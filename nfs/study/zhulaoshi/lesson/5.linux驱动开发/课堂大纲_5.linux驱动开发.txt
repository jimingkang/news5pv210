5.linux驱动开发
	5.1.驱动应该怎么学
	5.2.字符设备驱动基础
	5.3.字符设备驱动高级
	5.4.驱动框架入门之LED
	5.5.linux设备驱动模型
	5.6.misc类设备与蜂鸣器驱动
	5.7.framebuffer驱动详解
	5.8.input子系统基础之按键
	5.9.触摸屏驱动移植实战
	5.10.块设备驱动介绍
	5.11.网络设备驱动介绍
	

5.1.驱动应该怎么学
	5.1.1.什么是驱动1
	5.1.2.什么是驱动2
	5.1.3.模块化设计
	5.1.4.linux设备驱动分类
	5.1.5.驱动程序的安全性要求
	5.1.6.驱动应该这么学

5.2.字符设备驱动基础
	5.2.1.开启驱动开发之路
	5.2.2.最简单的模块源码分析1
	5.2.3.最简单的模块源码分析2
	5.2.4.最简单的模块源码分析3
	5.2.5.用开发板来调试模块
	5.2.6.字符设备驱动工作原理1
	5.2.7.字符设备驱动工作原理2
	5.2.8.字符设备驱动代码实践1
	5.2.9.字符设备驱动代码实践2
	5.2.10.应用程序如何调用驱动
	5.2.11.添加读写接口
	5.2.12.读写接口实践
	5.2.13.驱动中如何操控硬件
	5.2.14.静态映射操作LED1
	5.2.15.静态映射操作LED2
	5.2.16.静态映射操作LED3
	5.2.17.动态映射操作LED	

5.3.字符设备驱动高级
	5.3.1.注册字符设备驱动新接口1
	5.3.2.注册字符设备驱动新接口2
	5.3.3.注册字符设备驱动新接口3
	5.3.4.注册字符设备驱动新接口4
	5.3.5.字符设备驱动注册代码分析1
	5.3.6.字符设备驱动注册代码分析2
	5.3.7.自动创建字符设备驱动的设备文件
	5.3.8.设备类相关代码分析1
	5.3.9.设备类相关代码分析2
	5.3.10.静态映射表建立过程分析
	5.3.11.动态映射结构体方式操作寄存器
	5.3.12.内核提供的读写寄存器接口

5.4.驱动框架入门之LED
	5.4.1.何谓驱动框架
	5.4.2.内核驱动框架中LED的基本情况
	5.4.3.初步分析led驱动框架源码1
	5.4.4.初步分析led驱动框架源码2
	5.4.5.在内核中添加或去除某个驱动
	5.4.6.基于驱动框架写led驱动1
	5.4.7.基于驱动框架写led驱动2
	5.4.8.基于驱动框架写led驱动3
	5.4.9.linux内核的gpiolib学习1
	5.4.10.linux内核的gpiolib学习2
	5.4.11.linux内核的gpiolib学习3
	5.4.12.linux内核的gpiolib学习4
	5.4.13.linux内核的gpiolib学习5
	5.4.14.linux内核的gpiolib学习6
	5.4.15.linux内核的gpiolib学习7
	5.4.16.使用gpiolib完成led驱动
	5.4.17.将驱动添加到内核中

5.5.linux设备驱动模型
	5.5.1.linux设备驱动模型简介
	5.5.2.设备驱动模型的底层架构
	5.5.3.总线式设备驱动组织方式
	5.5.4.platform平台总线简介1
	5.5.5.platform平台总线工作原理2
	5.5.6.platform平台总线工作原理3
	5.5.7.平台总线实践环节1
	5.5.8.平台总线实践环节2
	5.5.9.平台总线实践环节3
	5.5.10.平台总线实践环节4

5.6.misc类设备与蜂鸣器驱动
	5.6.1.板载蜂鸣器驱动测试
	5.6.2.misc类设备介绍
	5.6.3.misc驱动框架源码分析1
	5.6.4.misc驱动框架源码分析2
	5.6.5.蜂鸣器驱动源码分析1
	5.6.6.蜂鸣器驱动源码分析2

5.7.framebuffer驱动详解
	5.7.1.framebuffer介绍
	5.7.2.framebuffer应用编程实践1
	5.7.3.framebuffer应用编程实践2
	5.7.4.framebuffer应用编程实践3
	5.7.5.framebuffer驱动框架总览
	5.7.6.framebuffer驱动框架分析1

5.8.input子系统基础之按键
	5.8.1.什么是input子系统
	5.8.2.input设备应用层编程实践1
	5.8.3.input设备应用层编程实践2
	5.8.4.input子系统架构总览1
	5.8.5.input子系统架构总览2
	5.8.6.输入核心层源码分析1
	5.8.7.输入核心层源码分析2
	5.8.8.输入事件驱动层源码分析
	5.8.9.输入设备驱动层源码分析1
	5.8.10.输入设备驱动层源码分析2
	5.8.11.中断方式按键驱动实战1
	5.8.12.中断方式按键驱动实战2


5.9.触摸屏驱动移植实战
	5.9.1.触摸屏驱动概览
	5.9.2.内核中的竞争状态和互斥1
	5.9.3.内核中的竞争状态和互斥2
	5.9.4.中断的上下半部1
	5.9.5.中断的上下半部2
	5.9.6.linux内核的I2C子系统详解1
	5.9.7.linux内核的I2C子系统详解2
	5.9.8.linux内核的I2C子系统详解3
	5.9.9.linux内核的I2C子系统详解4
	5.9.10.linux内核的I2C子系统详解5
	5.9.11.linux内核的I2C子系统详解6
	5.9.12.linux内核的I2C子系统详解7
	5.9.13.gslX680驱动的移植实践
	5.9.14.gslX680驱动源码分析2
	5.9.15.gslX680驱动源码分析2
	5.9.16.老版本触摸屏的驱动

5.10.块设备驱动介绍
	5.10.1.正确理解块设备驱动的概念
	5.10.2.块设备驱动框架简介
	5.10.3.块设备驱动案例分析1
	5.10.4.块设备驱动案例分析2
	5.10.5.块设备驱动案例分析3

5.11.网络设备驱动介绍
	5.11.1.网络设备驱动概述
	5.11.2.虚拟网卡驱动分析1
	5.11.3.虚拟网卡驱动分析2
	5.11.4.DM9000驱动源码分析1
	5.11.5.DM9000驱动源码分析2
















备选课题


C语言实现状态机

















































