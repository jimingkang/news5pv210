diff -urN u-boot-2013.10/arch/arm/cpu/armv7/s5pc1xx/clock.c u-boot-2013.10_aston/arch/arm/cpu/armv7/s5pc1xx/clock.c
--- u-boot-2013.10/arch/arm/cpu/armv7/s5pc1xx/clock.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/cpu/armv7/s5pc1xx/clock.c	2016-01-04 21:40:00.000000000 -0800
@@ -117,6 +117,8 @@
 	/* SDIV [2:0] */
 	s = r & 0x7;
 
+	printf("m = %d, p = %d, s = %d.\n", m, p, s);
+
 	freq = CONFIG_SYS_CLK_FREQ_C110;
 	if (pllreg == APLL) {
 		if (s < 1)
@@ -145,6 +147,9 @@
 	apll_ratio = div & 0x7;
 
 	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
+
+	printf("apll_ratio = %d.\n", apll_ratio+1);
+	
 	armclk = dout_apll;
 
 	return armclk;
@@ -305,10 +310,17 @@
 
 unsigned long get_arm_clk(void)
 {
+	//return s5pc110_get_arm_clk();
 	if (cpu_is_s5pc110())
+	{
+		printf("s5pc110_get_arm_clk\n");
 		return s5pc110_get_arm_clk();
+	}
 	else
+	{
+		printf("s5pc100_get_arm_clk\n");
 		return s5pc100_get_arm_clk();
+	}
 }
 
 unsigned long get_pwm_clk(void)
diff -urN u-boot-2013.10/arch/arm/cpu/armv7/s5p-common/cpu_info.c u-boot-2013.10_aston/arch/arm/cpu/armv7/s5p-common/cpu_info.c
--- u-boot-2013.10/arch/arm/cpu/armv7/s5p-common/cpu_info.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/cpu/armv7/s5p-common/cpu_info.c	2016-01-04 21:40:00.000000000 -0800
@@ -32,9 +32,27 @@
 {
 	char buf[32];
 
-	printf("CPU:\t%s%X@%sMHz\n",
+/*	printf("CPU:\t%s%X@%sMHz\n",
 			s5p_get_cpu_name(), s5p_cpu_id,
 			strmhz(buf, get_arm_clk()));
+*/
+	printf("\nCPU:  S5PV210@%sMHz(OK)\n", strmhz(buf, get_arm_clk()));
+
+
+/*
+	printf("	APLL = %ldMHz, HclkMsys = %ldMHz, PclkMsys = %ldMHz\n",
+				get_FCLK()/1000000, get_HCLK()/1000000, get_PCLK()/1000000);
+
+	printf("	MPLL = %ldMHz, EPLL = %ldMHz\n",
+				get_MPLL_CLK()/1000000, get_PLLCLK(EPLL)/1000000);
+	printf("			   HclkDsys = %ldMHz, PclkDsys = %ldMHz\n",
+				get_HCLKD()/1000000, get_PCLKD()/1000000);
+	printf("			   HclkPsys = %ldMHz, PclkPsys = %ldMHz\n",
+				get_HCLKP()/1000000, get_PCLKP()/1000000);
+	printf("			   SCLKA2M	= %ldMHz\n", get_SCLKA2M()/1000000);
+*/
+
+
 
 	return 0;
 }
diff -urN u-boot-2013.10/arch/arm/cpu/armv7/start.S u-boot-2013.10_aston/arch/arm/cpu/armv7/start.S
--- u-boot-2013.10/arch/arm/cpu/armv7/start.S	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/cpu/armv7/start.S	2016-01-04 21:40:00.000000000 -0800
@@ -19,6 +19,13 @@
 #include <asm/system.h>
 #include <linux/linkage.h>
 
+	// 添加16字节占位，否则和sd_fusing中mkbl1不适配，就会出现校验和失败
+	.word 0x2000
+	.word 0x0
+	.word 0x0
+	.word 0x0
+
+
 .globl _start
 _start: b	reset
 	ldr	pc, _undefined_instruction
@@ -65,11 +72,8 @@
 
 .globl _TEXT_BASE
 _TEXT_BASE:
-#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_TEXT_BASE)
-	.word	CONFIG_SPL_TEXT_BASE
-#else
 	.word	CONFIG_SYS_TEXT_BASE
-#endif
+
 
 /*
  * These are defined in the board-specific linker script.
@@ -86,6 +90,16 @@
 _end_ofs:
 	.word _end - _start
 
+.globl _bss_start
+_bss_start:
+	.word __bss_start
+	
+.globl _bss_end
+_bss_end:
+	.word _end
+
+	
+
 #ifdef CONFIG_USE_IRQ
 /* IRQ stack memory (calculated at run-time) */
 .globl IRQ_STACK_START
@@ -121,6 +135,7 @@
 	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
 	msr	cpsr,r0
 
+
 /*
  * Setup vector:
  * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
@@ -140,10 +155,65 @@
 	/* the mask ROM code should have PLL and others stable */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 	bl	cpu_init_cp15
+
+	// 函数在这里正常运行
 	bl	cpu_init_crit
+
 #endif
 
-	bl	_main
+	// 在cpu_init_crit函数中最后初始化完了DDR，然后在下面跳转到了第二阶段，所以
+	// 重定位代码就在这里进行
+
+	// 第一步: 加一个调试信息串口输出字符来做调试定位
+	// 打印字符'A'
+	ldr r1, =0x41414141
+	ldr r2, =0xE2900820
+	str r1, [r2]		@'A'
+
+	// 正式开始重定位
+	
+	/* get ready to call C functions */
+	ldr	sp, _TEXT_BASE	/* setup temp stack pointer */
+	sub	sp, sp, #12
+	mov	fp, #0			/* no previous frame, so fp=0 */
+
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     after_copy		/* r0 == r1 then skip flash copy   */
+
+/* If BL1 was copied from SD/MMC CH2 */
+	ldr	r0, =0xD0037488
+	ldr	r1, [r0]
+	ldr	r2, =0xEB200000
+	cmp	r1, r2
+	beq     mmcsd_boot
+	
+mmcsd_boot:
+		bl		movi_bl2_copy
+		b		after_copy
+
+after_copy:
+	// 这里有一些设置sp的代码，暂时不要，到时候不对了再说
+	
+clear_bss:
+	ldr	r0, _bss_start		/* find start of bss segment        */
+	ldr	r1, _bss_end		/* stop here                        */
+	mov 	r2, #0x00000000		/* clear                            */
+
+clbss_l:
+	str	r2, [r0]		/* clear loop...                    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	ble	clbss_l
+	
+//	bl	_main
+	// 第一阶段和第二阶段的分界点
+	ldr	pc, __main
+
+__main:	.word _main
 
 /*------------------------------------------------------------------------------*/
 
@@ -258,6 +328,7 @@
 	 * basic memory. Go here to bump up clock rate and handle
 	 * wake up conditions.
 	 */
+	 // 这里还是正常的
 	b	lowlevel_init		@ go setup pll,mux,memory
 ENDPROC(cpu_init_crit)
 #endif
diff -urN u-boot-2013.10/arch/arm/cpu/u-boot.lds u-boot-2013.10_aston/arch/arm/cpu/u-boot.lds
--- u-boot-2013.10/arch/arm/cpu/u-boot.lds	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/cpu/u-boot.lds	2016-01-04 21:40:00.000000000 -0800
@@ -19,6 +19,9 @@
 	{
 		*(.__image_copy_start)
 		CPUDIR/start.o (.text*)
+		board/samsung/goni/lowlevel_init.o (.text*)
+		board/samsung/goni/cpu_init.o (.text*)
+		board/samsung/goni/movi.o (.text*)
 		*(.text*)
 	}
 
diff -urN u-boot-2013.10/arch/arm/include/asm/arch-s5pc1xx/cpu.h u-boot-2013.10_aston/arch/arm/include/asm/arch-s5pc1xx/cpu.h
--- u-boot-2013.10/arch/arm/include/asm/arch-s5pc1xx/cpu.h	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/include/asm/arch-s5pc1xx/cpu.h	2016-01-04 21:40:00.000000000 -0800
@@ -63,6 +63,7 @@
 	return S5P_CPU_NAME;
 }
 
+
 #define IS_SAMSUNG_TYPE(type, id)			\
 static inline int cpu_is_##type(void)			\
 {							\
@@ -72,15 +73,27 @@
 IS_SAMSUNG_TYPE(s5pc100, 0xc100)
 IS_SAMSUNG_TYPE(s5pc110, 0xc110)
 
+/*
+static inline int cpu_is_s5pc110(void)			
+{							
+	return 1;				
+}
+
+static inline int cpu_is_s5pc100(void)			
+{							
+	return 0;				
+}
+*/
+
 #define SAMSUNG_BASE(device, base)				\
 static inline unsigned int samsung_get_base_##device(void)	\
-{								\
+{											\
 	if (cpu_is_s5pc100())					\
 		return S5PC100_##base;				\
 	else if (cpu_is_s5pc110())				\
 		return S5PC110_##base;				\
 	else							\
-		return 0;					\
+		return 0;					\	
 }
 
 SAMSUNG_BASE(clock, CLOCK_BASE)
diff -urN u-boot-2013.10/arch/arm/lib/board.c u-boot-2013.10_aston/arch/arm/lib/board.c
--- u-boot-2013.10/arch/arm/lib/board.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/lib/board.c	2016-01-04 21:40:00.000000000 -0800
@@ -519,7 +519,7 @@
 	monitor_flash_len = _end_ofs;
 
 	/* Enable caches */
-	enable_caches();
+	//enable_caches();
 
 	debug("monitor flash len: %08lX\n", monitor_flash_len);
 	board_init();	/* Setup chipselects */
diff -urN u-boot-2013.10/arch/arm/lib/crt0.S u-boot-2013.10_aston/arch/arm/lib/crt0.S
--- u-boot-2013.10/arch/arm/lib/crt0.S	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/arch/arm/lib/crt0.S	2016-01-04 21:40:00.000000000 -0800
@@ -80,7 +80,7 @@
  * relocate_code(addr_moni). Trick here is that we'll return
  * 'here' but relocated.
  */
-
+#if 0
 	ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd->start_addr_sp */
 	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
 	ldr	r9, [r9, #GD_BD]		/* r9 = gd->bd */
@@ -91,6 +91,7 @@
 	add	lr, lr, r0
 	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
 	b	relocate_code
+#endif
 here:
 
 /* Set up final (full) environment */
@@ -107,8 +108,8 @@
 	addlo	r0, r0, #4		/* move to next */
 	blo	clbss_l
 
-	bl coloured_LED_init
-	bl red_led_on
+	//bl coloured_LED_init
+	//bl red_led_on
 
 	/* call board_init_r(gd_t *id, ulong dest_addr) */
 	mov     r0, r9                  /* gd_t */
diff -urN u-boot-2013.10/board/samsung/goni/cpu_init.S u-boot-2013.10_aston/board/samsung/goni/cpu_init.S
--- u-boot-2013.10/board/samsung/goni/cpu_init.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/board/samsung/goni/cpu_init.S	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,357 @@
+#include <config.h>
+#include <s5pc110.h>
+
+	.globl mem_ctrl_asm_init
+mem_ctrl_asm_init:
+
+	/* DMC0 Drive Strength (Setting 2X) */
+	
+	ldr	r0, =ELFIN_GPIO_BASE
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_0DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_1DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_2DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_3DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_4DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_5DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_6DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP1_7DRV_SR_OFFSET]
+
+	ldr	r1, =0x00002AAA
+	str	r1, [r0, #MP1_8DRV_SR_OFFSET]
+
+
+	/* DMC1 Drive Strength (Setting 2X) */
+	
+	ldr	r0, =ELFIN_GPIO_BASE
+	
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_0DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_1DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_2DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_3DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_4DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_5DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_6DRV_SR_OFFSET]
+
+	ldr	r1, =0x0000AAAA
+	str	r1, [r0, #MP2_7DRV_SR_OFFSET]
+
+	ldr	r1, =0x00002AAA
+	str	r1, [r0, #MP2_8DRV_SR_OFFSET]
+	
+	/* DMC0 initialization at single Type*/
+	ldr	r0, =APB_DMC_0_BASE
+
+	ldr	r1, =0x00101000				@PhyControl0 DLL parameter setting, manual 0x00101000
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000086				@PhyControl1 DLL parameter setting, LPDDR/LPDDR2 Case
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00101002				@PhyControl0 DLL on
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00101003				@PhyControl0 DLL start
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+find_lock_val:
+	ldr	r1, [r0, #DMC_PHYSTATUS]		@Load Phystatus register value
+	and	r2, r1, #0x7
+	cmp	r2, #0x7				@Loop until DLL is locked
+	bne	find_lock_val
+	
+	and	r1, #0x3fc0 
+	mov	r2, r1, LSL #18
+	orr	r2, r2, #0x100000
+	orr	r2 ,r2, #0x1000	
+		
+	orr	r1, r2, #0x3				@Force Value locking
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+#if 0	/* Memory margin test 10.01.05 */
+	orr	r1, r2, #0x1				@DLL off
+	str	r1, [r0, #DMC_PHYCONTROL0]
+#endif
+	/* setting DDR2 */
+	ldr	r1, =0x0FFF2010				@ConControl auto refresh off
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =0x00212400				@MemControl BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+	
+	ldr	r1, =DMC0_MEMCONFIG_0			@MemConfig0 256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+	ldr	r1, =DMC0_MEMCONFIG_1			@MemConfig1
+	str	r1, [r0, #DMC_MEMCONFIG1]
+
+	ldr	r1, =0xFF000000				@PrechConfig
+	str	r1, [r0, #DMC_PRECHCONFIG]
+	
+	ldr	r1, =DMC0_TIMINGA_REF			@TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
+	str	r1, [r0, #DMC_TIMINGAREF]
+	
+	ldr	r1, =DMC0_TIMING_ROW			@TimingRow	for @200MHz
+	str	r1, [r0, #DMC_TIMINGROW]
+
+	ldr	r1, =DMC0_TIMING_DATA			@TimingData	CL=3
+	str	r1, [r0, #DMC_TIMINGDATA]
+	
+	ldr	r1, =DMC0_TIMING_PWR			@TimingPower
+	str	r1, [r0, #DMC_TIMINGPOWER]
+
+	ldr	r1, =0x07000000				@DirectCmd	chip0 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00020000				@DirectCmd	chip0 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00030000				@DirectCmd	chip0 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000542				@DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000442				@DirectCmd	chip0 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010780				@DirectCmd	chip0 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x07100000				@DirectCmd	chip1 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00120000				@DirectCmd	chip1 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00130000				@DirectCmd	chip1 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00100542				@DirectCmd	chip1 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00100442				@DirectCmd	chip1 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+	
+	ldr	r1, =0x00110780				@DirectCmd	chip1 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+		
+	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+		
+	ldr	r1, =0x0FF02030				@ConControl	auto refresh on
+	str	r1, [r0, #DMC_CONCONTROL]
+		
+	ldr	r1, =0xFFFF00FF				@PwrdnConfig
+	str	r1, [r0, #DMC_PWRDNCONFIG]
+		
+	ldr	r1, =0x00202400				@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+	/* DMC1 initialization */
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0x00101000				@Phycontrol0 DLL parameter setting
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000086				@Phycontrol1 DLL parameter setting
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00101002				@PhyControl0 DLL on
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00101003				@PhyControl0 DLL start
+	str	r1, [r0, #DMC_PHYCONTROL0]
+find_lock_val1:
+	ldr	r1, [r0, #DMC_PHYSTATUS]		@Load Phystatus register value
+	and	r2, r1, #0x7
+	cmp	r2, #0x7				@Loop until DLL is locked
+	bne	find_lock_val1
+	
+	and	r1, #0x3fc0 
+	mov	r2, r1, LSL #18
+	orr	r2, r2, #0x100000
+	orr	r2, r2, #0x1000
+		
+	orr	r1, r2, #0x3				@Force Value locking
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+#if 0	/* Memory margin test 10.01.05 */
+	orr	r1, r2, #0x1				@DLL off
+	str	r1, [r0, #DMC_PHYCONTROL0]
+#endif
+
+	/* settinf fot DDR2 */
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0x0FFF2010				@auto refresh off
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =DMC1_MEMCONTROL			@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+	ldr	r1, =DMC1_MEMCONFIG_0			@MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+	ldr	r1, =DMC1_MEMCONFIG_1			@MemConfig1
+	str	r1, [r0, #DMC_MEMCONFIG1]
+
+	ldr	r1, =0xFF000000
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =DMC1_TIMINGA_REF			@TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
+	str	r1, [r0, #DMC_TIMINGAREF]
+
+	ldr	r1, =DMC1_TIMING_ROW			@TimingRow	for @200MHz
+	str	r1, [r0, #DMC_TIMINGROW]
+
+	ldr	r1, =DMC1_TIMING_DATA			@TimingData	CL=3
+	str	r1, [r0, #DMC_TIMINGDATA]
+
+	ldr	r1, =DMC1_TIMING_PWR			@TimingPower
+	str	r1, [r0, #DMC_TIMINGPOWER]
+
+
+	ldr	r1, =0x07000000				@DirectCmd	chip0 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00020000				@DirectCmd	chip0 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00030000				@DirectCmd	chip0 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000542				@DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01000000				@DirectCmd	chip0 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05000000				@DirectCmd	chip0 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00000442				@DirectCmd	chip0 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010780				@DirectCmd	chip0 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00010400				@DirectCmd	chip0 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x07100000				@DirectCmd	chip1 Deselect
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00120000				@DirectCmd	chip1 EMRS2
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00130000				@DirectCmd	chip1 EMRS3
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00110440				@DirectCmd	chip1 EMRS1 (MEM DLL on, DQS# disable)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00100542				@DirectCmd	chip1 MRS (MEM DLL reset) CL=4, BL=4
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x01100000				@DirectCmd	chip1 PALL
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x05100000				@DirectCmd	chip1 REFA
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00100442				@DirectCmd	chip1 MRS (MEM DLL unreset)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00110780				@DirectCmd	chip1 EMRS1 (OCD default)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x00110400				@DirectCmd	chip1 EMRS1 (OCD exit)
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	ldr	r1, =0x0FF02030				@ConControl	auto refresh on
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =0xFFFF00FF				@PwrdnConfig	
+	str	r1, [r0, #DMC_PWRDNCONFIG]
+
+	ldr	r1, =DMC1_MEMCONTROL			@MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+	str	r1, [r0, #DMC_MEMCONTROL]
+	
+	mov	pc, lr
diff -urN u-boot-2013.10/board/samsung/goni/goni.c u-boot-2013.10_aston/board/samsung/goni/goni.c
--- u-boot-2013.10/board/samsung/goni/goni.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/board/samsung/goni/goni.c	2016-01-04 21:40:00.000000000 -0800
@@ -13,23 +13,59 @@
 #include <usb/s3c_udc.h>
 #include <asm/arch/cpu.h>
 #include <power/max8998_pmic.h>
+#include <s5pc110.h>
 DECLARE_GLOBAL_DATA_PTR;
 
 static struct s5pc110_gpio *s5pc110_gpio;
 
+
+static void dm9000_pre_init(void)
+{
+	unsigned int tmp;
+
+#if defined(DM9000_16BIT_DATA)
+//	SROM_BW_REG &= ~(0xf << 20);
+//	SROM_BW_REG |= (0<<23) | (0<<22) | (0<<21) | (1<<20);
+	SROM_BW_REG &= ~(0xf << 4);
+	SROM_BW_REG |= (1<<7) | (1<<6) | (1<<5) | (1<<4);
+
+#else	
+	SROM_BW_REG &= ~(0xf << 20);
+	SROM_BW_REG |= (0<<19) | (0<<18) | (0<<16);
+#endif
+//	SROM_BC5_REG = ((0<<28)|(1<<24)|(5<<16)|(1<<12)|(4<<8)|(6<<4)|(0<<0));
+	SROM_BC1_REG = ((0<<28)|(1<<24)|(5<<16)|(1<<12)|(4<<8)|(6<<4)|(0<<0));
+
+	tmp = MP01CON_REG;
+//	tmp &=~(0xf<<20);
+//	tmp |=(2<<20);
+	tmp &=~(0xf<<4);
+	tmp |=(2<<4);
+
+	MP01CON_REG = tmp;
+}
+
+
+
 int board_init(void)
 {
 	/* Set Initial global variables */
 	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
 
-	gd->bd->bi_arch_number = MACH_TYPE_GONI;
+	gd->bd->bi_arch_number = MACH_TYPE_SMDKV210;		// 在这里更改
 	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
 
+// 添加网卡初始化
+#ifdef CONFIG_DRIVER_DM9000
+	dm9000_pre_init();
+#endif
+
 	return 0;
 }
 
 int power_init_board(void)
 {
+#if 0
 	int ret;
 
 	/*
@@ -39,14 +75,13 @@
 	ret = pmic_init(I2C_0);
 	if (ret)
 		return ret;
-
+#endif
 	return 0;
 }
 
 int dram_init(void)
 {
-	gd->ram_size = PHYS_SDRAM_1_SIZE + PHYS_SDRAM_2_SIZE +
-			PHYS_SDRAM_3_SIZE;
+	gd->ram_size = PHYS_SDRAM_1_SIZE + PHYS_SDRAM_2_SIZE;
 
 	return 0;
 }
@@ -57,14 +92,14 @@
 	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
 	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
 	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
-	gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
-	gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
+	
 }
 
 #ifdef CONFIG_DISPLAY_BOARDINFO
 int checkboard(void)
 {
-	puts("Board:\tGoni\n");
+	//puts("Board:\tGoni\n");
+	puts("Board:\tAston210\n");
 	return 0;
 }
 #endif
@@ -72,10 +107,21 @@
 #ifdef CONFIG_GENERIC_MMC
 int board_mmc_init(bd_t *bis)
 {
+#ifdef CONFIG_S3C_HSMMC
+	setup_hsmmc_clock();
+	setup_hsmmc_cfg_gpio();
+	return smdk_s3c_hsmmc_init();
+#else
+	return 0;
+#endif
+
+	
+
+#if 0
 	int i, ret, ret_sd = 0;
 
 	/* MASSMEMORY_EN: XMSMDATA7: GPJ2[7] output high */
-	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);
+	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);			// GPJ2_7
 
 	/*
 	 * MMC0 GPIO
@@ -88,7 +134,7 @@
 		if (i == 2)
 			continue;
 		/* GPG0[0:6] special function 2 */
-		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);
+		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);		// GPG0_i 0x2
 		/* GPG0[0:6] pull disable */
 		s5p_gpio_set_pull(&s5pc110_gpio->g0, i, GPIO_PULL_NONE);
 		/* GPG0[0:6] drv 4x */
@@ -99,6 +145,23 @@
 	if (ret)
 		error("MMC: Failed to init MMC:0.\n");
 
+	for (i = 0; i < 7; i++) {
+		if (i == 2)
+			continue;
+
+		/* GPG2[0:6] special function 2 */
+		s5p_gpio_cfg_pin(&s5pc110_gpio->g2, i, 0x2);
+		/* GPG2[0:6] pull disable */
+		s5p_gpio_set_pull(&s5pc110_gpio->g2, i, GPIO_PULL_NONE);
+		/* GPG2[0:6] drv 4x */
+		s5p_gpio_set_drv(&s5pc110_gpio->g2, i, GPIO_DRV_4X);
+	}
+
+	ret_sd = s5p_mmc_init(2, 4);
+	if (ret_sd)
+		error("MMC: Failed to init SD card (MMC:2).\n");
+
+#if 0
 	/*
 	 * SD card (T_FLASH) detect and init
 	 * T_FLASH_DETECT: EINT28: GPH3[4] input mode
@@ -123,8 +186,10 @@
 		if (ret_sd)
 			error("MMC: Failed to init SD card (MMC:2).\n");
 	}
+#endif
 
 	return ret & ret_sd;
+#endif
 }
 #endif
 
diff -urN u-boot-2013.10/board/samsung/goni/lowlevel_init.S u-boot-2013.10_aston/board/samsung/goni/lowlevel_init.S
--- u-boot-2013.10/board/samsung/goni/lowlevel_init.S	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/board/samsung/goni/lowlevel_init.S	2016-01-04 21:40:00.000000000 -0800
@@ -12,6 +12,7 @@
 #include <asm/arch/cpu.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/power.h>
+#include <s5pc110.h>
 
 /*
  * Register usages:
@@ -167,6 +168,11 @@
 	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
 	str	r5, [r0]
 
+	// 我们添加的开发板供电制锁的代码
+	ldr r0, =0xE010E81C
+	ldr r1, =0x301
+	str r1, [r0]
+
 	/* setting SRAM */
 	ldreq	r0, =S5PC100_SROMC_BASE
 	ldrne	r0, =S5PC110_SROMC_BASE
@@ -195,10 +201,25 @@
 	str	r5, [r1, #0xf00]			@ INTADDRESS
 	str	r5, [r2, #0xf00]			@ INTADDRESS
 
+	// for clock init
+	bl	system_clock_init
+
 	/* for UART */
 	bl	uart_asm_init
 
-	bl	internal_ram_init
+	// DDR init
+	bl	mem_ctrl_asm_init
+
+	// 打印字符'K'
+	
+	ldr r1, =0x4b4b4b4b
+	ldr r2, =0xE2900820
+	str r1, [r2]		@'K'
+
+	mov	lr, r11
+	mov	pc, lr
+
+	//bl	internal_ram_init
 
 	cmp	r7, r8
 	/* Clear wakeup status register */
@@ -245,145 +266,201 @@
  * void system_clock_init(void)
  */
 system_clock_init:
-	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
+#if 0
+	ldr r0, =ELFIN_CLOCK_POWER_BASE @0xe0100000
+				
+	/* Set Mux to FIN */
+	ldr r1, =0x0
+	//str r1, [r0, #CLK_SRC0_OFFSET]
+	ldr r2, =0xE0100200
+	str r1, [r2]
+				
+	ldr r1, =APLL_LOCKTIME_VAL	
+	//str r1, [r0, #APLL_LOCK_OFFSET]
+	ldr r2, =0xE0100000
+	str r1, [r2]
+				
+	/* Disable PLL */
+retryloop:
+	ldr r1, =0x0
+	//str r1, [r0, #APLL_CON0_OFFSET]
+	ldr r2, =0xE0100100
+	str r1, [r2]
+	ldr r1, =0x0
+	//str r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+				
+	ldr r1, =0x0
+	//str r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+				
+	//ldr 	r1, [r0, #CLK_DIV0_OFFSET]
+	ldr r2, =0xE0100300
+	str r1, [r2]
+	ldr r2, =CLK_DIV0_MASK
+	bic r1, r1, r2
+				
+	ldr r2, =CLK_DIV0_VAL
+	orr r1, r1, r2
+	//str r1, [r0, #CLK_DIV0_OFFSET]
+	ldr r2, =0xE0100300
+	str r1, [r2]
+				
+	ldr r1, =APLL_VAL
+	//str r1, [r0, #APLL_CON0_OFFSET]
+	ldr r2, =0xE0100100
+	str r1, [r2]
+				
+	ldr r1, =MPLL_VAL
+	//str r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+				
+	ldr r1, =VPLL_VAL
+	//str r1, [r0, #VPLL_CON_OFFSET]
+	ldr r2, =0xE0100120
+	str r1, [r2]
+		
+	ldr r1, =AFC_ON
+	//str r1, [r0, #APLL_CON1_OFFSET]
+	ldr r2, =0xE0100104
+	str r1, [r2]
+		
+	mov r1, #0x10000
+1:	subs	r1, r1, #1
+	bne 1b
+				
+	/* MPLL software workaround */
+	//ldr r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+	orr 	r1, r1, #(1<<28)
+	//str r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+				
+	mov r1, #0x100
+1:	subs	r1, r1, #1
+	bne 1b
+				
+	//ldr r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+	and r1, r1, #(1<<29)
+	cmp r1, #(1<<29)
+	bne 	retryloop
+				
+	/* H/W lock detect disable */
+	//ldr r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+	bic 	r1, r1, #(1<<28)
+	//str r1, [r0, #MPLL_CON_OFFSET]
+	ldr r2, =0xE0100108
+	str r1, [r2]
+				
+	//ldr r1, [r0, #CLK_SRC0_OFFSET]
+	ldr r2, =0xE0100200
+	str r1, [r2]
+	ldr r2, =0x10001111
+	orr r1, r1, r2
+	//str r1, [r0, #CLK_SRC0_OFFSET]
+	ldr r2, =0xE0100200
+	str r1, [r2]
+				
+	/* CLK_DIV6 */
+	//ldr r1, [r0, #CLK_DIV6_OFFSET]
+	ldr r2, =0xE0100318
+	str r1, [r2]
+	bic r1, r1, #(0x7<<12)	@; ONENAND_RATIO: 0
+	//str r1, [r0, #CLK_DIV6_OFFSET]
+	ldr r2, =0xE0100318
+	str r1, [r2]
+				
+	mov pc, lr
+#endif
+
+#if 1
+	ldr r0, =ELFIN_CLOCK_POWER_BASE @0xe0100000
+		
+	/* Set Mux to FIN */
+	ldr r1, =0x0
+	str r1, [r0, #CLK_SRC0_OFFSET]
+		
+	ldr r1, =APLL_LOCKTIME_VAL
+	str r1, [r0, #APLL_LOCK_OFFSET]
+		
+	/* Disable PLL */
+retryloop:
+	ldr r1, =0x0
+	str r1, [r0, #APLL_CON0_OFFSET]
+	ldr r1, =0x0
+	str r1, [r0, #MPLL_CON_OFFSET]
+		
+	ldr r1, =0x0
+	str r1, [r0, #MPLL_CON_OFFSET]
+		
+	ldr 	r1, [r0, #CLK_DIV0_OFFSET]
+	ldr r2, =CLK_DIV0_MASK
+	bic r1, r1, r2
+		
+	ldr r2, =CLK_DIV0_VAL
+	orr r1, r1, r2
+	str r1, [r0, #CLK_DIV0_OFFSET]
+		
+	ldr r1, =APLL_VAL
+	str r1, [r0, #APLL_CON0_OFFSET]
+		
+	ldr r1, =MPLL_VAL
+	str r1, [r0, #MPLL_CON_OFFSET]
+		
+	ldr r1, =VPLL_VAL
+	str r1, [r0, #VPLL_CON_OFFSET]
+#if defined(CONFIG_EVT1)
+	ldr r1, =AFC_ON
+	str r1, [r0, #APLL_CON1_OFFSET]
+#endif
+	mov r1, #0x10000
+1:	subs	r1, r1, #1
+	bne 1b
+		
+
+	/* MPLL software workaround */
+	ldr r1, [r0, #MPLL_CON_OFFSET]
+	orr 	r1, r1, #(1<<28)
+	str r1, [r0, #MPLL_CON_OFFSET]
+		
+	mov r1, #0x100
+1:	subs	r1, r1, #1
+	bne 1b
+		
+	ldr r1, [r0, #MPLL_CON_OFFSET]
+	and r1, r1, #(1<<29)
+	cmp r1, #(1<<29)
+	bne 	retryloop
+	
+	/* H/W lock detect disable */
+	ldr r1, [r0, #MPLL_CON_OFFSET]
+	bic 	r1, r1, #(1<<28)
+	str r1, [r0, #MPLL_CON_OFFSET]
+
+		
+	ldr r1, [r0, #CLK_SRC0_OFFSET]
+	ldr r2, =0x10001111
+	orr r1, r1, r2
+	str r1, [r0, #CLK_SRC0_OFFSET]
+				
+	/* CLK_DIV6 */
+	ldr r1, [r0, #CLK_DIV6_OFFSET]
+	bic r1, r1, #(0x7<<12)	@; ONENAND_RATIO: 0
+	str r1, [r0, #CLK_DIV6_OFFSET]
+		
+	mov pc, lr
+#endif
 
-	/* Check S5PC100 */
-	cmp	r7, r8
-	bne	110f
-100:
-	/* Set Lock Time */
-	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
-	str	r1, [r0, #0x000]		@ S5PC100_APLL_LOCK
-	str	r1, [r0, #0x004]		@ S5PC100_MPLL_LOCK
-	str	r1, [r0, #0x008]		@ S5PC100_EPLL_LOCK
-	str	r1, [r0, #0x00C]		@ S5PC100_HPLL_LOCK
-
-	/* S5P_APLL_CON */
-	ldr	r1, =0x81bc0400		@ SDIV 0, PDIV 4, MDIV 444 (1333MHz)
-	str	r1, [r0, #0x100]
-	/* S5P_MPLL_CON */
-	ldr	r1, =0x80590201		@ SDIV 1, PDIV 2, MDIV 89 (267MHz)
-	str	r1, [r0, #0x104]
-	/* S5P_EPLL_CON */
-	ldr	r1, =0x80870303		@ SDIV 3, PDIV 3, MDIV 135 (67.5MHz)
-	str	r1, [r0, #0x108]
-	/* S5P_HPLL_CON */
-	ldr	r1, =0x80600603		@ SDIV 3, PDIV 6, MDIV 96
-	str	r1, [r0, #0x10C]
-
-	ldr     r1, [r0, #0x300]
-	ldr     r2, =0x00003fff
-	bic     r1, r1, r2
-	ldr     r2, =0x00011301
 
-	orr	r1, r1, r2
-	str	r1, [r0, #0x300]
-	ldr     r1, [r0, #0x304]
-	ldr     r2, =0x00011110
-	orr     r1, r1, r2
-	str     r1, [r0, #0x304]
-	ldr     r1, =0x00000001
-	str     r1, [r0, #0x308]
-
-	/* Set Source Clock */
-	ldr	r1, =0x00001111			@ A, M, E, HPLL Muxing
-	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
-
-	b	200f
-110:
-	ldr	r0, =0xE010C000			@ S5PC110_PWR_CFG
-
-	/* Set OSC_FREQ value */
-	ldr	r1, =0xf
-	str	r1, [r0, #0x100]		@ S5PC110_OSC_FREQ
-
-	/* Set MTC_STABLE value */
-	ldr	r1, =0xffffffff
-	str	r1, [r0, #0x110]		@ S5PC110_MTC_STABLE
-
-	/* Set CLAMP_STABLE value */
-	ldr	r1, =0x3ff03ff
-	str	r1, [r0, #0x114]		@ S5PC110_CLAMP_STABLE
-
-	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
-
-	/* Set Clock divider */
-	ldr	r1, =0x14131330			@ 1:1:4:4, 1:4:5
-	str	r1, [r0, #0x300]
-	ldr	r1, =0x11110111			@ UART[3210]: MMC[3210]
-	str	r1, [r0, #0x310]
-
-	/* Set Lock Time */
-	ldr	r1, =0x2cf			@ Locktime : 30us
-	str	r1, [r0, #0x000]		@ S5PC110_APLL_LOCK
-	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
-	str	r1, [r0, #0x008]		@ S5PC110_MPLL_LOCK
-	str	r1, [r0, #0x010]		@ S5PC110_EPLL_LOCK
-	str	r1, [r0, #0x020]		@ S5PC110_VPLL_LOCK
-
-	/* S5PC110_APLL_CON */
-	ldr	r1, =0x80C80601			@ 800MHz
-	str	r1, [r0, #0x100]
-	/* S5PC110_MPLL_CON */
-	ldr	r1, =0x829B0C01			@ 667MHz
-	str	r1, [r0, #0x108]
-	/* S5PC110_EPLL_CON */
-	ldr	r1, =0x80600602			@  96MHz VSEL 0 P 6 M 96 S 2
-	str	r1, [r0, #0x110]
-	/* S5PC110_VPLL_CON */
-	ldr	r1, =0x806C0603			@  54MHz
-	str	r1, [r0, #0x120]
-
-	/* Set Source Clock */
-	ldr	r1, =0x10001111			@ A, M, E, VPLL Muxing
-	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
-
-	/* OneDRAM(DMC0) clock setting */
-	ldr	r1, =0x01000000			@ ONEDRAM_SEL[25:24] 1 SCLKMPLL
-	str	r1, [r0, #0x218]		@ S5PC110_CLK_SRC6
-	ldr	r1, =0x30000000			@ ONEDRAM_RATIO[31:28] 3 + 1
-	str	r1, [r0, #0x318]		@ S5PC110_CLK_DIV6
-
-	/* XCLKOUT = XUSBXTI 24MHz */
-	add	r2, r0, #0xE000			@ S5PC110_OTHERS
-	ldr     r1, [r2]
-	orr	r1, r1, #(0x3 << 8)		@ CLKOUT[9:8] 3 XUSBXTI
-	str	r1, [r2]
-
-	/* CLK_IP0 */
-	ldr	r1, =0x8fefeeb			@ DMC[1:0] PDMA0[3] IMEM[5]
-	str	r1, [r0, #0x460]		@ S5PC110_CLK_IP0
-
-	/* CLK_IP1 */
-	ldr	r1, =0xe9fdf0f9			@ FIMD[0] USBOTG[16]
-						@ NANDXL[24]
-	str	r1, [r0, #0x464]		@ S5PC110_CLK_IP1
-
-	/* CLK_IP2 */
-	ldr	r1, =0xf75f7fc			@ CORESIGHT[8] MODEM[9]
-						@ HOSTIF[10] HSMMC0[16]
-						@ HSMMC2[18] VIC[27:24]
-	str	r1, [r0, #0x468]		@ S5PC110_CLK_IP2
-
-	/* CLK_IP3 */
-	ldr	r1, =0x8eff038c			@ I2C[8:6]
-						@ SYSTIMER[16] UART0[17]
-						@ UART1[18] UART2[19]
-						@ UART3[20] WDT[22]
-						@ PWM[23] GPIO[26] SYSCON[27]
-	str	r1, [r0, #0x46c]		@ S5PC110_CLK_IP3
-
-	/* CLK_IP4 */
-	ldr	r1, =0xfffffff1			@ CHIP_ID[0] TZPC[8:5]
-	str	r1, [r0, #0x470]		@ S5PC110_CLK_IP3
-
-200:
-	/* wait at least 200us to stablize all clock */
-	mov	r2, #0x10000
-1:	subs	r2, r2, #1
-	bne	1b
-
-	mov	pc, lr
 
 internal_ram_init:
 	ldreq	r0, =0xE3800000
@@ -446,4 +523,9 @@
 	orr	r1, r1, #(1 << 7)		@ 7 = 7 * 1-bit
 	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
 200:
+	// 串口2输出字符'O'
+	ldr	r1, =0x4f4f4f4f
+	ldr r2, =0xE2900820
+	str	r1, [r2]		@'O'
+
 	mov	pc, lr
diff -urN u-boot-2013.10/board/samsung/goni/Makefile u-boot-2013.10_aston/board/samsung/goni/Makefile
--- u-boot-2013.10/board/samsung/goni/Makefile	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/board/samsung/goni/Makefile	2016-01-04 21:40:00.000000000 -0800
@@ -12,13 +12,17 @@
 
 LIB	= $(obj)lib$(BOARD).o
 
-COBJS-y	:= goni.o onenand.o
-SOBJS	:= lowlevel_init.o
+COBJS-y	:= goni.o setup_hsmmc.o
+#SOBJS	:= lowlevel_init.o
+LOW 	:= lowlevel_init.o cpu_init.o movi.o
 
 SRCS    := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS-y))
 SOBJS	:= $(addprefix $(obj),$(SOBJS))
 
+
+all:	$(obj).depend $(LOW) $(LIB)
+
 $(LIB):	$(obj).depend $(SOBJS) $(OBJS)
 	$(call cmd_link_o_target, $(SOBJS) $(OBJS))
 
diff -urN u-boot-2013.10/board/samsung/goni/movi.c u-boot-2013.10_aston/board/samsung/goni/movi.c
--- u-boot-2013.10/board/samsung/goni/movi.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/board/samsung/goni/movi.c	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,44 @@
+#include <common.h>
+#include <s5pc110.h>
+
+#include <movi.h>
+#include <asm/io.h>
+//#include <regs.h>
+#include <mmc.h>
+
+
+
+
+typedef u32(*copy_sd_mmc_to_mem)
+(u32 channel, u32 start_block, u16 block_size, u32 *trg, u32 init);
+
+void movi_bl2_copy(void)
+{
+	ulong ch;
+
+	ch = *(volatile u32 *)(0xD0037488);
+	copy_sd_mmc_to_mem copy_bl2 =
+	    (copy_sd_mmc_to_mem) (*(u32 *) (0xD0037F98));
+
+	u32 ret;
+	if (ch == 0xEB000000) {
+		ret = copy_bl2(0, MOVI_BL2_POS, MOVI_BL2_BLKCNT,
+			CFG_PHY_UBOOT_BASE, 0);
+	}
+	else if (ch == 0xEB200000) {
+		ret = copy_bl2(2, MOVI_BL2_POS, MOVI_BL2_BLKCNT,
+			CFG_PHY_UBOOT_BASE, 0);
+	}
+	else
+		return;
+
+	if (ret == 0)
+		while (1)
+			;
+	else
+		return;
+}
+
+
+
+
diff -urN u-boot-2013.10/board/samsung/goni/setup_hsmmc.c u-boot-2013.10_aston/board/samsung/goni/setup_hsmmc.c
--- u-boot-2013.10/board/samsung/goni/setup_hsmmc.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/board/samsung/goni/setup_hsmmc.c	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,140 @@
+
+#include <common.h>
+//#include <regs.h>
+#include <asm/io.h>
+#include <mmc.h>
+#include <s3c_hsmmc.h>
+#include <s5pc110.h>
+#include <asm/arch/clk.h>
+
+void setup_hsmmc_clock(void)
+{
+	u32 tmp;
+	u32 clock;
+	u32 i;
+
+	/* MMC0 clock src = SCLKMPLL */
+	tmp = CLK_SRC4_REG & ~(0x0000000f);
+	CLK_SRC4_REG = tmp | 0x00000006;
+
+	/* MMC0 clock div */
+	tmp = CLK_DIV4_REG & ~(0x0000000f);
+	//clock = get_MPLL_CLK()/1000000;
+	clock = get_pll_clk(MPLL)/1000000;
+
+	for(i=0; i<0xf; i++)
+	{
+		if((clock / (i+1)) <= 50) {
+			CLK_DIV4_REG = tmp | i<<0;
+			break;
+		}
+	}
+
+#ifdef USE_MMC1
+	/* MMC1 clock src = SCLKMPLL */
+	tmp = CLK_SRC4_REG & ~(0x000000f0);
+	CLK_SRC4_REG = tmp | 0x00000060;
+
+	/* MMC1 clock div */
+	tmp = CLK_DIV4_REG & ~(0x000000f0);
+	CLK_DIV4_REG = tmp | i<<4;
+#endif	
+
+#ifdef USE_MMC2
+	/* MMC2 clock src = SCLKMPLL */
+	tmp = CLK_SRC4_REG & ~(0x00000f00);
+	CLK_SRC4_REG = tmp | 0x00000600;
+
+	/* MMC2 clock div */
+	tmp = CLK_DIV4_REG & ~(0x00000f00);
+	CLK_DIV4_REG = tmp | i<<8;
+#endif
+
+#ifdef USE_MMC3
+	/* MMC3 clock src = SCLKMPLL */
+	tmp = CLK_SRC4_REG & ~(0x00000f00);
+	CLK_SRC4_REG = tmp | 0x00000600;
+
+	/* MMC3 clock div */
+	tmp = CLK_DIV4_REG & ~(0x00000f00);
+	CLK_DIV4_REG = tmp | i<<12;
+#endif	
+}
+
+/*
+ * this will set the GPIO for hsmmc ch0
+ * GPG0[0:6] = CLK, CMD, CDn, DAT[0:3]
+ */
+void setup_hsmmc_cfg_gpio(void)
+{
+	ulong reg;
+
+	/* MMC channel 0 */
+	/* 7 pins will be assigned - GPG0[0:6] = CLK, CMD, CDn, DAT[0:3] */
+	reg = readl(GPG0CON) & 0xf0000000;
+	writel(reg | 0x02222222, GPG0CON);
+	reg = readl(GPG0PUD) & 0xffffc000;
+	writel(reg | 0x00002aaa, GPG0PUD);
+	writel(0x00003fff, GPG0DRV);
+
+#ifdef USE_MMC1
+	/* MMC channel 1 */
+	/* 7 pins will be assigned - GPG1[0:6] = CLK, CMD, CDn, DAT[0:3] */
+	reg = readl(GPG1CON) & 0xf0000000;
+	writel(reg | 0x02222222, GPG1CON);
+	reg = readl(GPG1PUD) & 0xffffc000;
+	writel(reg | 0x00002aaa, GPG1PUD);
+	writel(0x00003fff, GPG1DRV);
+#endif
+
+#ifdef USE_MMC2
+	/* MMC channel 2 */
+	/* 7 pins will be assigned - GPG2[0:6] = CLK, CMD, CDn, DAT[0:3] */
+	reg = readl(GPG2CON) & 0xf0000000;
+	writel(reg | 0x02222222, GPG2CON);
+	reg = readl(GPG2PUD) & 0xffffc000;
+	writel(reg | 0x00002aaa, GPG2PUD);
+	writel(0x00003fff, GPG2DRV);
+#endif
+
+#ifdef USE_MMC3
+	/* MMC channel 3 */
+	/* 7 pins will be assigned - GPG0[0:6] = CLK, CMD, CDn, DAT[0:3] */
+	reg = readl(GPG3CON) & 0xf0000000;
+	writel(reg | 0x02222222, GPG3CON);
+	reg = readl(GPG3PUD) & 0xffffc000;
+	writel(reg | 0x00002aaa, GPG3PUD);
+	writel(0x00003fff, GPG3DRV);
+#endif
+}
+
+
+void setup_sdhci0_cfg_card(struct sdhci_host *host)
+{
+	u32 ctrl2;
+	u32 ctrl3;
+
+	/* don't need to alter anything acording to card-type */
+	writel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA, host->ioaddr + S3C64XX_SDHCI_CONTROL4);
+
+	ctrl2 = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
+
+	ctrl2 |= (S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR |
+		  S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |
+		  S3C_SDHCI_CTRL2_DFCNT_NONE |
+		  S3C_SDHCI_CTRL2_ENCLKOUTHOLD);
+
+	if (host->clock <= 500000) {
+		ctrl2 &= ~(S3C_SDHCI_CTRL2_ENFBCLKTX |
+			S3C_SDHCI_CTRL2_ENFBCLKRX);
+		ctrl3 = 0;
+	} else {
+		ctrl2 |= S3C_SDHCI_CTRL2_ENFBCLKTX |
+			S3C_SDHCI_CTRL2_ENFBCLKRX;
+		ctrl3 = S3C_SDHCI_CTRL3_FCSEL3 | S3C_SDHCI_CTRL3_FCSEL2;
+	}
+
+	writel(ctrl2, host->ioaddr + S3C_SDHCI_CONTROL2);
+	writel(ctrl3, host->ioaddr + S3C_SDHCI_CONTROL3);
+}
+
diff -urN u-boot-2013.10/common/cmd_mmc.c u-boot-2013.10_aston/common/cmd_mmc.c
--- u-boot-2013.10/common/cmd_mmc.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/common/cmd_mmc.c	2016-01-04 21:40:00.000000000 -0800
@@ -2,426 +2,234 @@
  * (C) Copyright 2003
  * Kyle Harris, kharris@nexus-tech.net
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
 #include <command.h>
 #include <mmc.h>
 
-static int curr_device = -1;
+#define MAXIMUM_BLOCK_COUNT 0xFFFF
+
 #ifndef CONFIG_GENERIC_MMC
-int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	int dev;
-
-	if (argc < 2)
-		return CMD_RET_USAGE;
-
-	if (strcmp(argv[1], "init") == 0) {
-		if (argc == 2) {
-			if (curr_device < 0)
-				dev = 1;
-			else
-				dev = curr_device;
-		} else if (argc == 3) {
-			dev = (int)simple_strtoul(argv[2], NULL, 10);
-		} else {
-			return CMD_RET_USAGE;
-		}
-
-		if (mmc_legacy_init(dev) != 0) {
-			puts("No MMC card found\n");
-			return 1;
-		}
-
-		curr_device = dev;
-		printf("mmc%d is available\n", curr_device);
-	} else if (strcmp(argv[1], "device") == 0) {
-		if (argc == 2) {
-			if (curr_device < 0) {
-				puts("No MMC device available\n");
-				return 1;
-			}
-		} else if (argc == 3) {
-			dev = (int)simple_strtoul(argv[2], NULL, 10);
-
-#ifdef CONFIG_SYS_MMC_SET_DEV
-			if (mmc_set_dev(dev) != 0)
-				return 1;
-#endif
-			curr_device = dev;
-		} else {
-			return CMD_RET_USAGE;
-		}
-
-		printf("mmc%d is current device\n", curr_device);
-	} else {
-		return CMD_RET_USAGE;
+	if (mmc_init (1) != 0) {
+		printf ("No MMC card found\n");
+		return 1;
 	}
-
 	return 0;
 }
 
 U_BOOT_CMD(
-	mmc, 3, 1, do_mmc,
-	"MMC sub-system",
-	"init [dev] - init MMC sub system\n"
-	"mmc device [dev] - show or set current device"
+	mmcinit,	1,	0,	do_mmc,
+	"mmcinit - init mmc card\n",
+	NULL
 );
 #else /* !CONFIG_GENERIC_MMC */
 
-enum mmc_state {
-	MMC_INVALID,
-	MMC_READ,
-	MMC_WRITE,
-	MMC_ERASE,
-};
-static void print_mmcinfo(struct mmc *mmc)
+static void print_mmcinfo(struct mmc *host)
 {
-	printf("Device: %s\n", mmc->name);
-	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
-	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
-	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
-			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
-			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
-
-	printf("Tran Speed: %d\n", mmc->tran_speed);
-	printf("Rd Block Len: %d\n", mmc->read_bl_len);
-
-	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
-			(mmc->version >> 8) & 0xf, mmc->version & 0xff);
-
-	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
-	puts("Capacity: ");
-	print_size(mmc->capacity, "\n");
+	printf("Device: %s\n", host->name);
+	printf("Manufacturer ID: %x\n", host->cid[0] >> 24);
+	printf("RCA: %x\n", host->rca);
+	printf("OEM: %x\n", (host->cid[0] >> 8) & 0xffff);
+	printf("Name: %c%c%c%c%c \n", host->cid[0] & 0xff,
+			(host->cid[1] >> 24), (host->cid[1] >> 16) & 0xff,
+			(host->cid[1] >> 8) & 0xff, host->cid[1] & 0xff);
+
+	printf("Tran Speed: %d\n", host->clock);
+	printf("Rd Block Len: %d\n", host->read_bl_len);
+
+	printf("%s version %d.%d\n", IS_SD(host) ? "SD" : "MMC",
+			(host->version >> 4) & 0xf, host->version & 0xf);
+
+	printf("High Capacity: %s\n", host->high_capacity ? "Yes" : "No");
+	printf("Size: %dMB (block: %d)\n",
+			(host->capacity/(1024*1024/host->read_bl_len)),
+			host->capacity);
 
-	printf("Bus Width: %d-bit\n", mmc->bus_width);
+	printf("Bus Width: %d-bit\n\n", host->bus_width);
 }
 
-static int do_mmcinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	struct mmc *mmc;
+	int dev_num;
+	int err;
 
-	if (curr_device < 0) {
-		if (get_mmc_num() > 0)
-			curr_device = 0;
-		else {
-			puts("No MMC device available\n");
-			return 1;
-		}
-	}
+	if (argc < 2)
+		dev_num = 0;
+	else
+		dev_num = simple_strtoul(argv[1], NULL, 0);
 
-	mmc = find_mmc_device(curr_device);
+	mmc = find_mmc_device(dev_num);
 
 	if (mmc) {
-		mmc_init(mmc);
+		err = mmc_init(mmc);
+		if(err)
+			return err;
 
 		print_mmcinfo(mmc);
-		return 0;
-	} else {
-		printf("no mmc device at slot %x\n", curr_device);
-		return 1;
 	}
-}
-
-U_BOOT_CMD(
-	mmcinfo, 1, 0, do_mmcinfo,
-	"display MMC info",
-	"- display info of the current MMC device"
-);
 
-#ifdef CONFIG_SUPPORT_EMMC_BOOT
-static int boot_part_access(struct mmc *mmc, u8 ack, u8 part_num, u8 access)
-{
-	int err;
-	err = mmc_boot_part_access(mmc, ack, part_num, access);
-
-	if ((err == 0) && (access != 0)) {
-		printf("\t\t\t!!!Notice!!!\n");
-
-		printf("!You must close EMMC boot Partition");
-		printf("after all images are written\n");
-
-		printf("!EMMC boot partition has continuity");
-		printf("at image writing time.\n");
-
-		printf("!So, do not close the boot partition");
-		printf("before all images are written.\n");
-		return 0;
-	} else if ((err == 0) && (access == 0))
-		return 0;
-	else if ((err != 0) && (access != 0)) {
-		printf("EMMC boot partition-%d OPEN Failed.\n", part_num);
-		return 1;
-	} else {
-		printf("EMMC boot partition-%d CLOSE Failed.\n", part_num);
-		return 1;
-	}
+	return 0;
 }
-#endif
 
-static int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	enum mmc_state state;
-
-	if (argc < 2)
-		return CMD_RET_USAGE;
+U_BOOT_CMD(mmcinfo,	2,	0,	do_mmcinfo,
+	"print MMC information",
+	"<dev num>\n");
 
-	if (curr_device < 0) {
-		if (get_mmc_num() > 0)
-			curr_device = 0;
-		else {
-			puts("No MMC device available\n");
-			return 1;
-		}
-	}
+int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int rc = 0;
 
-	if (strcmp(argv[1], "rescan") == 0) {
-		struct mmc *mmc;
+	switch (argc) {
+	case 3:
+		if (strcmp(argv[1], "rescan") == 0) {
+			int dev = simple_strtoul(argv[2], NULL, 10);
+			struct mmc *mmc = find_mmc_device(dev);
 
-		if (argc != 2)
-			return CMD_RET_USAGE;
+			if (!mmc)
+				return 1;
 
-		mmc = find_mmc_device(curr_device);
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", curr_device);
-			return 1;
+			rc = mmc_init(mmc);
+			return rc;
 		}
 
-		mmc->has_init = 0;
+	case 0:
+	case 1:
+	case 4:
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
 
-		if (mmc_init(mmc))
-			return 1;
-		else
-			return 0;
-	} else if (strncmp(argv[1], "part", 4) == 0) {
-		block_dev_desc_t *mmc_dev;
-		struct mmc *mmc;
-
-		if (argc != 2)
-			return CMD_RET_USAGE;
-
-		mmc = find_mmc_device(curr_device);
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", curr_device);
-			return 1;
-		}
-		mmc_init(mmc);
-		mmc_dev = mmc_get_dev(curr_device);
-		if (mmc_dev != NULL &&
-				mmc_dev->type != DEV_TYPE_UNKNOWN) {
-			print_part(mmc_dev);
+	case 2:
+		if (!strcmp(argv[1], "list")) {
+			print_mmc_devices('\n');
 			return 0;
 		}
-
-		puts("get mmc type error!\n");
 		return 1;
-	} else if (strcmp(argv[1], "list") == 0) {
-		if (argc != 2)
-			return CMD_RET_USAGE;
-		print_mmc_devices('\n');
-		return 0;
-	} else if (strcmp(argv[1], "dev") == 0) {
-		int dev, part = -1;
-		struct mmc *mmc;
-
-		if (argc == 2)
-			dev = curr_device;
-		else if (argc == 3)
-			dev = simple_strtoul(argv[2], NULL, 10);
-		else if (argc == 4) {
-			dev = (int)simple_strtoul(argv[2], NULL, 10);
-			part = (int)simple_strtoul(argv[3], NULL, 10);
-			if (part > PART_ACCESS_MASK) {
-				printf("#part_num shouldn't be larger"
-					" than %d\n", PART_ACCESS_MASK);
-				return 1;
-			}
-		} else
-			return CMD_RET_USAGE;
-
-		mmc = find_mmc_device(dev);
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", dev);
-			return 1;
-		}
+	default: /* at least 5 args */
+		if (strcmp(argv[1], "read") == 0) {
+			int dev = simple_strtoul(argv[2], NULL, 10);
+			void *addr = (void *)simple_strtoul(argv[3], NULL, 16);
+			u32 cnt = simple_strtoul(argv[5], NULL, 10);
+			u32 blk = simple_strtoul(argv[4], NULL, 10);
+			u32 n;
+			u32 read_cnt;
+			u32 cnt_to_read;
+			void *addr_to_read;
+			struct mmc *mmc = find_mmc_device(dev);
 
-		mmc_init(mmc);
-		if (part != -1) {
-			int ret;
-			if (mmc->part_config == MMCPART_NOAVAILABLE) {
-				printf("Card doesn't support part_switch\n");
+			if (!mmc)
 				return 1;
-			}
-
-			if (part != mmc->part_num) {
-				ret = mmc_switch_part(dev, part);
-				if (!ret)
-					mmc->part_num = part;
-
-				printf("switch to partitions #%d, %s\n",
-						part, (!ret) ? "OK" : "ERROR");
-			}
-		}
-		curr_device = dev;
-		if (mmc->part_config == MMCPART_NOAVAILABLE)
-			printf("mmc%d is current device\n", curr_device);
-		else
-			printf("mmc%d(part %d) is current device\n",
-				curr_device, mmc->part_num);
-
-		return 0;
-#ifdef CONFIG_SUPPORT_EMMC_BOOT
-	} else if ((strcmp(argv[1], "open") == 0) ||
-			(strcmp(argv[1], "close") == 0)) {
-		int dev;
-		struct mmc *mmc;
-		u8 part_num, access = 0;
-
-		if (argc == 4) {
-			dev = simple_strtoul(argv[2], NULL, 10);
-			part_num = simple_strtoul(argv[3], NULL, 10);
-		} else {
-			return CMD_RET_USAGE;
-		}
 
-		mmc = find_mmc_device(dev);
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", dev);
-			return 1;
-		}
+			printf("\nMMC read: dev # %d, block # %d, count %d ...",
+				dev, blk, cnt);
 
-		if (IS_SD(mmc)) {
-			printf("SD device cannot be opened/closed\n");
-			return 1;
-		}
+			rc = mmc_init(mmc);
+			if(rc)
+				return rc;
+
+			n = 0;
+			addr_to_read = addr;
+			do {
+				if (cnt - n > MAXIMUM_BLOCK_COUNT)
+					cnt_to_read = MAXIMUM_BLOCK_COUNT;
+				else
+					cnt_to_read = cnt - n;
+
+				read_cnt = mmc->block_dev.block_read(dev, blk, cnt_to_read, addr_to_read);
+				n += read_cnt;
+				blk += read_cnt;
+				addr_to_read += read_cnt * 512;
+				if(cnt_to_read != read_cnt) {
+					printf("%d blocks read: %s\n",
+						n, "ERROR");
+					return -1;
+				}
+			} while(cnt > n);
 
-		if ((part_num <= 0) || (part_num > MMC_NUM_BOOT_PARTITION)) {
-			printf("Invalid boot partition number:\n");
-			printf("Boot partition number cannot be <= 0\n");
-			printf("EMMC44 supports only 2 boot partitions\n");
-			return 1;
-		}
-
-		if (strcmp(argv[1], "open") == 0)
-			access = part_num; /* enable R/W access to boot part*/
-		else
-			access = 0; /* No access to boot partition */
-
-		/* acknowledge to be sent during boot operation */
-		return boot_part_access(mmc, 1, part_num, access);
-
-	} else if (strcmp(argv[1], "bootpart") == 0) {
-		int dev;
-		dev = simple_strtoul(argv[2], NULL, 10);
-
-		u32 bootsize = simple_strtoul(argv[3], NULL, 10);
-		u32 rpmbsize = simple_strtoul(argv[4], NULL, 10);
-		struct mmc *mmc = find_mmc_device(dev);
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", dev);
-			return 1;
-		}
-
-		if (IS_SD(mmc)) {
-			printf("It is not a EMMC device\n");
-			return 1;
-		}
+			/* flush cache after read */
+			flush_cache((ulong)addr, cnt * 512); /* FIXME */
 
-		if (0 == mmc_boot_partition_size_change(mmc,
-							bootsize, rpmbsize)) {
-			printf("EMMC boot partition Size %d MB\n", bootsize);
-			printf("EMMC RPMB partition Size %d MB\n", rpmbsize);
+			printf("%d blocks read: %s\n",
+				n, "OK");
 			return 0;
-		} else {
-			printf("EMMC boot partition Size change Failed.\n");
-			return 1;
-		}
-#endif /* CONFIG_SUPPORT_EMMC_BOOT */
-	}
-	state = MMC_INVALID;
-	if (argc == 5 && strcmp(argv[1], "read") == 0)
-		state = MMC_READ;
-	else if (argc == 5 && strcmp(argv[1], "write") == 0)
-		state = MMC_WRITE;
-	else if (argc == 4 && strcmp(argv[1], "erase") == 0)
-		state = MMC_ERASE;
-
-	if (state != MMC_INVALID) {
-		struct mmc *mmc = find_mmc_device(curr_device);
-		int idx = 2;
-		u32 blk, cnt, n;
-		void *addr;
-
-		if (state != MMC_ERASE) {
-			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
-			++idx;
-		} else
-			addr = NULL;
-		blk = simple_strtoul(argv[idx], NULL, 16);
-		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
-
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", curr_device);
-			return 1;
-		}
+		} else if (strcmp(argv[1], "write") == 0) {
+			int dev = simple_strtoul(argv[2], NULL, 10);
+			void *addr = (void *)simple_strtoul(argv[3], NULL, 16);
+			u32 cnt = simple_strtoul(argv[5], NULL, 10);
+			int blk = simple_strtoul(argv[4], NULL, 10);
+			u32 n;
+			u32 written_cnt;
+			u32 cnt_to_write;
+			void *addr_to_write = addr;
+			struct mmc *mmc = find_mmc_device(dev);
 
-		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
-				argv[1], curr_device, blk, cnt);
 
-		mmc_init(mmc);
-
-		if ((state == MMC_WRITE || state == MMC_ERASE)) {
-			if (mmc_getwp(mmc) == 1) {
-				printf("Error: card is write protected!\n");
+			if (!mmc)
 				return 1;
-			}
-		}
 
-		switch (state) {
-		case MMC_READ:
-			n = mmc->block_dev.block_read(curr_device, blk,
-						      cnt, addr);
-			/* flush cache after read */
-			flush_cache((ulong)addr, cnt * 512); /* FIXME */
-			break;
-		case MMC_WRITE:
-			n = mmc->block_dev.block_write(curr_device, blk,
-						      cnt, addr);
-			break;
-		case MMC_ERASE:
-			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
-			break;
-		default:
-			BUG();
+			printf("\nMMC write: dev # %d, block # %d, count %d ... ",
+				dev, blk, cnt);
+
+			rc = mmc_init(mmc);
+			if(rc)
+				return rc;
+
+			n = 0;
+			addr_to_write = addr;
+			do {
+				if (cnt - n > MAXIMUM_BLOCK_COUNT)
+					cnt_to_write = MAXIMUM_BLOCK_COUNT;
+				else
+					cnt_to_write = cnt - n;
+
+				written_cnt = mmc->block_dev.block_write(dev, blk, cnt_to_write, addr_to_write);
+				n += written_cnt;
+				blk += written_cnt;
+				addr_to_write += written_cnt * 512;
+				if(cnt_to_write != written_cnt) {
+					printf("%d blocks written: %s\n",
+						n, "ERROR");
+					return -1;
+				}
+			} while(cnt > n);
+
+			printf("%d blocks written: %s\n",
+				n, "OK");
+			return 0;
+		} else {
+			printf("Usage:\n%s\n", cmdtp->usage);
+			rc = 1;
 		}
 
-		printf("%d blocks %s: %s\n",
-				n, argv[1], (n == cnt) ? "OK" : "ERROR");
-		return (n == cnt) ? 0 : 1;
+		return rc;
 	}
-
-	return CMD_RET_USAGE;
 }
 
 U_BOOT_CMD(
 	mmc, 6, 1, do_mmcops,
 	"MMC sub system",
-	"read addr blk# cnt\n"
-	"mmc write addr blk# cnt\n"
-	"mmc erase blk# cnt\n"
-	"mmc rescan\n"
-	"mmc part - lists available partition on current mmc device\n"
-	"mmc dev [dev] [part] - show or set current mmc device [partition]\n"
-	"mmc list - lists available devices\n"
-#ifdef CONFIG_SUPPORT_EMMC_BOOT
-	"mmc open <dev> <boot_partition>\n"
-	" - Enable boot_part for booting and enable R/W access of boot_part\n"
-	"mmc close <dev> <boot_partition>\n"
-	" - Enable boot_part for booting and disable access to boot_part\n"
-	"mmc bootpart <device num> <boot part size MB> <RPMB part size MB>\n"
-	" - change sizes of boot and RPMB partitions of specified device\n"
+	"read <device num> addr blk# cnt\n"
+	"mmc write <device num> addr blk# cnt\n"
+	"mmc rescan <device num>\n"
+	"mmc list - list available devices\n");
 #endif
-	);
-#endif /* !CONFIG_GENERIC_MMC */
diff -urN u-boot-2013.10/cp.sh u-boot-2013.10_aston/cp.sh
--- u-boot-2013.10/cp.sh	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/cp.sh	2016-01-04 21:33:09.000000000 -0800
@@ -0,0 +1,56 @@
+# start.S 浠剁疯
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/cpu/armv7/start.S ./arch/arm/cpu/armv7/ -f
+
+# crt0.S
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/lib/crt0.S ./arch/arm/lib/ -f
+
+# arch/arm/lib/board.c
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/lib/board.c ./arch/arm/lib/ -f
+
+
+# board/samsung/goni/lowlevel_init.S
+#cp /root/winshare/s5pv210/uboot/u-boot-2013.10/board/samsung/goni/lowlevel_init.S ./board/samsung/goni/ -f
+
+# u-boot.lds
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/cpu/u-boot.lds ./arch/arm/cpu/ -f
+
+# board/samsung/goni/Makefile
+#cp /root/winshare/s5pv210/uboot/u-boot-2013.10/board/samsung/goni/Makefile ./board/samsung/goni/ -f
+
+# board/samsung/goni
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/board/samsung/goni ./board/samsung/ -rf
+
+# include/s5pc110.h
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/include/s5pc110.h ./include/ -f
+
+# include/confits/s5p_goni.h
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/include/configs/s5p_goni.h ./include/configs/ -f
+
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/include/movi.h ./include/ -f
+
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/cpu/armv7/s5p-common/cpu_info.c ./arch/arm/cpu/armv7/s5p-common/ -f
+
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/include/asm/arch-s5pc1xx/cpu.h ./arch/arm/include/asm/arch-s5pc1xx/ -f
+
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/arch/arm/cpu/armv7/s5pc1xx/clock.c ./arch/arm/cpu/armv7/s5pc1xx/ -f
+
+# sd/mmc driver
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/drivers/mmc/mmc.c ./drivers/mmc -f
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/drivers/mmc/s3c_hsmmc.c ./drivers/mmc -f
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/include/mmc.h ./include/ -f
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/include/s3c_hsmmc.h ./include/ -f
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/common/cmd_mmc.c ./common/ -f
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/drivers/mmc/Makefile ./drivers/mmc -f
+
+// network
+cp /root/winshare/s5pv210/uboot/u-boot-2013.10/net/eth.c ./net/ -f
+
+
+#echo $#
+if [$# -eq 0]; then
+make distclean
+make s5p_goni_config
+fi
+
+make
+
diff -urN u-boot-2013.10/drivers/mmc/Makefile u-boot-2013.10_aston/drivers/mmc/Makefile
--- u-boot-2013.10/drivers/mmc/Makefile	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/drivers/mmc/Makefile	2016-01-04 21:40:00.000000000 -0800
@@ -10,6 +10,8 @@
 LIB	:= $(obj)libmmc.o
 
 
+COBJS-$(CONFIG_S3C_HSMMC) += s3c_hsmmc.o
+
 COBJS-$(CONFIG_BFIN_SDH) += bfin_sdh.o
 COBJS-$(CONFIG_DAVINCI_MMC) += davinci_mmc.o
 COBJS-$(CONFIG_FSL_ESDHC) += fsl_esdhc.o
@@ -35,7 +37,7 @@
 ifdef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_SPL_MMC_BOOT) += fsl_esdhc_spl.o
 else
-COBJS-$(CONFIG_GENERIC_MMC) += mmc_write.o
+#COBJS-$(CONFIG_GENERIC_MMC) += mmc_write.o
 endif
 
 COBJS	:= $(COBJS-y)
diff -urN u-boot-2013.10/drivers/mmc/mmc.c u-boot-2013.10_aston/drivers/mmc/mmc.c
--- u-boot-2013.10/drivers/mmc/mmc.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/drivers/mmc/mmc.c	2016-01-04 21:40:00.000000000 -0800
@@ -4,7 +4,23 @@
  *
  * Based vaguely on the Linux code
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <config.h>
@@ -14,158 +30,32 @@
 #include <part.h>
 #include <malloc.h>
 #include <linux/list.h>
+#include <mmc.h>
 #include <div64.h>
-#include "mmc_private.h"
 
-/* Set block count limit because of 16 bit register limit on some hardware*/
-#ifndef CONFIG_SYS_MMC_MAX_BLK_COUNT
-#define CONFIG_SYS_MMC_MAX_BLK_COUNT 65535
+#ifdef CONFIG_CMD_MOVINAND
+extern int init_raw_area_table(block_dev_desc_t *dev_desc);
 #endif
 
 static struct list_head mmc_devices;
 static int cur_dev_num = -1;
 
-int __weak board_mmc_getwp(struct mmc *mmc)
-{
-	return -1;
-}
-
-int mmc_getwp(struct mmc *mmc)
-{
-	int wp;
-
-	wp = board_mmc_getwp(mmc);
-
-	if (wp < 0) {
-		if (mmc->getwp)
-			wp = mmc->getwp(mmc);
-		else
-			wp = 0;
-	}
-
-	return wp;
-}
-
-int __board_mmc_getcd(struct mmc *mmc) {
-	return -1;
-}
-
-int board_mmc_getcd(struct mmc *mmc)__attribute__((weak,
-	alias("__board_mmc_getcd")));
+struct mmc *mmc_global[3] = {NULL, NULL, NULL};
+struct mmc *mmc_default = NULL;
 
 int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 {
-	int ret;
-
-#ifdef CONFIG_MMC_TRACE
-	int i;
-	u8 *ptr;
-
-	printf("CMD_SEND:%d\n", cmd->cmdidx);
-	printf("\t\tARG\t\t\t 0x%08X\n", cmd->cmdarg);
-	ret = mmc->send_cmd(mmc, cmd, data);
-	switch (cmd->resp_type) {
-		case MMC_RSP_NONE:
-			printf("\t\tMMC_RSP_NONE\n");
-			break;
-		case MMC_RSP_R1:
-			printf("\t\tMMC_RSP_R1,5,6,7 \t 0x%08X \n",
-				cmd->response[0]);
-			break;
-		case MMC_RSP_R1b:
-			printf("\t\tMMC_RSP_R1b\t\t 0x%08X \n",
-				cmd->response[0]);
-			break;
-		case MMC_RSP_R2:
-			printf("\t\tMMC_RSP_R2\t\t 0x%08X \n",
-				cmd->response[0]);
-			printf("\t\t          \t\t 0x%08X \n",
-				cmd->response[1]);
-			printf("\t\t          \t\t 0x%08X \n",
-				cmd->response[2]);
-			printf("\t\t          \t\t 0x%08X \n",
-				cmd->response[3]);
-			printf("\n");
-			printf("\t\t\t\t\tDUMPING DATA\n");
-			for (i = 0; i < 4; i++) {
-				int j;
-				printf("\t\t\t\t\t%03d - ", i*4);
-				ptr = (u8 *)&cmd->response[i];
-				ptr += 3;
-				for (j = 0; j < 4; j++)
-					printf("%02X ", *ptr--);
-				printf("\n");
-			}
-			break;
-		case MMC_RSP_R3:
-			printf("\t\tMMC_RSP_R3,4\t\t 0x%08X \n",
-				cmd->response[0]);
-			break;
-		default:
-			printf("\t\tERROR MMC rsp not supported\n");
-			break;
-	}
-#else
-	ret = mmc->send_cmd(mmc, cmd, data);
-#endif
-	return ret;
-}
-
-int mmc_send_status(struct mmc *mmc, int timeout)
-{
-	struct mmc_cmd cmd;
-	int err, retries = 5;
-#ifdef CONFIG_MMC_TRACE
-	int status;
-#endif
-
-	cmd.cmdidx = MMC_CMD_SEND_STATUS;
-	cmd.resp_type = MMC_RSP_R1;
-	if (!mmc_host_is_spi(mmc))
-		cmd.cmdarg = mmc->rca << 16;
-
-	do {
-		err = mmc_send_cmd(mmc, &cmd, NULL);
-		if (!err) {
-			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
-			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
-			     MMC_STATE_PRG)
-				break;
-			else if (cmd.response[0] & MMC_STATUS_MASK) {
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-				printf("Status Error: 0x%08X\n",
-					cmd.response[0]);
-#endif
-				return COMM_ERR;
-			}
-		} else if (--retries < 0)
-			return err;
-
-		udelay(1000);
-
-	} while (timeout--);
-
-#ifdef CONFIG_MMC_TRACE
-	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
-	printf("CURR STATE:%d\n", status);
-#endif
-	if (timeout <= 0) {
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-		printf("Timeout waiting card ready\n");
-#endif
-		return TIMEOUT;
-	}
-
-	return 0;
+	return mmc->send_cmd(mmc, cmd, data);
 }
 
 int mmc_set_blocklen(struct mmc *mmc, int len)
 {
 	struct mmc_cmd cmd;
 
-	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
+	cmd.opcode = MMC_CMD_SET_BLOCKLEN;
 	cmd.resp_type = MMC_RSP_R1;
-	cmd.cmdarg = len;
+	cmd.arg = len;
+	cmd.flags = 0;
 
 	return mmc_send_cmd(mmc, &cmd, NULL);
 }
@@ -182,100 +72,144 @@
 			return m;
 	}
 
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
 	printf("MMC Device %d not found\n", dev_num);
-#endif
 
 	return NULL;
 }
 
-static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
-			   lbaint_t blkcnt)
+static ulong
+mmc_bread_primitive(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
 {
+	struct mmc *host = find_mmc_device(dev_num);
+	int err;
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 
+	if (!host)
+		return 0;
+
+	/* We always do full block reads from the card */
+	err = mmc_set_blocklen(host, (1<<9));
+	if (err)
+		return 0;
+
+
 	if (blkcnt > 1)
-		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
+		cmd.opcode = MMC_CMD_READ_MULTIPLE_BLOCK;
 	else
-		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+		cmd.opcode = MMC_CMD_READ_SINGLE_BLOCK;
 
-	if (mmc->high_capacity)
-		cmd.cmdarg = start;
+	if (host->high_capacity)
+		cmd.arg = start;
 	else
-		cmd.cmdarg = start * mmc->read_bl_len;
+		cmd.arg = start * (1<<9);
 
 	cmd.resp_type = MMC_RSP_R1;
+	cmd.flags = 0;
 
 	data.dest = dst;
 	data.blocks = blkcnt;
-	data.blocksize = mmc->read_bl_len;
+	data.blocksize = (1<<9);
 	data.flags = MMC_DATA_READ;
 
-	if (mmc_send_cmd(mmc, &cmd, &data))
-		return 0;
-
-	if (blkcnt > 1) {
-		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
-		cmd.cmdarg = 0;
-		cmd.resp_type = MMC_RSP_R1b;
-		if (mmc_send_cmd(mmc, &cmd, NULL)) {
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-			printf("mmc fail to send stop cmd\n");
-#endif
-			return 0;
-		}
+	err = mmc_send_cmd(host, &cmd, &data);
+	if (err) {
+		printf("mmc read failed\n");
+		return err;
 	}
 
 	return blkcnt;
 }
 
-static ulong mmc_bread(int dev_num, lbaint_t start, lbaint_t blkcnt, void *dst)
+#define MAXBLKCNT	0xFFFF
+static ulong
+mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
 {
-	lbaint_t cur, blocks_todo = blkcnt;
+	lbaint_t blkcnt_tmp = blkcnt;
+	ulong ret = 0;
 
-	if (blkcnt == 0)
-		return 0;
+	while (blkcnt_tmp >= MAXBLKCNT) {
+		ret += mmc_bread_primitive(dev_num, start, MAXBLKCNT, dst);
 
-	struct mmc *mmc = find_mmc_device(dev_num);
-	if (!mmc)
-		return 0;
+		start += MAXBLKCNT;
+		dst += MAXBLKCNT * 512;
+		blkcnt_tmp -= MAXBLKCNT;
+	}
+	ret += mmc_bread_primitive(dev_num, start, blkcnt_tmp, dst);
 
-	if ((start + blkcnt) > mmc->block_dev.lba) {
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-		printf("MMC: block number 0x" LBAF " exceeds max(0x" LBAF ")\n",
-			start + blkcnt, mmc->block_dev.lba);
-#endif
+	return ret;
+}
+
+static ulong
+mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void *src)
+{
+	struct mmc *host = find_mmc_device(dev_num);
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+
+	if (!host)
 		return 0;
+
+	err = mmc_set_blocklen(host, (1<<9));
+	if (err) {
+		printf("set write bl len failed\n");
+		return err;
 	}
 
-	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
-		return 0;
+	if (blkcnt > 1)
+		cmd.opcode = MMC_CMD_WRITE_MULTIPLE_BLOCK;
+	else
+		cmd.opcode = MMC_CMD_WRITE_SINGLE_BLOCK;
 
-	do {
-		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
-		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
-			return 0;
-		blocks_todo -= cur;
-		start += cur;
-		dst += cur * mmc->read_bl_len;
-	} while (blocks_todo > 0);
+	if (host->high_capacity)
+		cmd.arg = start;
+	else
+		cmd.arg = start * (1<<9);
 
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.flags = 0;
+
+	data.src = src;
+	data.blocks = blkcnt;
+	data.blocksize = (1<<9);
+	data.flags = MMC_DATA_WRITE;
+
+	err = mmc_send_cmd(host, &cmd, &data);
+	if (err) {
+		printf("mmc write failed\n");
+		return err;
+	}
+
+#if defined(CONFIG_VOGUES)
+	mmc_bread(dev_num, start, blkcnt, src);
+#endif
 	return blkcnt;
 }
 
-static int mmc_go_idle(struct mmc *mmc)
+ulong movi_write(ulong start, lbaint_t blkcnt, void *src)
+{
+	return mmc_bwrite(0, start, blkcnt, src);
+}
+
+ulong movi_read(ulong start, lbaint_t blkcnt, void *dst)
+{
+	return mmc_bread(0, start, blkcnt, dst);
+}
+
+int mmc_go_idle(struct mmc *host)
 {
 	struct mmc_cmd cmd;
 	int err;
 
 	udelay(1000);
 
-	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
-	cmd.cmdarg = 0;
+	cmd.opcode = MMC_CMD_GO_IDLE_STATE;
+	cmd.arg = 0;
 	cmd.resp_type = MMC_RSP_NONE;
+	cmd.flags = 0;
 
-	err = mmc_send_cmd(mmc, &cmd, NULL);
+	err = mmc_send_cmd(host, &cmd, NULL);
 
 	if (err)
 		return err;
@@ -285,149 +219,79 @@
 	return 0;
 }
 
-static int sd_send_op_cond(struct mmc *mmc)
+int mmc_send_app_op_cond(struct mmc *host)
 {
-	int timeout = 1000;
+	int timeout = 100;
 	int err;
 	struct mmc_cmd cmd;
 
 	do {
-		cmd.cmdidx = MMC_CMD_APP_CMD;
+		cmd.opcode = MMC_CMD_APP_CMD;
 		cmd.resp_type = MMC_RSP_R1;
-		cmd.cmdarg = 0;
+		cmd.arg = 0;
+		cmd.flags = 0;
 
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+		err = mmc_send_cmd(host, &cmd, NULL);
 
 		if (err)
 			return err;
 
-		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+		cmd.opcode = SD_APP_OP_COND;
 		cmd.resp_type = MMC_RSP_R3;
+		cmd.arg = host->voltages;
 
-		/*
-		 * Most cards do not answer if some reserved bits
-		 * in the ocr are set. However, Some controller
-		 * can set bit 7 (reserved for low voltages), but
-		 * how to manage low voltages SD card is not yet
-		 * specified.
-		 */
-		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
-			(mmc->voltages & 0xff8000);
+		if (host->version == SD_VERSION_2)
+			cmd.arg |= OCR_HCS;
 
-		if (mmc->version == SD_VERSION_2)
-			cmd.cmdarg |= OCR_HCS;
-
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+		err = mmc_send_cmd(host, &cmd, NULL);
 
 		if (err)
 			return err;
 
-		udelay(1000);
-	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
+		udelay(10000);
+	} while ((!(cmd.resp[0] & OCR_BUSY)) && timeout--);
 
 	if (timeout <= 0)
 		return UNUSABLE_ERR;
 
-	if (mmc->version != SD_VERSION_2)
-		mmc->version = SD_VERSION_1_0;
+	if (host->version != SD_VERSION_2)
+		host->version = SD_VERSION_1_0;
 
-	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
-		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
-		cmd.resp_type = MMC_RSP_R3;
-		cmd.cmdarg = 0;
+	host->ocr = cmd.resp[0];
+	host->high_capacity = ((host->ocr & OCR_HCS) == OCR_HCS);
+	host->rca = 0;
 
-		err = mmc_send_cmd(mmc, &cmd, NULL);
-
-		if (err)
-			return err;
-	}
-
-	mmc->ocr = cmd.response[0];
-
-	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
-	mmc->rca = 0;
-
-	return 0;
-}
-
-/* We pass in the cmd since otherwise the init seems to fail */
-static int mmc_send_op_cond_iter(struct mmc *mmc, struct mmc_cmd *cmd,
-		int use_arg)
-{
-	int err;
-
-	cmd->cmdidx = MMC_CMD_SEND_OP_COND;
-	cmd->resp_type = MMC_RSP_R3;
-	cmd->cmdarg = 0;
-	if (use_arg && !mmc_host_is_spi(mmc)) {
-		cmd->cmdarg =
-			(mmc->voltages &
-			(mmc->op_cond_response & OCR_VOLTAGE_MASK)) |
-			(mmc->op_cond_response & OCR_ACCESS_MODE);
-
-		if (mmc->host_caps & MMC_MODE_HC)
-			cmd->cmdarg |= OCR_HCS;
-	}
-	err = mmc_send_cmd(mmc, cmd, NULL);
-	if (err)
-		return err;
-	mmc->op_cond_response = cmd->response[0];
 	return 0;
 }
 
 int mmc_send_op_cond(struct mmc *mmc)
 {
+	int timeout = 1000;
 	struct mmc_cmd cmd;
-	int err, i;
+	int err;
 
 	/* Some cards seem to need this */
 	mmc_go_idle(mmc);
 
- 	/* Asking to the card its capabilities */
-	mmc->op_cond_pending = 1;
-	for (i = 0; i < 2; i++) {
-		err = mmc_send_op_cond_iter(mmc, &cmd, i != 0);
-		if (err)
-			return err;
-
-		/* exit if not busy (flag seems to be inverted) */
-		if (mmc->op_cond_response & OCR_BUSY)
-			return 0;
-	}
-	return IN_PROGRESS;
-}
-
-int mmc_complete_op_cond(struct mmc *mmc)
-{
-	struct mmc_cmd cmd;
-	int timeout = 1000;
-	uint start;
-	int err;
-
-	mmc->op_cond_pending = 0;
-	start = get_timer(0);
 	do {
-		err = mmc_send_op_cond_iter(mmc, &cmd, 1);
-		if (err)
-			return err;
-		if (get_timer(start) > timeout)
-			return UNUSABLE_ERR;
-		udelay(100);
-	} while (!(mmc->op_cond_response & OCR_BUSY));
-
-	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
-		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
+		cmd.opcode = MMC_CMD_SEND_OP_COND;
 		cmd.resp_type = MMC_RSP_R3;
-		cmd.cmdarg = 0;
+		cmd.arg = OCR_HCS | mmc->voltages;
+		cmd.flags = 0;
 
 		err = mmc_send_cmd(mmc, &cmd, NULL);
 
 		if (err)
 			return err;
-	}
+
+		udelay(1000);
+	} while (!(cmd.resp[0] & OCR_BUSY) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
 
 	mmc->version = MMC_VERSION_UNKNOWN;
-	mmc->ocr = cmd.response[0];
+	mmc->ocr = cmd.resp[0];
 
 	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
 	mmc->rca = 0;
@@ -435,21 +299,21 @@
 	return 0;
 }
 
-
-static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
+int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 {
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 	int err;
 
 	/* Get the Card Status Register */
-	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
+	cmd.opcode = MMC_CMD_SEND_EXT_CSD;
 	cmd.resp_type = MMC_RSP_R1;
-	cmd.cmdarg = 0;
+	cmd.arg = 0;
+	cmd.flags = 0;
 
-	data.dest = (char *)ext_csd;
+	data.dest = ext_csd;
 	data.blocks = 1;
-	data.blocksize = MMC_MAX_BLOCK_LEN;
+	data.blocksize = 512;
 	data.flags = MMC_DATA_READ;
 
 	err = mmc_send_cmd(mmc, &cmd, &data);
@@ -457,53 +321,59 @@
 	return err;
 }
 
+int mmc_set_relative_addr(struct mmc *host)
+{
+	int err;
+	struct mmc_cmd cmd;
+
+	cmd.opcode = MMC_SET_RELATIVE_ADDR;
+	cmd.arg = host->rca << 16;
+	cmd.flags = MMC_RSP_R1;
+
+	err = mmc_send_cmd(host, &cmd, NULL);
 
-static int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+	return err;
+}
+
+int mmc_switch(struct mmc *host, u8 set, u8 index, u8 value)
 {
 	struct mmc_cmd cmd;
-	int timeout = 1000;
-	int ret;
 
-	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.opcode = MMC_CMD_SWITCH;
 	cmd.resp_type = MMC_RSP_R1b;
-	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-				 (index << 16) |
-				 (value << 8);
-
-	ret = mmc_send_cmd(mmc, &cmd, NULL);
-
-	/* Waiting for the ready status */
-	if (!ret)
-		ret = mmc_send_status(mmc, timeout);
-
-	return ret;
+	cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+		(index << 16) |
+		(value << 8);
+	cmd.flags = 0;
 
+	return mmc_send_cmd(host, &cmd, NULL);
 }
 
-static int mmc_change_freq(struct mmc *mmc)
+int mmc_change_freq(struct mmc *mmc)
 {
-	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+	u8 ext_csd[512];
 	char cardtype;
 	int err;
 
 	mmc->card_caps = 0;
 
-	if (mmc_host_is_spi(mmc))
-		return 0;
-
 	/* Only version 4 supports high-speed */
 	if (mmc->version < MMC_VERSION_4)
 		return 0;
 
+	mmc->card_caps |= MMC_MODE_4BIT;
+
 	err = mmc_send_ext_csd(mmc, ext_csd);
 
 	if (err)
 		return err;
 
-	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
+	if (ext_csd[212] || ext_csd[213] || ext_csd[214] || ext_csd[215])
+		mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
 
-	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
+	cardtype = ext_csd[196] & 0xf;
 
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
 	if (err)
 		return err;
 
@@ -514,7 +384,7 @@
 		return err;
 
 	/* No high-speed support */
-	if (!ext_csd[EXT_CSD_HS_TIMING])
+	if (!ext_csd[185])
 		return 0;
 
 	/* High Speed is set, there are two types: 52MHz and 26MHz */
@@ -526,80 +396,20 @@
 	return 0;
 }
 
-static int mmc_set_capacity(struct mmc *mmc, int part_num)
-{
-	switch (part_num) {
-	case 0:
-		mmc->capacity = mmc->capacity_user;
-		break;
-	case 1:
-	case 2:
-		mmc->capacity = mmc->capacity_boot;
-		break;
-	case 3:
-		mmc->capacity = mmc->capacity_rpmb;
-		break;
-	case 4:
-	case 5:
-	case 6:
-	case 7:
-		mmc->capacity = mmc->capacity_gp[part_num - 4];
-		break;
-	default:
-		return -1;
-	}
-
-	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
-
-	return 0;
-}
-
-int mmc_switch_part(int dev_num, unsigned int part_num)
-{
-	struct mmc *mmc = find_mmc_device(dev_num);
-	int ret;
-
-	if (!mmc)
-		return -1;
-
-	ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
-			 (mmc->part_config & ~PART_ACCESS_MASK)
-			 | (part_num & PART_ACCESS_MASK));
-	if (ret)
-		return ret;
-
-	return mmc_set_capacity(mmc, part_num);
-}
-
-int mmc_getcd(struct mmc *mmc)
-{
-	int cd;
-
-	cd = board_mmc_getcd(mmc);
-
-	if (cd < 0) {
-		if (mmc->getcd)
-			cd = mmc->getcd(mmc);
-		else
-			cd = 1;
-	}
-
-	return cd;
-}
-
-static int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
+int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
 {
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 
 	/* Switch the frequency */
-	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
+	cmd.opcode = SD_SWITCH;
 	cmd.resp_type = MMC_RSP_R1;
-	cmd.cmdarg = (mode << 31) | 0xffffff;
-	cmd.cmdarg &= ~(0xf << (group * 4));
-	cmd.cmdarg |= value << (group * 4);
+	cmd.arg = (mode << 31) | 0xffffff;
+	cmd.arg &= ~(0xf << (group * 4));
+	cmd.arg |= value << (group * 4);
+	cmd.flags = 0;
 
-	data.dest = (char *)resp;
+	data.dest = resp;
 	data.blocksize = 64;
 	data.blocks = 1;
 	data.flags = MMC_DATA_READ;
@@ -608,38 +418,37 @@
 }
 
 
-static int sd_change_freq(struct mmc *mmc)
+int sd_change_freq(struct mmc *mmc)
 {
 	int err;
 	struct mmc_cmd cmd;
-	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
-	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
+	uint scr[2];
+	uint switch_status[16];
 	struct mmc_data data;
 	int timeout;
 
 	mmc->card_caps = 0;
 
-	if (mmc_host_is_spi(mmc))
-		return 0;
-
 	/* Read the SCR to find out if this card supports higher speeds */
-	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.opcode = MMC_CMD_APP_CMD;
 	cmd.resp_type = MMC_RSP_R1;
-	cmd.cmdarg = mmc->rca << 16;
+	cmd.arg = mmc->rca << 16;
+	cmd.flags = 0;
 
 	err = mmc_send_cmd(mmc, &cmd, NULL);
 
 	if (err)
 		return err;
 
-	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
+	cmd.opcode = SD_APP_SEND_SCR;
 	cmd.resp_type = MMC_RSP_R1;
-	cmd.cmdarg = 0;
+	cmd.arg = 0;
+	cmd.flags = 0;
 
 	timeout = 3;
 
 retry_scr:
-	data.dest = (char *)scr;
+	data.dest = (u8 *)&scr;
 	data.blocksize = 8;
 	data.blocks = 1;
 	data.flags = MMC_DATA_READ;
@@ -657,25 +466,20 @@
 	mmc->scr[1] = __be32_to_cpu(scr[1]);
 
 	switch ((mmc->scr[0] >> 24) & 0xf) {
-		case 0:
-			mmc->version = SD_VERSION_1_0;
-			break;
-		case 1:
-			mmc->version = SD_VERSION_1_10;
-			break;
-		case 2:
-			mmc->version = SD_VERSION_2;
-			if ((mmc->scr[0] >> 15) & 0x1)
-				mmc->version = SD_VERSION_3;
-			break;
-		default:
-			mmc->version = SD_VERSION_1_0;
-			break;
+	case 0:
+		mmc->version = SD_VERSION_1_0;
+		break;
+	case 1:
+		mmc->version = SD_VERSION_1_10;
+		break;
+	case 2:
+		mmc->version = SD_VERSION_2;
+		break;
+	default:
+		mmc->version = SD_VERSION_1_0;
+		break;
 	}
 
-	if (mmc->scr[0] & SD_DATA_4BIT)
-		mmc->card_caps |= MMC_MODE_4BIT;
-
 	/* Version 1.0 doesn't support switching */
 	if (mmc->version == SD_VERSION_1_0)
 		return 0;
@@ -683,7 +487,7 @@
 	timeout = 4;
 	while (timeout--) {
 		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
-				(u8 *)switch_status);
+				(u8 *)&switch_status);
 
 		if (err)
 			return err;
@@ -693,63 +497,366 @@
 			break;
 	}
 
+//	if (mmc->scr[0] & SD_DATA_4BIT)
+		mmc->card_caps |= MMC_MODE_4BIT;
+
 	/* If high-speed isn't supported, we return */
 	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
 		return 0;
 
-	/*
-	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
-	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
-	 * This can avoid furthur problem when the card runs in different
-	 * mode between the host.
-	 */
-	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
-		(mmc->host_caps & MMC_MODE_HS)))
-		return 0;
-
-	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
+	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)&switch_status);
 
 	if (err)
 		return err;
 
-	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
+	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000) {
 		mmc->card_caps |= MMC_MODE_HS;
+		mmc->clock = 50000000;
+	} else {
+		mmc->clock = 25000000;
+	}
 
 	return 0;
 }
 
-/* frequency bases */
-/* divided by 10 to be nice to platforms without floating point */
-static const int fbase[] = {
-	10000,
-	100000,
-	1000000,
-	10000000,
+static const unsigned int tran_exp[] = {
+	10000,		100000,		1000000,	10000000,
+	0,		0,		0,		0
 };
 
-/* Multiplier values for TRAN_SPEED.  Multiplied by 10 to be nice
- * to platforms without floating point.
- */
-static const int multipliers[] = {
-	0,	/* reserved */
-	10,
-	12,
-	13,
-	15,
-	20,
-	25,
-	30,
-	35,
-	40,
-	45,
-	50,
-	55,
-	60,
-	70,
-	80,
+static const unsigned char tran_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+static const unsigned int tacc_exp[] = {
+	1,	10,	100,	1000,	10000,	100000,	1000000, 10000000,
 };
 
-static void mmc_set_ios(struct mmc *mmc)
+static const unsigned int tacc_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+#define UNSTUFF_BITS(resp, start, size)					\
+	({								\
+		const int __size = size;				\
+		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
+		const int __off = 3 - ((start) / 32);			\
+		const int __shft = (start) & 31;			\
+		u32 __res;						\
+									\
+		__res = resp[__off] >> __shft;				\
+		if (__size + __shft > 32)				\
+			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
+		__res & __mask;						\
+	})
+
+/*
+ * Given a 128-bit response, decode to our card CSD structure. for SD
+ * every
+ */
+static int sd_decode_csd(struct mmc *host)
+{
+	struct mmc_csd csd_org, *csd;
+	unsigned int e, m, csd_struct;
+	u32 *resp = host->csd;
+
+	csd = &csd_org;
+
+	csd_struct = UNSTUFF_BITS(resp, 126, 2);
+
+	switch (csd_struct) {
+	case 0:
+		m = UNSTUFF_BITS(resp, 115, 4);
+		e = UNSTUFF_BITS(resp, 112, 3);
+		csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
+		csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
+
+		m = UNSTUFF_BITS(resp, 99, 4);
+		e = UNSTUFF_BITS(resp, 96, 3);
+		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+		e = UNSTUFF_BITS(resp, 47, 3);
+		m = UNSTUFF_BITS(resp, 62, 12);
+		csd->capacity	  = (1 + m) << (e + 2);
+
+		csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
+		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
+		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
+		csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
+		csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
+		csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
+		csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
+		host->read_bl_len = (1<<9);
+		host->write_bl_len = (1<<9);
+		host->capacity = csd->capacity<<(csd->read_blkbits - 9);
+		break;
+	case 1:
+		/*
+		 * This is a block-addressed SDHC card. Most
+		 * interesting fields are unused and have fixed
+		 * values. To avoid getting tripped by buggy cards,
+		 * we assume those fixed values ourselves.
+		 */
+
+		csd->tacc_ns	 = 0; /* Unused */
+		csd->tacc_clks	 = 0; /* Unused */
+
+		m = UNSTUFF_BITS(resp, 99, 4);
+		e = UNSTUFF_BITS(resp, 96, 3);
+		csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+		m = UNSTUFF_BITS(resp, 48, 22);
+		csd->capacity     = (1 + m) << 10;
+
+		csd->read_blkbits = 9;
+		csd->read_partial = 0;
+		csd->write_misalign = 0;
+		csd->read_misalign = 0;
+		csd->r2w_factor = 4; /* Unused */
+		csd->write_blkbits = 9;
+		csd->write_partial = 0;
+
+		host->high_capacity = 1;
+		host->read_bl_len = (1<<9);
+		host->write_bl_len = (1<<9);
+		host->capacity = csd->capacity;
+		break;
+	default:
+		printf("unrecognised CSD structure version %d\n"
+			, csd_struct);
+		return -1;
+	}
+
+	return 0;
+}
+
+#if 0
+/*
+ * Given the decoded CSD structure, decode the raw CID to our CID structure.
+ */
+static int mmc_decode_cid(struct mmc_card *card)
+{
+	u32 *resp = card->raw_cid;
+
+	/*
+	 * The selection of the format here is based upon published
+	 * specs from sandisk and from what people have reported.
+	 */
+	switch (card->csd.mmca_vsn) {
+	case 0: /* MMC v1.0 - v1.2 */
+	case 1: /* MMC v1.4 */
+		card->cid.manfid	= UNSTUFF_BITS(resp, 104, 24);
+		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
+		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
+		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
+		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
+		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
+		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
+		card->cid.prod_name[6]	= UNSTUFF_BITS(resp, 48, 8);
+		card->cid.hwrev		= UNSTUFF_BITS(resp, 44, 4);
+		card->cid.fwrev		= UNSTUFF_BITS(resp, 40, 4);
+		card->cid.serial	= UNSTUFF_BITS(resp, 16, 24);
+		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
+		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
+		break;
+
+	case 2: /* MMC v2.0 - v2.2 */
+	case 3: /* MMC v3.1 - v3.3 */
+	case 4: /* MMC v4 */
+		card->cid.manfid	= UNSTUFF_BITS(resp, 120, 8);
+		card->cid.oemid		= UNSTUFF_BITS(resp, 104, 16);
+		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
+		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
+		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
+		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
+		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
+		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
+		card->cid.serial	= UNSTUFF_BITS(resp, 16, 32);
+		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
+		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
+		break;
+
+	default:
+		printk(KERN_ERR "%s: card has unknown MMCA version %d\n",
+			mmc_hostname(card->host), card->csd.mmca_vsn);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+ * Given a 128-bit response, decode to our card CSD structure.
+ */
+static int mmc_decode_csd(struct mmc *host)
+{
+	struct mmc_csd csd_org, *csd;
+	unsigned int e, m, csd_struct;
+	u32 *resp = host->csd;
+
+	csd = &csd_org;
+
+	/*
+	 * We only understand CSD structure v1.1 and v1.2.
+	 * v1.2 has extra information in bits 15, 11 and 10.
+	 */
+	csd_struct = UNSTUFF_BITS(resp, 126, 2);
+	if (csd_struct != 1 && csd_struct != 2 && csd_struct != 3) {
+		printf("unrecognised CSD structure version %d\n",
+			csd_struct);
+		return -1;
+	}
+
+	csd->mmca_vsn	 = UNSTUFF_BITS(resp, 122, 4);
+	switch (csd->mmca_vsn) {
+	case 0:
+		host->version = MMC_VERSION_1_2;
+		break;
+	case 1:
+		host->version = MMC_VERSION_1_4;
+		break;
+	case 2:
+		host->version = MMC_VERSION_2_2;
+		break;
+	case 3:
+		host->version = MMC_VERSION_3;
+		break;
+	case 4:
+		host->version = MMC_VERSION_4;
+		break;
+	}
+
+	m = UNSTUFF_BITS(resp, 115, 4);
+	e = UNSTUFF_BITS(resp, 112, 3);
+	csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
+	csd->tacc_clks	 = UNSTUFF_BITS(resp, 104, 8) * 100;
+
+	m = UNSTUFF_BITS(resp, 99, 4);
+	e = UNSTUFF_BITS(resp, 96, 3);
+	csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+	csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
+
+	e = UNSTUFF_BITS(resp, 47, 3);
+	m = UNSTUFF_BITS(resp, 62, 12);
+	csd->capacity	  = (1 + m) << (e + 2);
+
+	csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
+	csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
+	csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
+	csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
+	csd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);
+	csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
+	csd->write_partial = UNSTUFF_BITS(resp, 21, 1);
+
+	host->read_bl_len = 1 << csd->read_blkbits;
+	host->write_bl_len = 1 << csd->write_blkbits;
+	host->capacity = csd->capacity;
+	host->clock = 20000000;
+
+	return 0;
+}
+
+/*
+ * Read and decode extended CSD.
+ */
+static int mmc_read_ext_csd(struct mmc *host)
+{
+	int err;
+	u8 *ext_csd;
+	unsigned int ext_csd_struct;
+
+	if (host->version < (MMC_VERSION_4 | MMC_VERSION_MMC))
+		return 0;
+
+	/*
+	 * As the ext_csd is so large and mostly unused, we don't store the
+	 * raw block in mmc_card.
+	 */
+	ext_csd = malloc(512);
+	if (!ext_csd) {
+		printf("could not allocate a buffer to "
+			"receive the ext_csd.\n");
+		return -1;
+	}
+
+	err = mmc_switch(host, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 0);
+	if (err)
+		return err;
+
+	err = mmc_switch(host, EXT_CSD_CMD_SET_NORMAL,
+				EXT_CSD_BUS_WIDTH,
+				EXT_CSD_BUS_WIDTH_1);
+	if (err)
+		return err;
+
+	err = mmc_send_ext_csd(host, ext_csd);
+	if (err) {
+		/*
+		 * High capacity cards should have this "magic" size
+		 * stored in their CSD.
+		 */
+		if (host->capacity == (4096 * 512)) {
+			printf("unable to read EXT_CSD "
+				"on a possible high capacity card. "
+				"Card will be ignored.\n");
+		} else {
+			printf("unable to read "
+				"EXT_CSD, performance might suffer.\n");
+			err = 0;
+		}
+
+		goto out;
+	}
+
+	ext_csd_struct = ext_csd[EXT_CSD_REV];
+	if (ext_csd_struct > 8) {
+		printf("unrecognised EXT_CSD structure "
+			"version %d\n", ext_csd_struct);
+		err = -1;
+		goto out;
+	}
+
+	if (ext_csd_struct >= 2) {
+		host->ext_csd.sectors =
+			ext_csd[EXT_CSD_SEC_CNT + 0] << 0 |
+			ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
+			ext_csd[EXT_CSD_SEC_CNT + 2] << 16 |
+			ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
+		if (host->ext_csd.sectors) {
+			host->high_capacity = ((host->ocr & OCR_HCS) == OCR_HCS);
+			/* common host->read_bl_len=512 */
+			host->capacity = host->ext_csd.sectors;
+		}
+	}
+
+	switch (ext_csd[EXT_CSD_CARD_TYPE] & 0x3) {
+	case EXT_CSD_CARD_TYPE_52 | EXT_CSD_CARD_TYPE_26:
+		host->ext_csd.hs_max_dtr = 52000000;
+		host->clock = 52000000;
+		break;
+	case EXT_CSD_CARD_TYPE_26:
+		host->ext_csd.hs_max_dtr = 26000000;
+		host->clock = 26000000;
+		break;
+	default:
+		/* MMC v4 spec says this cannot happen */
+		printf("card is mmc v4 but doesn't "
+			"support any high-speed modes.\n");
+		goto out;
+	}
+
+out:
+	free(ext_csd);
+
+	return err;
+}
+
+void mmc_set_ios(struct mmc *mmc)
 {
 	mmc->set_ios(mmc);
 }
@@ -767,387 +874,188 @@
 	mmc_set_ios(mmc);
 }
 
-static void mmc_set_bus_width(struct mmc *mmc, uint width)
+void mmc_set_bus_width(struct mmc *host, uint width)
 {
-	mmc->bus_width = width;
+	host->bus_width = width;
 
-	mmc_set_ios(mmc);
+	mmc_set_ios(host);
 }
 
-static int mmc_startup(struct mmc *mmc)
+int mmc_startup(struct mmc *host)
 {
-	int err, i;
-	uint mult, freq;
-	u64 cmult, csize, capacity;
+	int err;
 	struct mmc_cmd cmd;
-	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
-	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
-	int timeout = 1000;
-
-#ifdef CONFIG_MMC_SPI_CRC_ON
-	if (mmc_host_is_spi(mmc)) { /* enable CRC check for spi */
-		cmd.cmdidx = MMC_CMD_SPI_CRC_ON_OFF;
-		cmd.resp_type = MMC_RSP_R1;
-		cmd.cmdarg = 1;
-		err = mmc_send_cmd(mmc, &cmd, NULL);
-
-		if (err)
-			return err;
-	}
-#endif
 
 	/* Put the Card in Identify Mode */
-	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
-		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
+	cmd.opcode = MMC_ALL_SEND_CID;
 	cmd.resp_type = MMC_RSP_R2;
-	cmd.cmdarg = 0;
-
-	err = mmc_send_cmd(mmc, &cmd, NULL);
+	cmd.arg = 0;
+	cmd.flags = 0;
 
+	err = mmc_send_cmd(host, &cmd, NULL);
 	if (err)
 		return err;
 
-	memcpy(mmc->cid, cmd.response, 16);
+	memcpy(host->cid, cmd.resp, 16);
 
 	/*
 	 * For MMC cards, set the Relative Address.
 	 * For SD cards, get the Relatvie Address.
 	 * This also puts the cards into Standby State
 	 */
-	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
-		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
-		cmd.cmdarg = mmc->rca << 16;
-		cmd.resp_type = MMC_RSP_R6;
+	cmd.opcode = SD_SEND_RELATIVE_ADDR;
+	cmd.arg = host->rca << 16;
+	cmd.resp_type = MMC_RSP_R6;
+	cmd.flags = 0;
 
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+	err = mmc_send_cmd(host, &cmd, NULL);
 
-		if (err)
-			return err;
+	if (err)
+		return err;
 
-		if (IS_SD(mmc))
-			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
-	}
+	if (IS_SD(host))
+		host->rca = (cmd.resp[0] >> 16) & 0xffff;
 
 	/* Get the Card-Specific Data */
-	cmd.cmdidx = MMC_CMD_SEND_CSD;
+	cmd.opcode = MMC_SEND_CSD;
 	cmd.resp_type = MMC_RSP_R2;
-	cmd.cmdarg = mmc->rca << 16;
+	cmd.arg = host->rca << 16;
+	cmd.flags = 0;
 
-	err = mmc_send_cmd(mmc, &cmd, NULL);
-
-	/* Waiting for the ready status */
-	mmc_send_status(mmc, timeout);
+	err = mmc_send_cmd(host, &cmd, NULL);
 
 	if (err)
 		return err;
 
-	mmc->csd[0] = cmd.response[0];
-	mmc->csd[1] = cmd.response[1];
-	mmc->csd[2] = cmd.response[2];
-	mmc->csd[3] = cmd.response[3];
-
-	if (mmc->version == MMC_VERSION_UNKNOWN) {
-		int version = (cmd.response[0] >> 26) & 0xf;
-
-		switch (version) {
-			case 0:
-				mmc->version = MMC_VERSION_1_2;
-				break;
-			case 1:
-				mmc->version = MMC_VERSION_1_4;
-				break;
-			case 2:
-				mmc->version = MMC_VERSION_2_2;
-				break;
-			case 3:
-				mmc->version = MMC_VERSION_3;
-				break;
-			case 4:
-				mmc->version = MMC_VERSION_4;
-				break;
-			default:
-				mmc->version = MMC_VERSION_1_2;
-				break;
-		}
-	}
-
-	/* divide frequency by 10, since the mults are 10x bigger */
-	freq = fbase[(cmd.response[0] & 0x7)];
-	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
-
-	mmc->tran_speed = freq * mult;
-
-	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
-
-	if (IS_SD(mmc))
-		mmc->write_bl_len = mmc->read_bl_len;
+	memcpy(host->csd, cmd.resp, 4*4);
+	if (IS_SD(host))
+		sd_decode_csd(host);
 	else
-		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
-
-	if (mmc->high_capacity) {
-		csize = (mmc->csd[1] & 0x3f) << 16
-			| (mmc->csd[2] & 0xffff0000) >> 16;
-		cmult = 8;
-	} else {
-		csize = (mmc->csd[1] & 0x3ff) << 2
-			| (mmc->csd[2] & 0xc0000000) >> 30;
-		cmult = (mmc->csd[2] & 0x00038000) >> 15;
-	}
-
-	mmc->capacity_user = (csize + 1) << (cmult + 2);
-	mmc->capacity_user *= mmc->read_bl_len;
-	mmc->capacity_boot = 0;
-	mmc->capacity_rpmb = 0;
-	for (i = 0; i < 4; i++)
-		mmc->capacity_gp[i] = 0;
-
-	if (mmc->read_bl_len > MMC_MAX_BLOCK_LEN)
-		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
-
-	if (mmc->write_bl_len > MMC_MAX_BLOCK_LEN)
-		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
+		mmc_decode_csd(host);
 
 	/* Select the card, and put it into Transfer Mode */
-	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
-		cmd.cmdidx = MMC_CMD_SELECT_CARD;
-		cmd.resp_type = MMC_RSP_R1;
-		cmd.cmdarg = mmc->rca << 16;
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+	cmd.opcode = MMC_CMD_SELECT_CARD;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.arg = host->rca << 16;
+	cmd.flags = 0;
+	err = mmc_send_cmd(host, &cmd, NULL);
+	if (err)
+		return err;
 
+	if (IS_SD(host)) {
+		err = sd_change_freq(host);
+	} else {
+		err = mmc_read_ext_csd(host);
 		if (err)
 			return err;
+		err = mmc_change_freq(host);
 	}
 
-	/*
-	 * For SD, its erase group is always one sector
-	 */
-	mmc->erase_grp_size = 1;
-	mmc->part_config = MMCPART_NOAVAILABLE;
-	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
-		/* check  ext_csd version and capacity */
-		err = mmc_send_ext_csd(mmc, ext_csd);
-		if (!err && (ext_csd[EXT_CSD_REV] >= 2)) {
-			/*
-			 * According to the JEDEC Standard, the value of
-			 * ext_csd's capacity is valid if the value is more
-			 * than 2GB
-			 */
-			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
-					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
-					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
-					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
-			capacity *= MMC_MAX_BLOCK_LEN;
-			if ((capacity >> 20) > 2 * 1024)
-				mmc->capacity_user = capacity;
-		}
-
-		switch (ext_csd[EXT_CSD_REV]) {
-		case 1:
-			mmc->version = MMC_VERSION_4_1;
-			break;
-		case 2:
-			mmc->version = MMC_VERSION_4_2;
-			break;
-		case 3:
-			mmc->version = MMC_VERSION_4_3;
-			break;
-		case 5:
-			mmc->version = MMC_VERSION_4_41;
-			break;
-		case 6:
-			mmc->version = MMC_VERSION_4_5;
-			break;
-		}
-
-		/*
-		 * Check whether GROUP_DEF is set, if yes, read out
-		 * group size from ext_csd directly, or calculate
-		 * the group size from the csd value.
-		 */
-		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF]) {
-			mmc->erase_grp_size =
-				ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] *
-					MMC_MAX_BLOCK_LEN * 1024;
-		} else {
-			int erase_gsz, erase_gmul;
-			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
-			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
-			mmc->erase_grp_size = (erase_gsz + 1)
-				* (erase_gmul + 1);
-		}
-
-		/* store the partition info of emmc */
-		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
-		    ext_csd[EXT_CSD_BOOT_MULT])
-			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
-
-		mmc->capacity_boot = ext_csd[EXT_CSD_BOOT_MULT] << 17;
-
-		mmc->capacity_rpmb = ext_csd[EXT_CSD_RPMB_MULT] << 17;
-
-		for (i = 0; i < 4; i++) {
-			int idx = EXT_CSD_GP_SIZE_MULT + i * 3;
-			mmc->capacity_gp[i] = (ext_csd[idx + 2] << 16) +
-				(ext_csd[idx + 1] << 8) + ext_csd[idx];
-			mmc->capacity_gp[i] *=
-				ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE];
-			mmc->capacity_gp[i] *= ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
-		}
-	}
-
-	err = mmc_set_capacity(mmc, mmc->part_num);
-	if (err)
-		return err;
-
-	if (IS_SD(mmc))
-		err = sd_change_freq(mmc);
-	else
-		err = mmc_change_freq(mmc);
-
 	if (err)
 		return err;
 
 	/* Restrict card's capabilities by what the host can do */
-	mmc->card_caps &= mmc->host_caps;
+	host->card_caps &= host->host_caps;
 
-	if (IS_SD(mmc)) {
-		if (mmc->card_caps & MMC_MODE_4BIT) {
-			cmd.cmdidx = MMC_CMD_APP_CMD;
+	if (IS_SD(host)) {
+		if (host->card_caps & MMC_MODE_4BIT) {
+			cmd.opcode = MMC_CMD_APP_CMD;
 			cmd.resp_type = MMC_RSP_R1;
-			cmd.cmdarg = mmc->rca << 16;
+			cmd.arg = host->rca << 16;
+			cmd.flags = 0;
 
-			err = mmc_send_cmd(mmc, &cmd, NULL);
+			err = mmc_send_cmd(host, &cmd, NULL);
 			if (err)
 				return err;
 
-			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
+			cmd.opcode = SD_APP_SET_BUS_WIDTH;
 			cmd.resp_type = MMC_RSP_R1;
-			cmd.cmdarg = 2;
-			err = mmc_send_cmd(mmc, &cmd, NULL);
+			cmd.arg = 2;
+			cmd.flags = 0;
+			err = mmc_send_cmd(host, &cmd, NULL);
 			if (err)
 				return err;
 
-			mmc_set_bus_width(mmc, 4);
+			mmc_set_bus_width(host, 4);
 		}
 
-		if (mmc->card_caps & MMC_MODE_HS)
-			mmc->tran_speed = 50000000;
+		if (host->card_caps & MMC_MODE_HS)
+			host->clock = 50000000;
 		else
-			mmc->tran_speed = 25000000;
+			host->clock = 25000000;
 	} else {
-		int idx;
-
-		/* An array of possible bus widths in order of preference */
-		static unsigned ext_csd_bits[] = {
-			EXT_CSD_BUS_WIDTH_8,
-			EXT_CSD_BUS_WIDTH_4,
-			EXT_CSD_BUS_WIDTH_1,
-		};
-
-		/* An array to map CSD bus widths to host cap bits */
-		static unsigned ext_to_hostcaps[] = {
-			[EXT_CSD_BUS_WIDTH_4] = MMC_MODE_4BIT,
-			[EXT_CSD_BUS_WIDTH_8] = MMC_MODE_8BIT,
-		};
-
-		/* An array to map chosen bus width to an integer */
-		static unsigned widths[] = {
-			8, 4, 1,
-		};
-
-		for (idx=0; idx < ARRAY_SIZE(ext_csd_bits); idx++) {
-			unsigned int extw = ext_csd_bits[idx];
-
-			/*
-			 * Check to make sure the controller supports
-			 * this bus width, if it's more than 1
-			 */
-			if (extw != EXT_CSD_BUS_WIDTH_1 &&
-					!(mmc->host_caps & ext_to_hostcaps[extw]))
-				continue;
-
-			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_BUS_WIDTH, extw);
+		if (host->card_caps & MMC_MODE_4BIT) {
+			/* Set the card to use 4 bit*/
+			err = mmc_switch(host, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH,
+					EXT_CSD_BUS_WIDTH_4);
 
 			if (err)
-				continue;
+				return err;
 
-			mmc_set_bus_width(mmc, widths[idx]);
+			mmc_set_bus_width(host, 4);
+		} else if (host->card_caps & MMC_MODE_8BIT) {
+			/* Set the card to use 8 bit*/
+			err = mmc_switch(host, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH,
+					EXT_CSD_BUS_WIDTH_8);
 
-			err = mmc_send_ext_csd(mmc, test_csd);
-			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
-				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
-				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
-				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
-				 && ext_csd[EXT_CSD_REV] \
-				    == test_csd[EXT_CSD_REV]
-				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
-				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
-				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
-					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {
-
-				mmc->card_caps |= ext_to_hostcaps[extw];
-				break;
-			}
-		}
+			if (err)
+				return err;
 
-		if (mmc->card_caps & MMC_MODE_HS) {
-			if (mmc->card_caps & MMC_MODE_HS_52MHz)
-				mmc->tran_speed = 52000000;
-			else
-				mmc->tran_speed = 26000000;
+			mmc_set_bus_width(host, 8);
+		} else {
+			mmc_set_bus_width(host, 1);
 		}
 	}
 
-	mmc_set_clock(mmc, mmc->tran_speed);
+	mmc_set_ios(host);
 
 	/* fill in device description */
-	mmc->block_dev.lun = 0;
-	mmc->block_dev.type = 0;
-	mmc->block_dev.blksz = mmc->read_bl_len;
-	mmc->block_dev.log2blksz = LOG2(mmc->block_dev.blksz);
-	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-	sprintf(mmc->block_dev.vendor, "Man %06x Snr %04x%04x",
-		mmc->cid[0] >> 24, (mmc->cid[2] & 0xffff),
-		(mmc->cid[3] >> 16) & 0xffff);
-	sprintf(mmc->block_dev.product, "%c%c%c%c%c%c", mmc->cid[0] & 0xff,
-		(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
-		(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff,
-		(mmc->cid[2] >> 24) & 0xff);
-	sprintf(mmc->block_dev.revision, "%d.%d", (mmc->cid[2] >> 20) & 0xf,
-		(mmc->cid[2] >> 16) & 0xf);
-#else
-	mmc->block_dev.vendor[0] = 0;
-	mmc->block_dev.product[0] = 0;
-	mmc->block_dev.revision[0] = 0;
-#endif
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
-	init_part(&mmc->block_dev);
-#endif
+	host->block_dev.lun = 0;
+	host->block_dev.type = 0;
+	host->block_dev.blksz = (1<<9);
+	host->block_dev.lba = host->capacity;
+	sprintf(host->block_dev.vendor, "Man %06x Snr %08x", host->cid[0] >> 8,
+			(host->cid[2] << 8) | (host->cid[3] >> 24));
+	sprintf(host->block_dev.product, "%c%c%c%c%c", host->cid[0] & 0xff,
+			(host->cid[1] >> 24), (host->cid[1] >> 16) & 0xff,
+			(host->cid[1] >> 8) & 0xff, host->cid[1] & 0xff);
+	sprintf(host->block_dev.revision, "%d.%d", host->cid[2] >> 28,
+			(host->cid[2] >> 24) & 0xf);
+	init_part(&host->block_dev);
 
+#ifdef CONFIG_CMD_MOVINAND
+	init_raw_area_table(&host->block_dev);
+#endif
 	return 0;
 }
 
-static int mmc_send_if_cond(struct mmc *mmc)
+int mmc_send_if_cond(struct mmc *host)
 {
 	struct mmc_cmd cmd;
 	int err;
+	static const u8 test_pattern = 0xAA;
 
-	cmd.cmdidx = SD_CMD_SEND_IF_COND;
-	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
-	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	/*
+	 * To support SD 2.0 cards, we must always invoke SD_SEND_IF_COND
+	 * before SD_APP_OP_COND. This command will harmlessly fail for
+	 * SD 1.0 cards.
+	 */
+	cmd.opcode = SD_SEND_IF_COND;
+	cmd.arg = ((host->voltages & 0xFF8000) != 0) << 8 | test_pattern;
 	cmd.resp_type = MMC_RSP_R7;
+	cmd.flags = 0;
 
-	err = mmc_send_cmd(mmc, &cmd, NULL);
+	err = mmc_send_cmd(host, &cmd, NULL);
 
 	if (err)
 		return err;
 
-	if ((cmd.response[0] & 0xff) != 0xaa)
+	if ((cmd.resp[0] & 0xff) != 0xaa)
 		return UNUSABLE_ERR;
 	else
-		mmc->version = SD_VERSION_2;
+		host->version = SD_VERSION_2;
 
 	return 0;
 }
@@ -1160,115 +1068,53 @@
 	mmc->block_dev.removable = 1;
 	mmc->block_dev.block_read = mmc_bread;
 	mmc->block_dev.block_write = mmc_bwrite;
-	mmc->block_dev.block_erase = mmc_berase;
-	if (!mmc->b_max)
-		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
 
-	INIT_LIST_HEAD (&mmc->link);
+	INIT_LIST_HEAD(&mmc->link);
 
-	list_add_tail (&mmc->link, &mmc_devices);
+	list_add_tail(&mmc->link, &mmc_devices);
 
 	return 0;
 }
 
-#ifdef CONFIG_PARTITIONS
 block_dev_desc_t *mmc_get_dev(int dev)
 {
 	struct mmc *mmc = find_mmc_device(dev);
-	if (!mmc || mmc_init(mmc))
-		return NULL;
 
-	return &mmc->block_dev;
+	return mmc ? &mmc->block_dev : NULL;
 }
-#endif
 
-int mmc_start_init(struct mmc *mmc)
+int mmc_init(struct mmc *host)
 {
 	int err;
 
-	if (mmc_getcd(mmc) == 0) {
-		mmc->has_init = 0;
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-		printf("MMC: no card present\n");
-#endif
-		return NO_CARD_ERR;
-	}
-
-	if (mmc->has_init)
-		return 0;
-
-	err = mmc->init(mmc);
+	err = host->init(host);
 
 	if (err)
 		return err;
 
-	mmc_set_bus_width(mmc, 1);
-	mmc_set_clock(mmc, 1);
-
 	/* Reset the Card */
-	err = mmc_go_idle(mmc);
+	err = mmc_go_idle(host);
 
 	if (err)
 		return err;
 
-	/* The internal partition reset to user partition(0) at every CMD0*/
-	mmc->part_num = 0;
-
 	/* Test for SD version 2 */
-	err = mmc_send_if_cond(mmc);
+	err = mmc_send_if_cond(host);
 
 	/* Now try to get the SD card's operating condition */
-	err = sd_send_op_cond(mmc);
+	err = mmc_send_app_op_cond(host);
 
 	/* If the command timed out, we check for an MMC card */
 	if (err == TIMEOUT) {
-		err = mmc_send_op_cond(mmc);
+		err = mmc_send_op_cond(host);
 
-		if (err && err != IN_PROGRESS) {
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-			printf("Card did not respond to voltage select!\n");
-#endif
+		if (err)
+			return UNUSABLE_ERR;
+	} else
+		if (err)
 			return UNUSABLE_ERR;
-		}
-	}
-
-	if (err == IN_PROGRESS)
-		mmc->init_in_progress = 1;
-
-	return err;
-}
-
-static int mmc_complete_init(struct mmc *mmc)
-{
-	int err = 0;
-
-	if (mmc->op_cond_pending)
-		err = mmc_complete_op_cond(mmc);
-
-	if (!err)
-		err = mmc_startup(mmc);
-	if (err)
-		mmc->has_init = 0;
-	else
-		mmc->has_init = 1;
-	mmc->init_in_progress = 0;
-	return err;
-}
-
-int mmc_init(struct mmc *mmc)
-{
-	int err = IN_PROGRESS;
-	unsigned start = get_timer(0);
-
-	if (mmc->has_init)
-		return 0;
-	if (!mmc->init_in_progress)
-		err = mmc_start_init(mmc);
 
-	if (!err || err == IN_PROGRESS)
-		err = mmc_complete_init(mmc);
-	debug("%s: %d, time %lu\n", __func__, err, get_timer(start));
-	return err;
+	return mmc_startup(host);
 }
 
 /*
@@ -1283,8 +1129,6 @@
 int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
 int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
 
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-
 void print_mmc_devices(char separator)
 {
 	struct mmc *m;
@@ -1293,7 +1137,9 @@
 	list_for_each(entry, &mmc_devices) {
 		m = list_entry(entry, struct mmc, link);
 
-		printf("%s: %d", m->name, m->block_dev.dev);
+		m->init(m);
+
+		printf("%s_dev%d", m->name, m->block_dev.dev);
 
 		if (entry->next != &mmc_devices)
 			printf("%c ", separator);
@@ -1302,180 +1148,31 @@
 	printf("\n");
 }
 
-#else
-void print_mmc_devices(char separator) { }
-#endif
-
-int get_mmc_num(void)
-{
-	return cur_dev_num;
-}
-
-void mmc_set_preinit(struct mmc *mmc, int preinit)
-{
-	mmc->preinit = preinit;
-}
-
-static void do_preinit(void)
-{
-	struct mmc *m;
-	struct list_head *entry;
-
-	list_for_each(entry, &mmc_devices) {
-		m = list_entry(entry, struct mmc, link);
-
-		if (m->preinit)
-			mmc_start_init(m);
-	}
-}
-
-
 int mmc_initialize(bd_t *bis)
 {
-	INIT_LIST_HEAD (&mmc_devices);
+	struct mmc *mmc;
+	int err;
+
+	INIT_LIST_HEAD(&mmc_devices);
 	cur_dev_num = 0;
 
 	if (board_mmc_init(bis) < 0)
 		cpu_mmc_init(bis);
 
-#ifndef CONFIG_SPL_BUILD
+#if defined(DEBUG_S3C_HSMMC)
 	print_mmc_devices(',');
 #endif
 
-	do_preinit();
-	return 0;
-}
-
-#ifdef CONFIG_SUPPORT_EMMC_BOOT
-/*
- * This function changes the size of boot partition and the size of rpmb
- * partition present on EMMC devices.
- *
- * Input Parameters:
- * struct *mmc: pointer for the mmc device strcuture
- * bootsize: size of boot partition
- * rpmbsize: size of rpmb partition
- *
- * Returns 0 on success.
- */
-
-int mmc_boot_partition_size_change(struct mmc *mmc, unsigned long bootsize,
-				unsigned long rpmbsize)
-{
-	int err;
-	struct mmc_cmd cmd;
-
-	/* Only use this command for raw EMMC moviNAND. Enter backdoor mode */
-	cmd.cmdidx = MMC_CMD_RES_MAN;
-	cmd.resp_type = MMC_RSP_R1b;
-	cmd.cmdarg = MMC_CMD62_ARG1;
-
-	err = mmc_send_cmd(mmc, &cmd, NULL);
-	if (err) {
-		debug("mmc_boot_partition_size_change: Error1 = %d\n", err);
-		return err;
-	}
-
-	/* Boot partition changing mode */
-	cmd.cmdidx = MMC_CMD_RES_MAN;
-	cmd.resp_type = MMC_RSP_R1b;
-	cmd.cmdarg = MMC_CMD62_ARG2;
-
-	err = mmc_send_cmd(mmc, &cmd, NULL);
-	if (err) {
-		debug("mmc_boot_partition_size_change: Error2 = %d\n", err);
-		return err;
-	}
-	/* boot partition size is multiple of 128KB */
-	bootsize = (bootsize * 1024) / 128;
-
-	/* Arg: boot partition size */
-	cmd.cmdidx = MMC_CMD_RES_MAN;
-	cmd.resp_type = MMC_RSP_R1b;
-	cmd.cmdarg = bootsize;
-
-	err = mmc_send_cmd(mmc, &cmd, NULL);
-	if (err) {
-		debug("mmc_boot_partition_size_change: Error3 = %d\n", err);
-		return err;
-	}
-	/* RPMB partition size is multiple of 128KB */
-	rpmbsize = (rpmbsize * 1024) / 128;
-	/* Arg: RPMB partition size */
-	cmd.cmdidx = MMC_CMD_RES_MAN;
-	cmd.resp_type = MMC_RSP_R1b;
-	cmd.cmdarg = rpmbsize;
-
-	err = mmc_send_cmd(mmc, &cmd, NULL);
-	if (err) {
-		debug("mmc_boot_partition_size_change: Error4 = %d\n", err);
-		return err;
-	}
-	return 0;
-}
-
-/*
- * This function shall form and send the commands to open / close the
- * boot partition specified by user.
- *
- * Input Parameters:
- * ack: 0x0 - No boot acknowledge sent (default)
- *	0x1 - Boot acknowledge sent during boot operation
- * part_num: User selects boot data that will be sent to master
- *	0x0 - Device not boot enabled (default)
- *	0x1 - Boot partition 1 enabled for boot
- *	0x2 - Boot partition 2 enabled for boot
- * access: User selects partitions to access
- *	0x0 : No access to boot partition (default)
- *	0x1 : R/W boot partition 1
- *	0x2 : R/W boot partition 2
- *	0x3 : R/W Replay Protected Memory Block (RPMB)
- *
- * Returns 0 on success.
- */
-int mmc_boot_part_access(struct mmc *mmc, u8 ack, u8 part_num, u8 access)
-{
-	int err;
-	struct mmc_cmd cmd;
-
-	/* Boot ack enable, boot partition enable , boot partition access */
-	cmd.cmdidx = MMC_CMD_SWITCH;
-	cmd.resp_type = MMC_RSP_R1b;
-
-	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-			(EXT_CSD_PART_CONF << 16) |
-			((EXT_CSD_BOOT_ACK(ack) |
-			EXT_CSD_BOOT_PART_NUM(part_num) |
-			EXT_CSD_PARTITION_ACCESS(access)) << 8);
-
-	err = mmc_send_cmd(mmc, &cmd, NULL);
-	if (err) {
-		if (access) {
-			debug("mmc boot partition#%d open fail:Error1 = %d\n",
-			      part_num, err);
-		} else {
-			debug("mmc boot partition#%d close fail:Error = %d\n",
-			      part_num, err);
-		}
-		return err;
-	}
-
-	if (access) {
-		/* 4bit transfer mode at booting time. */
-		cmd.cmdidx = MMC_CMD_SWITCH;
-		cmd.resp_type = MMC_RSP_R1b;
-
-		cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-				(EXT_CSD_BOOT_BUS_WIDTH << 16) |
-				((1 << 0) << 8);
-
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+	mmc = find_mmc_device(0);
+	if (mmc) {
+		err = mmc_init(mmc);
+		if (err)
+			err = mmc_init(mmc);
 		if (err) {
-			debug("mmc boot partition#%d open fail:Error2 = %d\n",
-			      part_num, err);
+			printf("Card init fail!\n");
 			return err;
 		}
 	}
+	printf("%ldMB\n", (mmc->capacity/(1024*1024/mmc->read_bl_len)));
 	return 0;
 }
-#endif
diff -urN u-boot-2013.10/drivers/mmc/s3c_hsmmc.c u-boot-2013.10_aston/drivers/mmc/s3c_hsmmc.c
--- u-boot-2013.10/drivers/mmc/s3c_hsmmc.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/drivers/mmc/s3c_hsmmc.c	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,460 @@
+/*
+ * Copyright 2007, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the pxa mmc code:
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <asm/io.h>
+//#include <regs.h>
+#include <s5pc110.h>
+
+#include <s3c_hsmmc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+//#define DEBUG_S3C_HSMMC
+#ifdef DEBUG_S3C_HSMMC
+#define dbg(x...)       printf(x)
+#else
+#define dbg(x...)       do { } while (0)
+#endif
+
+#ifndef printk
+#define printk printf
+#endif
+
+#ifndef mdelay
+#define mdelay(x)	udelay(1000*x)
+#endif
+
+struct mmc mmc_channel[MMC_MAX_CHANNEL];
+
+struct sdhci_host mmc_host[MMC_MAX_CHANNEL];
+
+static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_data *data)
+{
+	u8 ctrl;
+
+	writeb(0xe, host->ioaddr + SDHCI_TIMEOUT_CONTROL);
+
+	/*
+	 * Always uses SDMA
+	 */
+ 	dbg("data->dest: %08x\n", data->dest);
+	writel(virt_to_phys((u32)data->dest), host->ioaddr + SDHCI_DMA_ADDRESS);
+
+	ctrl = readb(host->ioaddr + SDHCI_HOST_CONTROL);
+	ctrl &= ~SDHCI_CTRL_DMA_MASK;
+	writeb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
+
+	/* We do not handle DMA boundaries, so set it to max (512 KiB) */
+	writew(SDHCI_MAKE_BLKSZ(7, data->blocksize),
+		host->ioaddr + SDHCI_BLOCK_SIZE);
+	writew(data->blocks, host->ioaddr + SDHCI_BLOCK_COUNT);
+}
+
+static void sdhci_set_transfer_mode(struct sdhci_host *host,
+	struct mmc_data *data)
+{
+	u16 mode;
+
+	mode = SDHCI_TRNS_BLK_CNT_EN | SDHCI_TRNS_DMA;
+	if (data->blocks > 1)
+		mode |= SDHCI_TRNS_MULTI | SDHCI_TRNS_ACMD12;
+	if (data->flags & MMC_DATA_READ)
+		mode |= SDHCI_TRNS_READ;
+
+	writew(mode, host->ioaddr + SDHCI_TRANSFER_MODE);
+}
+
+/*
+ * Sends a command out on the bus.  Takes the mmc pointer,
+ * a command pointer, and an optional data pointer.
+ */
+static int
+s3c_hsmmc_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
+			struct mmc_data *data)
+{
+	struct sdhci_host *host = mmc->priv;
+
+	int flags, i;
+	u32 mask;
+	unsigned long timeout;
+
+	/* Clear Error Interrupt Status Register before issuing cmd */
+	writew(readw(host->ioaddr + SDHCI_ERRINT_STATUS),
+	host->ioaddr + SDHCI_ERRINT_STATUS);
+
+	/* Clear Normal Interrupt Status Register before issuing cmd */
+	writew(readw(host->ioaddr + SDHCI_INT_STATUS),
+	host->ioaddr + SDHCI_INT_STATUS);
+
+	/* Wait max 10 ms */
+	timeout = 10;
+
+	/* Check the status busy bit until it is low*/
+	while ((readw(host->ioaddr + S3C64XX_SDHCI_CONTROL4)
+		& S3C64XX_SDHCI_CONTROL4_BUSY)) {
+		if(timeout == 0) {
+			printk("sdhci: Status busy bit is \
+				LOW for 10ms(warning)\n");
+			break;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	/* Wait max 10 ms */
+	timeout = 10;
+
+	mask = SDHCI_CMD_INHIBIT;
+	if ((data != NULL) || (cmd->flags & MMC_RSP_BUSY))
+		mask |= SDHCI_DATA_INHIBIT;
+
+	/* We shouldn't wait for data inihibit for stop commands, even
+	   though they might use busy signaling */
+	if (data)
+		mask &= ~SDHCI_DATA_INHIBIT;
+
+	while (readl(host->ioaddr + SDHCI_PRESENT_STATE) & mask) {
+		if (timeout == 0) {
+			printk("Controller never released " \
+				"inhibit bit(s).\n");
+			return -1;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	if (data)
+		sdhci_prepare_data(host, data);
+
+	dbg("cmd->arg: %08x\n", cmd->arg);	
+	writel(cmd->arg, host->ioaddr + SDHCI_ARGUMENT);
+
+	if (data)
+		sdhci_set_transfer_mode(host, data);
+
+	if ((cmd->resp_type & MMC_RSP_136) && (cmd->resp_type & MMC_RSP_BUSY)) {
+		return -1;
+	}
+
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = SDHCI_CMD_RESP_NONE;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = SDHCI_CMD_RESP_LONG;
+	else if (cmd->resp_type & MMC_RSP_BUSY)
+		flags = SDHCI_CMD_RESP_SHORT_BUSY;
+	else
+		flags = SDHCI_CMD_RESP_SHORT;
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= SDHCI_CMD_CRC;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= SDHCI_CMD_INDEX;
+	if (data)
+		flags |= SDHCI_CMD_DATA;
+
+	dbg("cmd: %d\n", cmd->opcode);
+	
+	writew(SDHCI_MAKE_CMD(cmd->opcode, flags),
+		host->ioaddr + SDHCI_COMMAND);
+
+	for (i=0; i<0x100000; i++) {
+		mask = readl(host->ioaddr + SDHCI_INT_STATUS);
+		if (mask & SDHCI_INT_RESPONSE) {
+			if (!data)
+				writel(mask, host->ioaddr + SDHCI_INT_STATUS);
+			break;
+		}
+	}
+	
+	if (0x100000 == i) {
+		printk("FAIL: waiting for status update.\n");
+		return TIMEOUT;
+	}
+
+	if (mask & SDHCI_INT_TIMEOUT) {
+		dbg("timeout: %08x cmd %d\n", mask, cmd->opcode);
+		return TIMEOUT;
+	}
+	else if (mask & SDHCI_INT_ERROR) {
+		dbg("error: %08x cmd %d\n", mask, cmd->opcode);
+		return -1;
+	}
+	
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		if (cmd->resp_type & MMC_RSP_136) {
+			/* CRC is stripped so we need to do some shifting. */
+			for (i = 0;i < 4;i++) {
+				cmd->resp[i] = readl(host->ioaddr +
+					SDHCI_RESPONSE + (3-i)*4) << 8;
+				dbg("cmd->resp[%d]: %08x\n", i, cmd->resp[i]);
+				if (i != 3)
+					cmd->resp[i] |=
+						readb(host->ioaddr +
+						SDHCI_RESPONSE + (3-i)*4-1);
+				dbg("cmd->resp[%d]: %08x\n", i, cmd->resp[i]);				
+			}
+		} else if (cmd->resp_type & MMC_RSP_BUSY) {
+			for (i = 0;i < 0x100000; i++)
+				if (readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_DATA_BIT(0))
+					break;
+			if (0x100000 == i) {
+				printk("FAIL: card is still busy\n");
+				return TIMEOUT;
+			}
+							
+			cmd->resp[0] = readl(host->ioaddr + SDHCI_RESPONSE);
+			dbg("cmd->resp[0]: %08x\n", cmd->resp[i]);
+		} else {
+			cmd->resp[0] = readl(host->ioaddr + SDHCI_RESPONSE);
+			dbg("cmd->resp[0]: %08x\n", cmd->resp[i]);
+		}
+	}
+
+	if (data) {
+		while (!(mask & (SDHCI_INT_DATA_END | SDHCI_INT_ERROR | SDHCI_INT_DMA_END))) {
+			mask = readl(host->ioaddr + SDHCI_INT_STATUS);
+		}
+		writel(mask, host->ioaddr + SDHCI_INT_STATUS);
+		if (mask & SDHCI_INT_ERROR) {
+			printf("error during transfer: 0x%08x\n", mask);
+			return -1;
+		} else if (mask & SDHCI_INT_DMA_END) {
+			printf("SDHCI_INT_DMA_END\n");
+		} else {		
+			dbg("r/w is done\n");
+		}
+	}
+
+	mdelay(1);
+	return 0;
+}
+
+static void sdhci_change_clock(struct sdhci_host *host, uint clock)
+{
+	int div;
+	u16 clk;
+	unsigned long timeout;
+	u32 ctrl2;
+
+	/* Set SCLK_MMC from SYSCON as a clock source */
+	ctrl2 = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
+	ctrl2 &= ~(3 << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT);
+	ctrl2 |= 2 << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+	writew(ctrl2, host->ioaddr + S3C_SDHCI_CONTROL2);
+
+	writew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* XXX: we assume that clock is between 40MHz and 50MHz */
+	if (clock == 0)
+		goto out;
+	else if (clock <= 400000)
+		div = 0x40;
+	else if (clock <= 20000000)
+		div = 2;
+	else if (clock <= 26000000)
+		div = 1;
+	else
+		div = 0;
+	dbg("div: %d\n", div);
+
+	clk = div << SDHCI_DIVIDER_SHIFT;
+	clk |= SDHCI_CLOCK_INT_EN;
+	writew(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 10 ms */
+	timeout = 10;
+	while (!((clk = readw(host->ioaddr + SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printk("Internal clock never stabilised.\n");
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	clk |= SDHCI_CLOCK_CARD_EN;
+	writew(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+out:
+	host->clock = clock;
+
+	return;
+}
+
+static void s3c_hsmmc_set_ios(struct mmc *mmc)
+{
+	struct sdhci_host *host = mmc->priv;
+	u8 ctrl;
+
+	dbg("set_ios: bus_width: %x, clock: %d\n", mmc->bus_width, mmc->clock);
+	setup_sdhci0_cfg_card(host);
+	sdhci_change_clock(host, mmc->clock);
+
+	ctrl = readb(host->ioaddr + SDHCI_HOST_CONTROL);
+	if (mmc->bus_width == 4)
+		ctrl |= SDHCI_CTRL_4BITBUS;
+	else
+		ctrl &= ~SDHCI_CTRL_4BITBUS;
+
+	ctrl &= ~SDHCI_CTRL_HISPD;
+
+	writeb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
+}
+
+static void sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	ulong timeout;
+
+	writeb(mask, host->ioaddr + SDHCI_SOFTWARE_RESET);
+
+	if (mask & SDHCI_RESET_ALL)
+		host->clock = 0;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readb(host->ioaddr + SDHCI_SOFTWARE_RESET) & mask) {
+		if (timeout == 0) {
+			printk("mmc: Reset 0x%x never completed.\n",
+				(int)mask);
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+}
+
+static void sdhci_init(struct sdhci_host *host)
+{
+	u32 intmask;
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	intmask = SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
+		SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
+		SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT |
+		SDHCI_INT_CARD_REMOVE | SDHCI_INT_CARD_INSERT |
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL |
+		SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE |
+		SDHCI_INT_ADMA_ERROR;
+
+	writel(intmask, host->ioaddr + SDHCI_INT_ENABLE);
+	writel(intmask, host->ioaddr + SDHCI_SIGNAL_ENABLE);
+}
+
+static int s3c_hsmmc_init(struct mmc *mmc)
+{
+	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	host->version = readw(host->ioaddr + SDHCI_HOST_VERSION);
+	sdhci_init(host);
+
+	sdhci_change_clock(host, 400000);
+
+	return 0;
+}
+
+static int s3c_hsmmc_initialize(int channel)
+{
+	struct mmc *mmc;
+
+	mmc = &mmc_channel[channel];
+
+	sprintf(mmc->name, "S3C_HSMMC%d", channel);
+	mmc->priv = &mmc_host[channel];
+	mmc->send_cmd = s3c_hsmmc_send_command;
+	mmc->set_ios = s3c_hsmmc_set_ios;
+	mmc->init = s3c_hsmmc_init;
+
+	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_HS_52MHz | MMC_MODE_HS;
+
+	mmc->f_min = 400000;
+	mmc->f_max = 52000000;
+
+	mmc_host[channel].clock = 0;
+
+	switch(channel) {
+	case 0:
+		mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_0_BASE;
+		break;
+	case 1:
+		mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_1_BASE;
+		break;
+	case 2:
+		mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_2_BASE;
+		break;
+#ifdef USE_MMC3
+	case 3:
+		mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_3_BASE;
+		break;
+#endif
+	default:
+		printk("mmc err: not supported channel %d\n", channel);
+	}
+	
+	return mmc_register(mmc);
+}
+
+int smdk_s3c_hsmmc_init(void)
+{
+	int err;
+
+#ifdef USE_MMC0
+	err = s3c_hsmmc_initialize(0);
+	if(err)
+		return err;
+#endif
+
+#ifdef USE_MMC1
+	err = s3c_hsmmc_initialize(1);
+	if(err)
+		return err;
+#endif	
+
+#ifdef USE_MMC2
+	err = s3c_hsmmc_initialize(2);
+	if(err)
+		return err;
+#endif	
+
+#ifdef USE_MMC3
+	err = s3c_hsmmc_initialize(3);
+	if(err)
+		return err;
+#endif
+	return -1;
+}
diff -urN u-boot-2013.10/include/configs/s5p_goni.h u-boot-2013.10_aston/include/configs/s5p_goni.h
--- u-boot-2013.10/include/configs/s5p_goni.h	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/include/configs/s5p_goni.h	2016-01-04 21:40:00.000000000 -0800
@@ -26,11 +26,118 @@
 /* input clock of PLL: has 24MHz input clock at S5PC110 */
 #define CONFIG_SYS_CLK_FREQ_C110	24000000
 
+/*********************************************************************/
+// DDR
+#define DMC0_MEMCONFIG_0	0x30F01323	// MemConfig0	256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+#define DMC0_MEMCONFIG_1	0x40F01323	// MemConfig1
+#define DMC0_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
+#define DMC0_TIMING_ROW		0x28233287	// TimingRow	for @200MHz
+#define DMC0_TIMING_DATA	0x23240304	// TimingData	CL=3
+#define	DMC0_TIMING_PWR		0x09C80232	// TimingPower
+
+#define	DMC1_MEMCONTROL		0x00202400	// MemControl	BL=4, 2 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
+#define DMC1_MEMCONFIG_0	0x40C01323	// MemConfig0	512MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
+#define DMC1_MEMCONFIG_1	0x00E01323	// MemConfig1
+#define DMC1_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4
+#define DMC1_TIMING_ROW		0x28233289	// TimingRow	for @200MHz
+#define DMC1_TIMING_DATA	0x23240304	// TimingData	CL=3
+#define	DMC1_TIMING_PWR		0x08280232	// TimingPower
+
+// ENV
+#define CFG_ENV_SIZE		0x4000		// 16kb  32个扇区
+
+#define CONFIG_EVT1			1
+
+// banner
+#define CONFIG_IDENT_STRING " for ASTON210"
+
+// clock
+#define APLL_MDIV       0x7d
+#define APLL_PDIV       0x3
+#define APLL_SDIV       0x1
+
+#define APLL_LOCKTIME_VAL	0x2cf
+
+#if defined(CONFIG_EVT1)
+/* Set AFC value */
+#define AFC_ON		0x00000000
+#define AFC_OFF		0x10000010
+#endif
+
+#define MPLL_MDIV	0x29b
+#define MPLL_PDIV	0xc
+#define MPLL_SDIV	0x1
+
+#define EPLL_MDIV	0x60
+#define EPLL_PDIV	0x6
+#define EPLL_SDIV	0x2
+
+#define VPLL_MDIV	0x6c
+#define VPLL_PDIV	0x6
+#define VPLL_SDIV	0x3
+
+/* CLK_DIV0 */
+#define APLL_RATIO	0
+#define A2M_RATIO	4
+#define HCLK_MSYS_RATIO	8
+#define PCLK_MSYS_RATIO	12
+#define HCLK_DSYS_RATIO	16
+#define PCLK_DSYS_RATIO 20
+#define HCLK_PSYS_RATIO	24
+#define PCLK_PSYS_RATIO 28
+
+#define CLK_DIV0_MASK	0x7fffffff
+
+#define set_pll(mdiv, pdiv, sdiv)	(1<<31 | mdiv<<16 | pdiv<<8 | sdiv)
+
+#define APLL_VAL	set_pll(APLL_MDIV,APLL_PDIV,APLL_SDIV)
+#define MPLL_VAL	set_pll(MPLL_MDIV,MPLL_PDIV,MPLL_SDIV)
+#define EPLL_VAL	set_pll(EPLL_MDIV,EPLL_PDIV,EPLL_SDIV)
+#define VPLL_VAL	set_pll(VPLL_MDIV,VPLL_PDIV,VPLL_SDIV)
+
+#define CLK_DIV0_VAL    ((0<<APLL_RATIO)|(4<<A2M_RATIO)|(4<<HCLK_MSYS_RATIO)|(1<<PCLK_MSYS_RATIO)\
+			|(3<<HCLK_DSYS_RATIO)|(1<<PCLK_DSYS_RATIO)|(4<<HCLK_PSYS_RATIO)|(1<<PCLK_PSYS_RATIO))
+#define CLK_DIV1_VAL	((1<<16)|(1<<12)|(1<<8)|(1<<4))
+#define CLK_DIV2_VAL	(1<<0)
+
+// 机器码
+//#define CONFIG_MACH_TYPE	2456
+
+// 设置环境变量分区的起始扇区
+#define CONFIG_ENV_OFFSET 		17*512	// 17个扇区开始的位置
+
+
+// 网络相关命令
+//#define CONFIG_CMD_NET			// 添加网络支持
+#define CONFIG_CMD_PING				// 添加ping命令支持
+
+#define DM9000_16BIT_DATA
+
+#define CONFIG_DRIVER_DM9000	1
+
+#ifdef CONFIG_DRIVER_DM9000
+//#define CONFIG_DM9000_BASE		(0xA8000000)
+#define CONFIG_DM9000_BASE		(0x88000300)
+#define DM9000_IO			(CONFIG_DM9000_BASE)
+#if defined(DM9000_16BIT_DATA)
+//#define DM9000_DATA			(CONFIG_DM9000_BASE+2)
+#define DM9000_DATA			(CONFIG_DM9000_BASE+4)
+
+#else
+#define DM9000_DATA			(CONFIG_DM9000_BASE+1)
+#endif
+#endif
+
+
+
+/*********************************************************************/
+
 /* DRAM Base */
 #define CONFIG_SYS_SDRAM_BASE		0x30000000
 
 /* Text Base */
 #define CONFIG_SYS_TEXT_BASE		0x34800000
+#define CFG_PHY_UBOOT_BASE			CONFIG_SYS_TEXT_BASE
 
 #define CONFIG_SETUP_MEMORY_TAGS
 #define CONFIG_CMDLINE_TAG
@@ -51,8 +158,20 @@
 /* MMC */
 #define CONFIG_GENERIC_MMC
 #define CONFIG_MMC
-#define CONFIG_SDHCI
-#define CONFIG_S5P_SDHCI
+//#define CONFIG_SDHCI
+//#define CONFIG_S5P_SDHCI			// 注释掉去掉原来的驱动
+#define CONFIG_S3C_HSMMC			// 添加这一行添加上新的移植过来的驱动文件
+
+/* IROM specific data */
+#define SDMMC_BLK_SIZE        (0xD003A500)
+#define COPY_SDMMC_TO_MEM     (0xD003E008)
+
+/* The macro for MMC channel 0 is defined by default and can't be undefined */
+#define USE_MMC0
+#define USE_MMC2
+#define MMC_MAX_CHANNEL		4
+
+
 
 /* PWM */
 #define CONFIG_PWM			1
@@ -65,21 +184,23 @@
 
 #undef CONFIG_CMD_FPGA
 #undef CONFIG_CMD_MISC
-#undef CONFIG_CMD_NET
+//#undef CONFIG_CMD_NET
 #undef CONFIG_CMD_NFS
 #undef CONFIG_CMD_XIMG
 #define CONFIG_CMD_CACHE
 #define CONFIG_CMD_REGINFO
-#define CONFIG_CMD_ONENAND
+//#define CONFIG_CMD_ONENAND		// 在x210上没有onenand
 #define CONFIG_CMD_MTDPARTS
 #define CONFIG_CMD_MMC
 
-#define CONFIG_BOOTDELAY		1
+#define CONFIG_BOOTDELAY		3
 #define CONFIG_ZERO_BOOTDELAY_CHECK
 
 #define CONFIG_MTD_DEVICE
 #define CONFIG_MTD_PARTITIONS
 
+
+#if 0
 /* Actual modem binary size is 16MiB. Add 2MiB for bad block handling */
 #define MTDIDS_DEFAULT		"onenand0=samsung-onenand"
 #define MTDPARTS_DEFAULT	"mtdparts=samsung-onenand:1m(bootloader)"\
@@ -158,6 +279,19 @@
 	"ubiblock=8\0" \
 	"ubi=enabled\0" \
 	"opts=always_resume=1"
+#endif 
+
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#define CONFIG_BOOTCOMMAND	"tftp 0x30008000 zImage-qt; bootm 0x30008000"
+#define CONFIG_BOOTARGS		"console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3"
+#define CONFIG_ETHADDR		00:57:5c:26:0a:5b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		192.168.1.10
+#define CONFIG_SERVERIP		192.168.1.141
+#define CONFIG_GATEWAYIP	192.168.1.1
+
 
 /* Miscellaneous configurable options */
 #define CONFIG_SYS_LONGHELP		/* undef to save memory */
@@ -176,25 +310,30 @@
 #define CONFIG_SYS_HZ			1000
 
 /* Goni has 3 banks of DRAM, but swap the bank */
-#define CONFIG_NR_DRAM_BANKS	3
+// x210有2个bank的ddr，各自256mb
+#define CONFIG_NR_DRAM_BANKS	2
 #define PHYS_SDRAM_1		CONFIG_SYS_SDRAM_BASE	/* OneDRAM Bank #0 */
-#define PHYS_SDRAM_1_SIZE	(80 << 20)		/* 80 MB in Bank #0 */
+#define PHYS_SDRAM_1_SIZE	(256 << 20)		/* 256 MB in Bank #0 */
 #define PHYS_SDRAM_2		0x40000000		/* mDDR DMC1 Bank #1 */
 #define PHYS_SDRAM_2_SIZE	(256 << 20)		/* 256 MB in Bank #1 */
-#define PHYS_SDRAM_3		0x50000000		/* mDDR DMC2 Bank #2 */
-#define PHYS_SDRAM_3_SIZE	(128 << 20)		/* 128 MB in Bank #2 */
+
 
 #define CONFIG_SYS_MONITOR_BASE		0x00000000
 #define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* 256 KiB */
 
 /* FLASH and environment organization */
-#define CONFIG_ENV_IS_IN_ONENAND	1
-#define CONFIG_ENV_SIZE			(256 << 10)	/* 256 KiB, 0x40000 */
-#define CONFIG_ENV_ADDR			(1 << 20)	/* 1 MB, 0x100000 */
-
-#define CONFIG_USE_ONENAND_BOARD_INIT
-#define CONFIG_SAMSUNG_ONENAND		1
-#define CONFIG_SYS_ONENAND_BASE		0xB0000000
+//#define CONFIG_ENV_IS_IN_ONENAND	1
+//#define CONFIG_ENV_SIZE			(256 << 10)	/* 256 KiB, 0x40000 */
+//#define CONFIG_ENV_ADDR			(1 << 20)	/* 1 MB, 0x100000 */
+
+//#define CONFIG_USE_ONENAND_BOARD_INIT
+//#define CONFIG_SAMSUNG_ONENAND		1
+//#define CONFIG_SYS_ONENAND_BASE		0xB0000000
+
+#define CONFIG_ENV_SIZE			CFG_ENV_SIZE		// 0x4000
+#define CONFIG_ENV_IS_IN_MMC	1
+#define CONFIG_SYS_MMC_ENV_DEV	0					// 0表示iNand，1表示SD卡
+
 
 #define CONFIG_DOS_PARTITION		1
 
diff -urN u-boot-2013.10/include/mmc.h u-boot-2013.10_aston/include/mmc.h
--- u-boot-2013.10/include/mmc.h	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/include/mmc.h	2016-01-04 21:40:00.000000000 -0800
@@ -1,45 +1,111 @@
+#ifndef CONFIG_GENERIC_MMC
+
+/*
+ * (C) Copyright 2000-2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _MMC_H_
+#define _MMC_H_
+
+#include <asm/arch/mmc.h>
+
+/* MMC command numbers */
+#define MMC_CMD_GO_IDLE_STATE		0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID		2
+#define MMC_CMD_SET_RELATIVE_ADDR	3
+#define MMC_CMD_SET_DSR			4
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_CSD		9
+#define MMC_CMD_SEND_CID		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_SINGLE_BLOCK	17
+#define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_CMD_WRITE_BLOCK		24
+#define MMC_CMD_APP_CMD			55
+
+/* SD Card command numbers */
+#define SD_CMD_SEND_RELATIVE_ADDR	3
+#define SD_CMD_SWITCH			6
+#define SD_CMD_SEND_IF_COND		8
+
+#define SD_CMD_APP_SET_BUS_WIDTH	6
+#define SD_CMD_APP_SEND_OP_COND		41
+
+int mmc_init(int verbose);
+int mmc_read(ulong src, uchar *dst, int size);
+int mmc_write(uchar *src, ulong dst, int size);
+int mmc2info(ulong addr);
+#endif /* _MMC_H_ */
+
+#else	/* !CONFIG_GENERIC_MMC */
+
 /*
- * Copyright 2008,2010 Freescale Semiconductor, Inc
+ * Copyright 2008, Freescale Semiconductor, Inc
  * Andy Fleming
  *
  * Based (loosely) on the Linux code
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #ifndef _MMC_H_
 #define _MMC_H_
 
 #include <linux/list.h>
-#include <linux/compiler.h>
 
-#define SD_VERSION_SD	0x20000
-#define SD_VERSION_3	(SD_VERSION_SD | 0x300)
-#define SD_VERSION_2	(SD_VERSION_SD | 0x200)
-#define SD_VERSION_1_0	(SD_VERSION_SD | 0x100)
-#define SD_VERSION_1_10	(SD_VERSION_SD | 0x10a)
+#define SD_VERSION_SD		0x20000
+#define SD_VERSION_2		(SD_VERSION_SD | 0x20)
+#define SD_VERSION_1_0		(SD_VERSION_SD | 0x10)
+#define SD_VERSION_1_10		(SD_VERSION_SD | 0x1a)
 #define MMC_VERSION_MMC		0x10000
 #define MMC_VERSION_UNKNOWN	(MMC_VERSION_MMC)
-#define MMC_VERSION_1_2		(MMC_VERSION_MMC | 0x102)
-#define MMC_VERSION_1_4		(MMC_VERSION_MMC | 0x104)
-#define MMC_VERSION_2_2		(MMC_VERSION_MMC | 0x202)
-#define MMC_VERSION_3		(MMC_VERSION_MMC | 0x300)
-#define MMC_VERSION_4		(MMC_VERSION_MMC | 0x400)
-#define MMC_VERSION_4_1		(MMC_VERSION_MMC | 0x401)
-#define MMC_VERSION_4_2		(MMC_VERSION_MMC | 0x402)
-#define MMC_VERSION_4_3		(MMC_VERSION_MMC | 0x403)
-#define MMC_VERSION_4_41	(MMC_VERSION_MMC | 0x429)
-#define MMC_VERSION_4_5		(MMC_VERSION_MMC | 0x405)
+#define MMC_VERSION_1_2		(MMC_VERSION_MMC | 0x12)
+#define MMC_VERSION_1_4		(MMC_VERSION_MMC | 0x14)
+#define MMC_VERSION_2_2		(MMC_VERSION_MMC | 0x22)
+#define MMC_VERSION_3		(MMC_VERSION_MMC | 0x30)
+#define MMC_VERSION_4		(MMC_VERSION_MMC | 0x40)
 
 #define MMC_MODE_HS		0x001
 #define MMC_MODE_HS_52MHz	0x010
 #define MMC_MODE_4BIT		0x100
 #define MMC_MODE_8BIT		0x200
-#define MMC_MODE_SPI		0x400
-#define MMC_MODE_HC		0x800
-
-#define MMC_MODE_MASK_WIDTH_BITS (MMC_MODE_4BIT | MMC_MODE_8BIT)
-#define MMC_MODE_WIDTH_BITS_SHIFT 8
 
 #define SD_DATA_4BIT	0x00040000
 
@@ -52,17 +118,16 @@
 #define UNUSABLE_ERR		-17 /* Unusable Card */
 #define COMM_ERR		-18 /* Communications Error */
 #define TIMEOUT			-19
-#define IN_PROGRESS		-20 /* operation is in progress */
 
 #define MMC_CMD_GO_IDLE_STATE		0
 #define MMC_CMD_SEND_OP_COND		1
-#define MMC_CMD_ALL_SEND_CID		2
-#define MMC_CMD_SET_RELATIVE_ADDR	3
+#define MMC_ALL_SEND_CID		2
+#define MMC_SET_RELATIVE_ADDR		3
 #define MMC_CMD_SET_DSR			4
 #define MMC_CMD_SWITCH			6
 #define MMC_CMD_SELECT_CARD		7
 #define MMC_CMD_SEND_EXT_CSD		8
-#define MMC_CMD_SEND_CSD		9
+#define MMC_SEND_CSD			9
 #define MMC_CMD_SEND_CID		10
 #define MMC_CMD_STOP_TRANSMISSION	12
 #define MMC_CMD_SEND_STATUS		13
@@ -71,27 +136,20 @@
 #define MMC_CMD_READ_MULTIPLE_BLOCK	18
 #define MMC_CMD_WRITE_SINGLE_BLOCK	24
 #define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
-#define MMC_CMD_ERASE_GROUP_START	35
-#define MMC_CMD_ERASE_GROUP_END		36
-#define MMC_CMD_ERASE			38
 #define MMC_CMD_APP_CMD			55
-#define MMC_CMD_SPI_READ_OCR		58
-#define MMC_CMD_SPI_CRC_ON_OFF		59
-#define MMC_CMD_RES_MAN			62
 
-#define MMC_CMD62_ARG1			0xefac62ec
-#define MMC_CMD62_ARG2			0xcbaea7
-
-
-#define SD_CMD_SEND_RELATIVE_ADDR	3
-#define SD_CMD_SWITCH_FUNC		6
-#define SD_CMD_SEND_IF_COND		8
-
-#define SD_CMD_APP_SET_BUS_WIDTH	6
-#define SD_CMD_ERASE_WR_BLK_START	32
-#define SD_CMD_ERASE_WR_BLK_END		33
-#define SD_CMD_APP_SEND_OP_COND		41
-#define SD_CMD_APP_SEND_SCR		51
+/* This is basically the same command as for MMC with some quirks. */
+#define SD_SEND_RELATIVE_ADDR	3	/* bcr                     R6  */
+#define SD_SEND_IF_COND		8	/* bcr  [11:0] See below   R7  */
+
+/* class 10 */
+#define SD_SWITCH		6	/* adtc [31:0] See below   R1  */
+
+/* Application commands */
+#define SD_APP_SET_BUS_WIDTH	6	/* ac   [1:0] bus width    R1  */
+#define SD_APP_SEND_NUM_WR_BLKS	22	/* adtc                    R1  */
+#define SD_APP_OP_COND		41	/* bcr  [31:0] OCR         R3  */
+#define SD_APP_SEND_SCR		51	/* adtc                    R1  */
 
 /* SCR definitions in different words */
 #define SD_HIGHSPEED_BUSY	0x00020000
@@ -100,19 +158,8 @@
 #define MMC_HS_TIMING		0x00000100
 #define MMC_HS_52MHZ		0x2
 
-#define OCR_BUSY		0x80000000
-#define OCR_HCS			0x40000000
-#define OCR_VOLTAGE_MASK	0x007FFF80
-#define OCR_ACCESS_MODE		0x60000000
-
-#define SECURE_ERASE		0x80000000
-
-#define MMC_STATUS_MASK		(~0x0206BF7F)
-#define MMC_STATUS_RDY_FOR_DATA (1 << 8)
-#define MMC_STATUS_CURR_STATE	(0xf << 9)
-#define MMC_STATUS_ERROR	(1 << 19)
-
-#define MMC_STATE_PRG		(7 << 9)
+#define OCR_BUSY	0x80000000
+#define OCR_HCS		0x40000000
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
@@ -147,98 +194,93 @@
 /*
  * EXT_CSD fields
  */
-#define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
-#define EXT_CSD_PARTITIONING_SUPPORT	160	/* RO */
-#define EXT_CSD_RPMB_MULT		168	/* RO */
-#define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
-#define EXT_CSD_BOOT_BUS_WIDTH		177
-#define EXT_CSD_PART_CONF		179	/* R/W */
-#define EXT_CSD_BUS_WIDTH		183	/* R/W */
-#define EXT_CSD_HS_TIMING		185	/* R/W */
-#define EXT_CSD_REV			192	/* RO */
-#define EXT_CSD_CARD_TYPE		196	/* RO */
-#define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
-#define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
-#define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
-#define EXT_CSD_BOOT_MULT		226	/* RO */
+
+#define EXT_CSD_BUS_WIDTH	183	/* R/W */
+#define EXT_CSD_HS_TIMING	185	/* R/W */
+#define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_REV		192	/* RO */
+#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
 
 /*
  * EXT_CSD field definitions
  */
 
-#define EXT_CSD_CMD_SET_NORMAL		(1 << 0)
-#define EXT_CSD_CMD_SET_SECURE		(1 << 1)
-#define EXT_CSD_CMD_SET_CPSECURE	(1 << 2)
+#define EXT_CSD_CMD_SET_NORMAL		(1<<0)
+#define EXT_CSD_CMD_SET_SECURE		(1<<1)
+#define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
 
-#define EXT_CSD_CARD_TYPE_26	(1 << 0)	/* Card can run at 26MHz */
-#define EXT_CSD_CARD_TYPE_52	(1 << 1)	/* Card can run at 52MHz */
+#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
 
-#define EXT_CSD_BOOT_ACK_ENABLE			(1 << 6)
-#define EXT_CSD_BOOT_PARTITION_ENABLE		(1 << 3)
-#define EXT_CSD_PARTITION_ACCESS_ENABLE		(1 << 0)
-#define EXT_CSD_PARTITION_ACCESS_DISABLE	(0 << 0)
-
-#define EXT_CSD_BOOT_ACK(x)		(x << 6)
-#define EXT_CSD_BOOT_PART_NUM(x)	(x << 3)
-#define EXT_CSD_PARTITION_ACCESS(x)	(x << 0)
-
-
 #define R1_ILLEGAL_COMMAND		(1 << 22)
 #define R1_APP_CMD			(1 << 5)
 
 #define MMC_RSP_PRESENT (1 << 0)
-#define MMC_RSP_136	(1 << 1)		/* 136 bit response */
-#define MMC_RSP_CRC	(1 << 2)		/* expect valid crc */
-#define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
-#define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */
+#define MMC_RSP_136     (1 << 1)                /* 136 bit response */
+#define MMC_RSP_CRC     (1 << 2)                /* expect valid crc */
+#define MMC_RSP_BUSY    (1 << 3)                /* card may send busy */
+#define MMC_RSP_OPCODE  (1 << 4)                /* response contains opcode */
 
-#define MMC_RSP_NONE	(0)
-#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_NONE    (0)
+#define MMC_RSP_R1      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 #define MMC_RSP_R1b	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE| \
 			MMC_RSP_BUSY)
-#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
-#define MMC_RSP_R3	(MMC_RSP_PRESENT)
-#define MMC_RSP_R4	(MMC_RSP_PRESENT)
-#define MMC_RSP_R5	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-
-#define MMCPART_NOAVAILABLE	(0xff)
-#define PART_ACCESS_MASK	(0x7)
-#define PART_SUPPORT		(0x1)
-
-/* Maximum block size for MMC */
-#define MMC_MAX_BLOCK_LEN	512
+#define MMC_RSP_R2      (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3      (MMC_RSP_PRESENT)
+#define MMC_RSP_R4      (MMC_RSP_PRESENT)
+#define MMC_RSP_R5      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 
-/* The number of MMC physical partitions.  These consist of:
- * boot partitions (2), general purpose partitions (4) in MMC v4.4.
- */
-#define MMC_NUM_BOOT_PARTITION	2
 
 struct mmc_cid {
-	unsigned long psn;
-	unsigned short oid;
-	unsigned char mid;
-	unsigned char prv;
-	unsigned char mdt;
-	char pnm[7];
+	unsigned int		manfid;
+	char			prod_name[8];
+	unsigned int		serial;
+	unsigned short		oemid;
+	unsigned short		year;
+	unsigned char		hwrev;
+	unsigned char		fwrev;
+	unsigned char		month;
+};
+
+struct mmc_csd {
+	unsigned char		mmca_vsn;
+	unsigned short		cmdclass;
+	unsigned short		tacc_clks;
+	unsigned int		tacc_ns;
+	unsigned int		r2w_factor;
+	unsigned int		max_dtr;
+	unsigned int		read_blkbits;
+	unsigned int		write_blkbits;
+	unsigned int		capacity;
+	unsigned int		read_partial:1,
+				read_misalign:1,
+				write_partial:1,
+				write_misalign:1;
+};
+
+struct mmc_ext_csd {
+	unsigned int		hs_max_dtr;
+	unsigned int		sectors;
 };
 
 struct mmc_cmd {
-	ushort cmdidx;
+	ushort opcode;
 	uint resp_type;
-	uint cmdarg;
-	uint response[4];
+	uint arg;
+	uint resp[4];
+	uint flags;
 };
 
 struct mmc_data {
 	union {
-		char *dest;
-		const char *src; /* src buffers don't get written to */
+		u8 *dest;
+		const u8 *src; /* src buffers don't get written to */
 	};
 	uint flags;
 	uint blocks;
@@ -251,7 +293,6 @@
 	void *priv;
 	uint voltages;
 	uint version;
-	uint has_init;
 	uint f_min;
 	uint f_max;
 	int high_capacity;
@@ -264,85 +305,28 @@
 	uint csd[4];
 	uint cid[4];
 	ushort rca;
-	char part_config;
-	char part_num;
 	uint tran_speed;
 	uint read_bl_len;
 	uint write_bl_len;
-	uint erase_grp_size;
-	u64 capacity;
-	u64 capacity_user;
-	u64 capacity_boot;
-	u64 capacity_rpmb;
-	u64 capacity_gp[4];
+	u32 capacity;
+	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
 	block_dev_desc_t block_dev;
 	int (*send_cmd)(struct mmc *mmc,
 			struct mmc_cmd *cmd, struct mmc_data *data);
 	void (*set_ios)(struct mmc *mmc);
 	int (*init)(struct mmc *mmc);
-	int (*getcd)(struct mmc *mmc);
-	int (*getwp)(struct mmc *mmc);
-	uint b_max;
-	char op_cond_pending;	/* 1 if we are waiting on an op_cond command */
-	char init_in_progress;	/* 1 if we have done mmc_start_init() */
-	char preinit;		/* start init as early as possible */
-	uint op_cond_response;	/* the response byte from the last op_cond */
 };
 
 int mmc_register(struct mmc *mmc);
 int mmc_initialize(bd_t *bis);
 int mmc_init(struct mmc *mmc);
-int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size);
-void mmc_set_clock(struct mmc *mmc, uint clock);
+int mmc_read(struct mmc *mmc, uint src, uchar *dst, int size);
 struct mmc *find_mmc_device(int dev_num);
-int mmc_set_dev(int dev_num);
 void print_mmc_devices(char separator);
-int get_mmc_num(void);
-int board_mmc_getcd(struct mmc *mmc);
-int mmc_switch_part(int dev_num, unsigned int part_num);
-int mmc_getcd(struct mmc *mmc);
-int mmc_getwp(struct mmc *mmc);
-void spl_mmc_load(void) __noreturn;
-/* Function to change the size of boot partition and rpmb partitions */
-int mmc_boot_partition_size_change(struct mmc *mmc, unsigned long bootsize,
-					unsigned long rpmbsize);
-/* Function to send commands to open/close the specified boot partition */
-int mmc_boot_part_access(struct mmc *mmc, u8 ack, u8 part_num, u8 access);
-
-/**
- * Start device initialization and return immediately; it does not block on
- * polling OCR (operation condition register) status.  Then you should call
- * mmc_init, which would block on polling OCR status and complete the device
- * initializatin.
- *
- * @param mmc	Pointer to a MMC device struct
- * @return 0 on success, IN_PROGRESS on waiting for OCR status, <0 on error.
- */
-int mmc_start_init(struct mmc *mmc);
-
-/**
- * Set preinit flag of mmc device.
- *
- * This will cause the device to be pre-inited during mmc_initialize(),
- * which may save boot time if the device is not accessed until later.
- * Some eMMC devices take 200-300ms to init, but unfortunately they
- * must be sent a series of commands to even get them to start preparing
- * for operation.
- *
- * @param mmc		Pointer to a MMC device struct
- * @param preinit	preinit flag value
- */
-void mmc_set_preinit(struct mmc *mmc, int preinit);
 
-#ifdef CONFIG_GENERIC_MMC
-#ifdef CONFIG_MMC_SPI
-#define mmc_host_is_spi(mmc)	((mmc)->host_caps & MMC_MODE_SPI)
-#else
-#define mmc_host_is_spi(mmc)	0
-#endif
-struct mmc *mmc_spi_init(uint bus, uint cs, uint speed, uint mode);
-#else
+#ifndef CONFIG_GENERIC_MMC
 int mmc_legacy_init(int verbose);
 #endif
-
 #endif /* _MMC_H_ */
+
+#endif /* !CONFIG_GENERIC_MMC */
diff -urN u-boot-2013.10/include/movi.h u-boot-2013.10_aston/include/movi.h
--- u-boot-2013.10/include/movi.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/include/movi.h	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,234 @@
+#ifndef __MOVI_H__
+#define __MOVI_H__
+
+#ifndef CONFIG_GENERIC_MMC
+
+#define MOVI_INIT_REQUIRED	0
+
+#if defined(CONFIG_S3C6400) || defined(CONFIG_S3C6410) || defined(CONFIG_S3C6430)
+#define	TCM_BASE		0x0C004000
+#define BL2_BASE		0x57E00000
+#elif defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416)
+#define	TCM_BASE		0x40004000
+#define BL2_BASE		0x33E00000
+#elif defined(CONFIG_S5P6440)
+#define S5P6440_SDMMC_BASE	0xd0021c4c
+#define S5P6440_SDHC_INFO	0xd0021c50
+#define S5P6440_BLK_SIZE	0xd0021c54
+#define BL2_BASE		0x27e00000
+#define S5P6440_DEVCPY_BASE	0xd0021c00
+#elif defined(CONFIG_S5PC100) || defined(CONFIG_S5PC110) || defined(CONFIG_S5P6442)
+#define S5PC100_BLK_SIZE        0xd0020230
+#define S5PC100_SDHC_INFO       0xd002011F
+#define BL2_BASE                0x27e00000
+#else
+# error TCM_BASE or BL2_BASE is not defined
+#endif
+
+/* TCM function for bl2 load */
+#if defined(CONFIG_S3C6400)
+#define CopyMovitoMem(a,b,c,d,e)	(((int(*)(uint, ushort, uint *, uint, int))(*((uint *)(TCM_BASE + 0x8))))(a,b,c,d,e))
+#elif defined(CONFIG_S3C6410) || defined(CONFIG_S3C6430)
+#define CopyMovitoMem(a,b,c,d,e)	(((int(*)(int, uint, ushort, uint *, int))(*((uint *)(TCM_BASE + 0x8))))(a,b,c,d,e))
+#elif defined(CONFIG_S5P6440)
+#define COPY_eMMC_to_MEM(a,b,c,d)	(((void(*)(uint, uint, uint *, int))(*((uint *)(S5P6440_DEVCPY_BASE + 0xc))))(a,b,c,d))
+#define CopyMovitoMem(a,b,c,d,e)	(((int(*)(int, uint, ushort, uint *, int))(*((uint *)(S5P6440_DEVCPY_BASE + 0x8))))(a,b,c,d,e))
+#elif defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416)
+#define CopyMovitoMem(a,b,c,d)		(((int(*)(uint, ushort, uint *, int))(*((uint *)(TCM_BASE + 0x8))))(a,b,c,d))
+#endif
+
+/* size information */
+#if defined(CONFIG_S3C6400)
+#define SS_SIZE			(4 * 1024)
+#define eFUSE_SIZE		(2 * 1024)	// 1.5k eFuse, 0.5k reserved
+#else
+#define SS_SIZE			(8 * 1024)
+#define eFUSE_SIZE		(1 * 1024)	// 0.5k eFuse, 0.5k reserved
+#endif
+
+/* movinand definitions */
+#define MOVI_BLKSIZE		512
+#define MOVI_UBOOTSIZE		496
+#define MOVI_RW_MAXBLKS		40960
+#if defined(CONFIG_S5P6440)
+#define MOVI_TOTAL_BLKCNT	*((volatile unsigned int*)(S5P6440_BLK_SIZE))
+#define MOVI_HIGH_CAPACITY	*((volatile unsigned int*)(S5P6440_SDHC_INFO))
+#elif defined(CONFIG_S5PC100) || defined(CONFIG_S5PC110) || defined(CONFIG_S5P6442)
+#define MOVI_TOTAL_BLKCNT       *((volatile unsigned int*)(S5PC100_BLK_SIZE))
+#define MOVI_HIGH_CAPACITY      *((volatile unsigned char*)(S5PC100_SDHC_INFO))
+#else
+#define MOVI_TOTAL_BLKCNT	*((volatile unsigned int*)(TCM_BASE - 0x4))
+#define MOVI_HIGH_CAPACITY	*((volatile unsigned int*)(TCM_BASE - 0x8))
+#endif
+
+/* partition information */
+#define PART_SIZE_BL		(512 * 1024)
+#define PART_SIZE_UBOOT		(496 * 1024)
+#define PART_SIZE_KERNEL	(4 * 1024 * 1024)
+#define PART_SIZE_ROOTFS	(8 * 1024 * 1024)
+
+#define MOVI_LAST_BLKPOS	(MOVI_TOTAL_BLKCNT - (eFUSE_SIZE / MOVI_BLKSIZE))
+#define MOVI_BL1_BLKCNT		(SS_SIZE / MOVI_BLKSIZE)
+#define MOVI_ENV_BLKCNT		(CFG_ENV_SIZE / MOVI_BLKSIZE)
+#define MOVI_BL2_BLKCNT		(PART_SIZE_BL / MOVI_BLKSIZE)
+#define MOVI_ZIMAGE_BLKCNT	(PART_SIZE_KERNEL / MOVI_BLKSIZE)
+#define MOVI_BL2_POS		(MOVI_LAST_BLKPOS - MOVI_BL1_BLKCNT - MOVI_BL2_BLKCNT - MOVI_ENV_BLKCNT)
+#define MOVI_ZIMAGE_POS		(MOVI_BL2_POS - MOVI_ZIMAGE_BLKCNT)
+#define MOVI_ROOTFS_BLKCNT	(PART_SIZE_ROOTFS / MOVI_BLKSIZE)
+
+/* eMMC partition information */
+#define EMMC_BL_SIZE		(512 * 1024)	/* UBOOT + ENV */
+#define EMMC_UBOOT_SIZE		(496 * 1024)
+#define EMMC_ENV_SIZE		(16 * 1024)
+#define EMMC_KERNEL_SIZE	((3 * 1024 * 1024) + (512 * 1024))
+#define EMMC_ROOTFS_SIZE	(12 * 1024 * 1024)
+
+#define EMMC_BL_BLKCNT		(EMMC_BL_SIZE / MOVI_BLKSIZE)
+#define EMMC_UBOOT_BLKCNT	(EMMC_UBOOT_SIZE / MOVI_BLKSIZE)
+#define EMMC_ENV_BLKCNT		(EMMC_ENV_SIZE / MOVI_BLKSIZE)
+#define EMMC_KERNEL_BLKCNT	(EMMC_KERNEL_SIZE / MOVI_BLKSIZE)
+#define EMMC_ROOTFS_BLKCNT	(EMMC_ROOTFS_SIZE / MOVI_BLKSIZE)
+
+struct movi_offset_t {
+	uint	last;
+	uint	bl1;
+	uint	env;
+	uint	bl2;
+	uint	kernel;
+	uint	rootfs;
+};
+
+/* external functions */
+extern void hsmmc_set_base(void);
+extern void hsmmc_set_gpio(void);
+extern void hsmmc_reset (void);
+extern int hsmmc_init (void);
+extern int movi_init(void);
+extern void movi_set_capacity(void);
+extern int movi_set_ofs(uint last);
+extern void movi_write (uint addr, uint start_blk, uint blknum);
+extern void movi_read (uint addr, uint start_blk, uint blknum);
+extern void movi_write_env(ulong addr);
+extern void movi_read_env(ulong addr);
+
+extern int emmc_write(uint addr, uint start_blk, uint blk_num);
+extern void emmc_read(uint addr, uint start_blk, uint blk_num);
+
+#if defined(CONFIG_S3C2450)
+extern ulong virt_to_phy_smdk2450(ulong addr);
+#elif defined(CONFIG_S3C6400)
+extern ulong virt_to_phy_smdk6400(ulong addr);
+#elif defined(CONFIG_S3C6410)
+extern ulong virt_to_phy_smdk6410(ulong addr);
+#elif defined(CONFIG_S3C6430)
+extern ulong virt_to_phy_smdk6430(ulong addr);
+#elif defined(CONFIG_S3C2416)
+extern ulong virt_to_phy_smdk2416(ulong addr);
+#elif defined(CONFIG_S5P6440)
+extern ulong virt_to_phy_smdk6440(ulong addr);
+#endif
+
+extern void test_hsmmc (uint width, uint test, uint start_blk, uint blknum);
+
+/* external variables */
+extern int movi_ch;
+extern int movi_emmc;
+extern uint movi_hc;
+extern struct movi_offset_t ofsinfo;
+
+#else	/* !CONFIG_GENERIC_MMC */
+
+#define MAGIC_NUMBER_MOVI	(0x24564236)
+
+#define MOVI_TOTAL_BLKCNT       *((volatile unsigned int*)(SDMMC_BLK_SIZE))
+
+#if defined(CONFIG_SECURE) || defined(CONFIG_FUSED)
+#define FWBL1_SIZE		(4* 1024)
+#endif
+
+#define SS_SIZE			(8 * 1024)
+
+#if defined(CONFIG_EVT1)
+#define eFUSE_SIZE		(1 * 512)	// 512 Byte eFuse, 512 Byte reserved
+#else
+#define eFUSE_SIZE		(1 * 1024)	// 1 kB eFuse, 1 KB reserved
+#endif /* CONFIG_EVT1 */
+
+
+#define MOVI_BLKSIZE		(1<<9) /* 512 bytes */
+
+/* partition information */
+#define PART_SIZE_BL		(512 * 1024)
+#define PART_SIZE_KERNEL	(4 * 1024 * 1024)
+#define PART_SIZE_ROOTFS	(26 * 1024 * 1024)
+
+#define MOVI_LAST_BLKPOS	(MOVI_TOTAL_BLKCNT - (eFUSE_SIZE / MOVI_BLKSIZE))
+
+/* Add block count at fused chip */
+#if defined(CONFIG_SECURE) || defined(CONFIG_FUSED)
+#define MOVI_FWBL1_BLKCNT	(FWBL1_SIZE / MOVI_BLKSIZE)	/* 4KB */
+#endif
+
+#define MOVI_BL1_BLKCNT		(SS_SIZE / MOVI_BLKSIZE)	/* 8KB */
+#define MOVI_ENV_BLKCNT		(CFG_ENV_SIZE / MOVI_BLKSIZE)	/* 16KB */
+#define MOVI_BL2_BLKCNT		(PART_SIZE_BL / MOVI_BLKSIZE)	/* 512KB */
+#define MOVI_ZIMAGE_BLKCNT	(PART_SIZE_KERNEL / MOVI_BLKSIZE)	/* 4MB */
+
+/* Change writing block position at fused chip */
+#if defined(CONFIG_EVT1)
+	#if defined(CONFIG_SECURE) || defined(CONFIG_FUSED)
+#define MOVI_BL2_POS		((eFUSE_SIZE / MOVI_BLKSIZE) + (FWBL1_SIZE / MOVI_BLKSIZE) + MOVI_BL1_BLKCNT + MOVI_ENV_BLKCNT)
+	#else
+#define MOVI_BL2_POS		((eFUSE_SIZE / MOVI_BLKSIZE) + MOVI_BL1_BLKCNT + MOVI_ENV_BLKCNT)
+	#endif
+#else
+#define MOVI_BL2_POS		(MOVI_LAST_BLKPOS - MOVI_BL1_BLKCNT - MOVI_BL2_BLKCNT - MOVI_ENV_BLKCNT)
+#endif
+
+// #define MOVI_ZIMAGE_POS		(MOVI_BL2_POS - MOVI_ZIMAGE_BLKCNT)
+#define MOVI_ROOTFS_BLKCNT	(PART_SIZE_ROOTFS / MOVI_BLKSIZE)
+
+/*
+ *
+ * start_blk: start block number for image
+ * used_blk: blocks occupied by image
+ * size: image size in bytes
+ * attribute: attributes of image
+ *            0x1: u-boot parted (BL1)
+ *            0x2: u-boot (BL2)
+ *            0x4: kernel
+ *            0x8: root file system
+ *            0x10: environment area
+ *            0x20: reserved
+ * description: description for image
+ * by scsuh
+ */
+typedef struct member {
+	uint start_blk;
+	uint used_blk;
+	uint size;
+	uint attribute; /* attribute of image */
+	char description[16];
+} member_t; /* 32 bytes */
+
+/*
+ * magic_number: 0x24564236
+ * start_blk: start block number for raw area
+ * total_blk: total block number of card
+ * next_raw_area: add next raw_area structure
+ * description: description for raw_area
+ * image: several image that is controlled by raw_area structure
+ * by scsuh
+ */
+typedef struct raw_area {
+	uint magic_number; /* to identify itself */
+	uint start_blk; /* compare with PT on coherency test */
+	uint total_blk;
+	uint next_raw_area; /* should be sector number */
+	char description[16];
+	member_t image[15];
+} raw_area_t; /* 512 bytes */
+
+#endif /* !CONFIG_GENERIC_MMC */
+
+#endif /*__MOVI_H__*/
diff -urN u-boot-2013.10/include/s3c_hsmmc.h u-boot-2013.10_aston/include/s3c_hsmmc.h
--- u-boot-2013.10/include/s3c_hsmmc.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/include/s3c_hsmmc.h	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,282 @@
+#ifndef S3C_HSMMC_H
+#define S3C_HSMMC_H
+/*
+ *  linux/drivers/mmc/host/sdhci.h - Secure Digital Host Controller Interface driver
+ *
+ *  Copyright (C) 2005-2008 Pierre Ossman, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+
+/*
+ * Controller registers
+ */
+
+#define SDHCI_DMA_ADDRESS	0x00
+
+#define SDHCI_BLOCK_SIZE	0x04
+#define  SDHCI_MAKE_BLKSZ(dma, blksz) (((dma & 0x7) << 12) | (blksz & 0xFFF))
+
+#define SDHCI_BLOCK_COUNT	0x06
+
+#define SDHCI_ARGUMENT		0x08
+
+#define SDHCI_TRANSFER_MODE	0x0C
+#define  SDHCI_TRNS_DMA		0x01
+#define  SDHCI_TRNS_BLK_CNT_EN	0x02
+#define  SDHCI_TRNS_ACMD12	0x04
+#define  SDHCI_TRNS_READ	0x10
+#define  SDHCI_TRNS_MULTI	0x20
+
+#define SDHCI_COMMAND		0x0E
+#define  SDHCI_CMD_RESP_MASK	0x03
+#define  SDHCI_CMD_CRC		0x08
+#define  SDHCI_CMD_INDEX	0x10
+#define  SDHCI_CMD_DATA		0x20
+
+#define  SDHCI_CMD_RESP_NONE	0x00
+#define  SDHCI_CMD_RESP_LONG	0x01
+#define  SDHCI_CMD_RESP_SHORT	0x02
+#define  SDHCI_CMD_RESP_SHORT_BUSY 0x03
+
+#define SDHCI_MAKE_CMD(c, f) (((c & 0xff) << 8) | (f & 0xff))
+
+#define SDHCI_RESPONSE		0x10
+
+#define SDHCI_BUFFER		0x20
+
+#define SDHCI_PRESENT_STATE	0x24
+#define  SDHCI_CMD_INHIBIT	0x00000001
+#define  SDHCI_DATA_INHIBIT	0x00000002
+#define  SDHCI_DOING_WRITE	0x00000100
+#define  SDHCI_DOING_READ	0x00000200
+#define  SDHCI_SPACE_AVAILABLE	0x00000400
+#define  SDHCI_DATA_AVAILABLE	0x00000800
+#define  SDHCI_CARD_PRESENT	0x00010000
+#define  SDHCI_WRITE_PROTECT	0x00080000
+#define  SDHCI_DATA_BIT(x)	(1 << ((x) + 20))
+
+#define SDHCI_HOST_CONTROL 	0x28
+#define  SDHCI_CTRL_LED		0x01
+#define  SDHCI_CTRL_4BITBUS	0x02
+#define  SDHCI_CTRL_HISPD	0x04
+#define  SDHCI_CTRL_DMA_MASK	0x18
+#define   SDHCI_CTRL_SDMA	0x00
+#define   SDHCI_CTRL_ADMA1	0x08
+#define   SDHCI_CTRL_ADMA32	0x10
+#define   SDHCI_CTRL_ADMA64	0x18
+
+#define SDHCI_POWER_CONTROL	0x29
+#define  SDHCI_POWER_ON		0x01
+#define  SDHCI_POWER_180	0x0A
+#define  SDHCI_POWER_300	0x0C
+#define  SDHCI_POWER_330	0x0E
+
+#define SDHCI_BLOCK_GAP_CONTROL	0x2A
+
+#define SDHCI_WAKE_UP_CONTROL	0x2B
+
+#define SDHCI_CLOCK_CONTROL	0x2C
+#define  SDHCI_DIVIDER_SHIFT	8
+#define  SDHCI_CLOCK_CARD_EN	0x0004
+#define  SDHCI_CLOCK_INT_STABLE	0x0002
+#define  SDHCI_CLOCK_INT_EN	0x0001
+
+#define SDHCI_TIMEOUT_CONTROL	0x2E
+
+#define SDHCI_SOFTWARE_RESET	0x2F
+#define  SDHCI_RESET_ALL	0x01
+#define  SDHCI_RESET_CMD	0x02
+#define  SDHCI_RESET_DATA	0x04
+
+#define SDHCI_INT_STATUS	0x30
+#define SDHCI_INT_ENABLE	0x34
+#define SDHCI_SIGNAL_ENABLE	0x38
+#define  SDHCI_INT_RESPONSE	0x00000001
+#define  SDHCI_INT_DATA_END	0x00000002
+#define  SDHCI_INT_DMA_END	0x00000008
+#define  SDHCI_INT_SPACE_AVAIL	0x00000010
+#define  SDHCI_INT_DATA_AVAIL	0x00000020
+#define  SDHCI_INT_CARD_INSERT	0x00000040
+#define  SDHCI_INT_CARD_REMOVE	0x00000080
+#define  SDHCI_INT_CARD_INT	0x00000100
+#define  SDHCI_INT_ERROR	0x00008000
+#define  SDHCI_INT_TIMEOUT	0x00010000
+#define  SDHCI_INT_CRC		0x00020000
+#define  SDHCI_INT_END_BIT	0x00040000
+#define  SDHCI_INT_INDEX	0x00080000
+#define  SDHCI_INT_DATA_TIMEOUT	0x00100000
+#define  SDHCI_INT_DATA_CRC	0x00200000
+#define  SDHCI_INT_DATA_END_BIT	0x00400000
+#define  SDHCI_INT_BUS_POWER	0x00800000
+#define  SDHCI_INT_ACMD12ERR	0x01000000
+#define  SDHCI_INT_ADMA_ERROR	0x02000000
+
+#define SDHCI_ERRINT_STATUS	0x32
+
+#define  SDHCI_INT_NORMAL_MASK	0x00007FFF
+#define  SDHCI_INT_ERROR_MASK	0xFFFF8000
+
+#define  SDHCI_INT_CMD_MASK	(SDHCI_INT_RESPONSE | SDHCI_INT_TIMEOUT | \
+		SDHCI_INT_CRC | SDHCI_INT_END_BIT | SDHCI_INT_INDEX)
+#define  SDHCI_INT_DATA_MASK	(SDHCI_INT_DATA_END | SDHCI_INT_DMA_END | \
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
+		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
+		SDHCI_INT_DATA_END_BIT)
+
+#define SDHCI_ACMD12_ERR	0x3C
+
+/* 3E-3F reserved */
+
+#define SDHCI_CAPABILITIES	0x40
+#define  SDHCI_TIMEOUT_CLK_MASK	0x0000003F
+#define  SDHCI_TIMEOUT_CLK_SHIFT 0
+#define  SDHCI_TIMEOUT_CLK_UNIT	0x00000080
+#define  SDHCI_CLOCK_BASE_MASK	0x00003F00
+#define  SDHCI_CLOCK_BASE_SHIFT	8
+#define  SDHCI_MAX_BLOCK_MASK	0x00030000
+#define  SDHCI_MAX_BLOCK_SHIFT  16
+#define  SDHCI_CAN_DO_ADMA2	0x00080000
+#define  SDHCI_CAN_DO_ADMA1	0x00100000
+#define  SDHCI_CAN_DO_HISPD	0x00200000
+#define  SDHCI_CAN_DO_DMA	0x00400000
+#define  SDHCI_CAN_VDD_330	0x01000000
+#define  SDHCI_CAN_VDD_300	0x02000000
+#define  SDHCI_CAN_VDD_180	0x04000000
+#define  SDHCI_CAN_64BIT	0x10000000
+
+/* 44-47 reserved for more caps */
+
+#define SDHCI_MAX_CURRENT	0x48
+
+/* 4C-4F reserved for more max current */
+
+#define SDHCI_SET_ACMD12_ERROR	0x50
+#define SDHCI_SET_INT_ERROR	0x52
+
+#define SDHCI_ADMA_ERROR	0x54
+
+/* 55-57 reserved */
+
+#define SDHCI_ADMA_ADDRESS	0x58
+
+/* 60-FB reserved */
+
+#define SDHCI_SLOT_INT_STATUS	0xFC
+
+#define SDHCI_HOST_VERSION	0xFE
+#define  SDHCI_VENDOR_VER_MASK	0xFF00
+#define  SDHCI_VENDOR_VER_SHIFT	8
+#define  SDHCI_SPEC_VER_MASK	0x00FF
+#define  SDHCI_SPEC_VER_SHIFT	0
+#define   SDHCI_SPEC_100	0
+#define   SDHCI_SPEC_200	1
+
+#define S3C_SDHCI_CONTROL2			(0x80)
+#define S3C_SDHCI_CONTROL3			(0x84)
+#define S3C64XX_SDHCI_CONTROL4			(0x8C)
+
+#define S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR	(1 << 31)
+#define S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK		(1 << 30)
+#define S3C_SDHCI_CTRL2_CDINVRXD3		(1 << 29)
+#define S3C_SDHCI_CTRL2_SLCARDOUT		(1 << 28)
+
+#define S3C_SDHCI_CTRL2_FLTCLKSEL_MASK		(0xf << 24)
+#define S3C_SDHCI_CTRL2_FLTCLKSEL_SHIFT		(24)
+#define S3C_SDHCI_CTRL2_FLTCLKSEL(_x)		((_x) << 24)
+
+#define S3C_SDHCI_CTRL2_LVLDAT_MASK		(0xff << 16)
+#define S3C_SDHCI_CTRL2_LVLDAT_SHIFT		(16)
+#define S3C_SDHCI_CTRL2_LVLDAT(_x)		((_x) << 16)
+
+#define S3C_SDHCI_CTRL2_ENFBCLKTX		(1 << 15)
+#define S3C_SDHCI_CTRL2_ENFBCLKRX		(1 << 14)
+#define S3C_SDHCI_CTRL2_SDCDSEL			(1 << 13)
+#define S3C_SDHCI_CTRL2_SDSIGPC			(1 << 12)
+#define S3C_SDHCI_CTRL2_ENBUSYCHKTXSTART	(1 << 11)
+
+#define S3C_SDHCI_CTRL2_DFCNT_MASK		(0x3 << 9)
+#define S3C_SDHCI_CTRL2_DFCNT_SHIFT		(9)
+#define S3C_SDHCI_CTRL2_DFCNT_NONE		(0x0 << 9)
+#define S3C_SDHCI_CTRL2_DFCNT_4SDCLK		(0x1 << 9)
+#define S3C_SDHCI_CTRL2_DFCNT_16SDCLK		(0x2 << 9)
+#define S3C_SDHCI_CTRL2_DFCNT_64SDCLK		(0x3 << 9)
+
+#define S3C_SDHCI_CTRL2_ENCLKOUTHOLD		(1 << 8)
+#define S3C_SDHCI_CTRL2_RWAITMODE		(1 << 7)
+#define S3C_SDHCI_CTRL2_DISBUFRD		(1 << 6)
+#define S3C_SDHCI_CTRL2_SELBASECLK_MASK		(0x3 << 4)
+#define S3C_SDHCI_CTRL2_SELBASECLK_SHIFT	(4)
+#define S3C_SDHCI_CTRL2_PWRSYNC			(1 << 3)
+#define S3C_SDHCI_CTRL2_ENCLKOUTMSKCON		(1 << 1)
+#define S3C_SDHCI_CTRL2_HWINITFIN		(1 << 0)
+
+#define S3C_SDHCI_CTRL3_FCSEL3			(1 << 31)
+#define S3C_SDHCI_CTRL3_FCSEL2			(1 << 23)
+#define S3C_SDHCI_CTRL3_FCSEL1			(1 << 15)
+#define S3C_SDHCI_CTRL3_FCSEL0			(1 << 7)
+
+#define S3C_SDHCI_CTRL3_FIA3_MASK		(0x7f << 24)
+#define S3C_SDHCI_CTRL3_FIA3_SHIFT		(24)
+#define S3C_SDHCI_CTRL3_FIA3(_x)		((_x) << 24)
+
+#define S3C_SDHCI_CTRL3_FIA2_MASK		(0x7f << 16)
+#define S3C_SDHCI_CTRL3_FIA2_SHIFT		(16)
+#define S3C_SDHCI_CTRL3_FIA2(_x)		((_x) << 16)
+
+#define S3C_SDHCI_CTRL3_FIA1_MASK		(0x7f << 8)
+#define S3C_SDHCI_CTRL3_FIA1_SHIFT		(8)
+#define S3C_SDHCI_CTRL3_FIA1(_x)		((_x) << 8)
+
+#define S3C_SDHCI_CTRL3_FIA0_MASK		(0x7f << 0)
+#define S3C_SDHCI_CTRL3_FIA0_SHIFT		(0)
+#define S3C_SDHCI_CTRL3_FIA0(_x)		((_x) << 0)
+
+#define S3C64XX_SDHCI_CONTROL4_DRIVE_MASK	(0x3 << 16)
+#define S3C64XX_SDHCI_CONTROL4_DRIVE_SHIFT	(16)
+#define S3C64XX_SDHCI_CONTROL4_DRIVE_2mA	(0x0 << 16)
+#define S3C64XX_SDHCI_CONTROL4_DRIVE_4mA	(0x1 << 16)
+#define S3C64XX_SDHCI_CONTROL4_DRIVE_7mA	(0x2 << 16)
+#define S3C64XX_SDHCI_CONTROL4_DRIVE_9mA	(0x3 << 16)
+
+#define S3C64XX_SDHCI_CONTROL4_BUSY		(1)
+
+#ifndef __iomem
+#define __iomem
+#endif
+
+struct sdhci_host {
+	/* Data set by hardware interface driver */
+	const char		*hw_name;	/* Hardware bus name */
+
+	int			irq;		/* Device IRQ */
+	void __iomem *		ioaddr;		/* Mapped address */
+
+	/* Internal data */
+	struct mmc		*mmc;		/* MMC structure */
+	u64			dma_mask;	/* custom DMA mask */
+
+	int			flags;		/* Host attributes */
+#define SDHCI_USE_DMA		(1<<0)		/* Host is DMA capable */
+#define SDHCI_USE_ADMA		(1<<1)		/* Host is ADMA capable */
+#define SDHCI_REQ_USE_DMA	(1<<2)		/* Use DMA for this req. */
+#define SDHCI_DEVICE_DEAD	(1<<3)		/* Device unresponsive */
+#define SDHCI_DEVICE_ALIVE	(1<<4)		/* used on ext card detect */
+
+	unsigned int		version;	/* SDHCI spec. version */
+
+	unsigned int		max_clk;	/* Max possible freq (MHz) */
+	unsigned int		timeout_clk;	/* Timeout freq (KHz) */
+
+	unsigned int		clock;		/* Current clock (MHz) */
+	unsigned short		power;		/* Current voltage */
+
+	dma_addr_t		adma_addr;	/* Mapped ADMA descr. table */
+};
+
+#endif
+
diff -urN u-boot-2013.10/include/s5pc110.h u-boot-2013.10_aston/include/s5pc110.h
--- u-boot-2013.10/include/s5pc110.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/include/s5pc110.h	2016-01-04 21:40:00.000000000 -0800
@@ -0,0 +1,1773 @@
+/*
+ * (C) Copyright 2008
+ * Jongpill Lee, Samsung Erectronics, boyko.lee@samsung.com.
+ *      - only support for S5PC110
+ *  $Id: s5pc100.h,v 1.4 2008/11/25 06:15:10 boyko Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/************************************************
+ * NAME	    : s5pc110.h
+ *
+ ************************************************/
+
+#ifndef __S5PC110_H__
+#define __S5PC110_H__
+
+#ifndef CONFIG_S5PC110
+#define CONFIG_S5PC110			1
+#endif
+
+#define S5PC11X_UART_CHANNELS		3
+#define S5PC11X_SPI_CHANNELS		2
+
+//#include <asm/hardware.h>
+
+#define __REG(x)	(*(vu_long *)(x))
+#define __REGl(x)	(*(vu_long *)(x))
+#define __REGw(x)	(*(vu_short *)(x))
+#define __REGb(x)	(*(vu_char *)(x))
+#define __REG2(x,y)	(*(vu_long *)((x) + (y)))
+
+
+
+
+#define BIT0 				0x00000001
+#define BIT1 				0x00000002
+#define BIT2 				0x00000004
+#define BIT3 				0x00000008
+#define BIT4 				0x00000010
+#define BIT5 				0x00000020
+#define BIT6				0x00000040
+#define BIT7				0x00000080
+#define BIT8				0x00000100
+#define BIT9				0x00000200
+#define BIT10				0x00000400
+#define BIT11				0x00000800
+#define BIT12				0x00001000
+#define BIT13				0x00002000
+#define BIT14				0x00004000
+#define BIT15				0x00008000
+#define BIT16				0x00010000
+#define BIT17				0x00020000
+#define BIT18				0x00040000
+#define BIT19				0x00080000
+#define BIT20				0x00100000
+#define BIT21				0x00200000
+#define BIT22				0x00400000
+#define BIT23				0x00800000
+#define BIT24				0x01000000
+#define BIT25				0x02000000
+#define BIT26				0x04000000
+#define BIT27				0x08000000
+#define BIT28				0x10000000
+#define BIT29				0x20000000
+#define BIT30				0x40000000
+#define BIT31				0x80000000
+
+/* S5PC110 device base addresses */
+#define ELFIN_DMA_BASE			0xE0900000
+#define ELFIN_LCD_BASE			0xF8000000
+#define ELFIN_USB_HOST_BASE		0xEC200000
+#define ELFIN_I2C_BASE			0xE1800000
+#define ELFIN_I2S_BASE			0xE2100000
+#define ELFIN_ADC_BASE			0xE1700000
+#define ELFIN_SPI_BASE			0xE1300000
+
+
+#define ELFIN_HSMMC_0_BASE		0xEB000000
+#define ELFIN_HSMMC_1_BASE		0xEB100000
+#define ELFIN_HSMMC_2_BASE		0xEB200000
+#define ELFIN_HSMMC_3_BASE		0xEB300000
+
+#define ELFIN_CLOCK_POWER_BASE		0xE0100000
+
+#define ELFIN_TZPC0_BASE		0xF1500000
+#define ELFIN_TZPC1_BASE		0xFAD00000
+#define ELFIN_TZPC2_BASE		0xE0600000
+#define ELFIN_TZPC3_BASE		0xE1C00000
+
+#define IO_RET_REL			((1 << 31) | (1 << 29) | (1 << 28)) 
+
+/* Clock & Power Controller for s5pc110*/
+#define APLL_LOCK_OFFSET		0x00
+#define MPLL_LOCK_OFFSET		0x08
+#define EPLL_LOCK_OFFSET		0x10
+#define VPLL_LOCK_OFFSET		0x20
+#define APLL_CON0_OFFSET		0x100
+#define APLL_CON1_OFFSET		0x104
+#define MPLL_CON_OFFSET			0x108
+#define EPLL_CON_OFFSET			0x110
+#define VPLL_CON_OFFSET			0x120
+
+#define CLK_SRC0_OFFSET			0x200
+#define CLK_SRC1_OFFSET			0x204
+#define CLK_SRC2_OFFSET			0x208
+#define CLK_SRC3_OFFSET			0x20c
+#define CLK_SRC4_OFFSET			0x210
+#define CLK_SRC5_OFFSET			0x214
+#define CLK_SRC6_OFFSET			0x218
+#define CLK_SRC_MASK0_OFFSET		0x280
+#define CLK_SRC_MASK1_OFFSET		0x284
+
+#define CLK_DIV0_OFFSET			0x300
+#define CLK_DIV1_OFFSET			0x304
+#define CLK_DIV2_OFFSET			0x308
+#define CLK_DIV3_OFFSET			0x30c
+#define CLK_DIV4_OFFSET			0x310
+#define CLK_DIV5_OFFSET			0x314
+#define CLK_DIV6_OFFSET			0x318
+#define CLK_DIV7_OFFSET			0x31c
+
+#define CLK_GATE_IP0_OFFSET		0x460
+#define CLK_GATE_IP1_OFFSET		0x464
+#define CLK_GATE_IP2_OFFSET		0x468
+#define CLK_GATE_IP3_OFFSET		0x46c
+#define CLK_GATE_IP4_OFFSET		0x470
+#define CLK_GATE_BLOCK_OFFSET		0x480
+
+#define CLK_OUT_OFFSET			0x500
+#define CLK_DIV_STAT0_OFFSET		0x1000
+#define CLK_DIV_STAT1_OFFSET		0x1004
+#define CLK_MUX_STAT0_OFFSET		0x1100
+#define CLK_MUX_STAT1_OFFSET		0x1104
+#define SW_RST_OFFSET			0x2000
+
+#define ONEDRAM_CFG_OFFSET		0x6208
+
+#define OSC_CON_OFFSET			0x8000
+#define RST_STAT_OFFSET			0xa000
+#define PWR_CFG_OFFSET			0xc000
+#define	EINT_WAKEUP_MASK_OFFSET		0xc004
+#define WAKEUP_MASK_OFFSET		0xc008
+#define NORMAL_CFG_OFFSET		0xc010
+#define IDLE_CFG_OFFSET			0xc020
+#define STOP_CFG_OFFSET			0xc030
+#define STOP_MEM_CFG_OFFSET		0xc034
+#define SLEEP_CFG_OFFSET		0xc040
+#define OSC_FREQ_OFFSET			0xc100
+#define OSC_STABLE_OFFSET		0xc104
+#define PWR_STABLE_OFFSET		0xc108
+#define MTC_STABLE_OFFSET		0xc110
+#define CLAMP_STABLE_OFFSET		0xc114
+#define WAKEUP_STAT_OFFSET		0xc200
+#define BLK_PWR_STAT_OFFSET		0xc204
+#define BODY_BIAS_CON_OFFSET		0xc300
+#define ION_SKEW_CON_OFFSET		0xc310
+#define ION_SKEW_MON_OFFSET		0xc314
+#define IOFF_SKEW_CON_OFFSET		0xc320
+#define IOFF_SKEW_MON_OFFSET		0xc324
+#define OTHERS_OFFSET			0xe000
+#define OM_STAT_OFFSET			0xe100
+#define MIE_CONTROL_OFFSET		0xe800
+#define HDMI_CONTROL_OFFSET		0xe804
+#define USB_PHY_CONTROL_OFFSET		0xe80c
+#define DAC_CONTROL_OFFSET		0xe810
+#define MIPI_DPHY_CONTROL_OFFSET	0xe814
+#define ADC_CONTROL_OFFSET		0xe818
+#define PS_HOLD_CONTROL_OFFSET		0xe81c
+
+#define INFORM0_OFFSET			0xf000
+#define INFORM1_OFFSET			0xf004
+#define INFORM2_OFFSET			0xf008
+#define INFORM3_OFFSET			0xf00c
+#define INFORM4_OFFSET			0xf010
+#define INFORM5_OFFSET			0xf014
+#define INFORM6_OFFSET			0xf018
+#define INFORM7_OFFSET			0xf01c
+
+#define INF_REG0_OFFSET			0x00
+#define INF_REG1_OFFSET			0x04
+#define INF_REG2_OFFSET			0x08
+#define INF_REG3_OFFSET			0x0c
+#define INF_REG4_OFFSET			0x10
+#define INF_REG5_OFFSET			0x14
+#define INF_REG6_OFFSET			0x18
+#define INF_REG7_OFFSET			0x1c
+
+#define APLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+APLL_LOCK_OFFSET)
+#define MPLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+MPLL_LOCK_OFFSET
+#define EPLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+EPLL_LOCK_OFFSET)
+//#define HPLL_LOCK_REG			__REG(ELFIN_CLOCK_POWER_BASE+HPLL_LOCK_OFFSET)
+#define APLL_CON0_REG			__REG(ELFIN_CLOCK_POWER_BASE+APLL_CON0_OFFSET)
+#define APLL_CON1_REG			__REG(ELFIN_CLOCK_POWER_BASE+APLL_CON1_OFFSET)
+#define MPLL_CON_REG			__REG(ELFIN_CLOCK_POWER_BASE+MPLL_CON_OFFSET)
+#define EPLL_CON_REG			__REG(ELFIN_CLOCK_POWER_BASE+EPLL_CON_OFFSET)
+//#define HPLL_CON_REG			__REG(ELFIN_CLOCK_POWER_BASE+HPLL_CON_OFFSET)
+#define CLK_SRC0_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC0_OFFSET)
+#define CLK_SRC1_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC1_OFFSET)
+#define CLK_SRC2_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC2_OFFSET)
+#define CLK_SRC3_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC3_OFFSET)
+#define CLK_SRC4_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_SRC4_OFFSET)
+#define CLK_DIV0_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV0_OFFSET)
+#define CLK_DIV1_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV1_OFFSET)
+#define CLK_DIV2_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV2_OFFSET)
+#define CLK_DIV3_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV3_OFFSET)
+#define CLK_DIV4_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV4_OFFSET)
+#define CLK_DIV5_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV5_OFFSET)
+#define CLK_DIV6_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV6_OFFSET)
+#define CLK_DIV7_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV7_OFFSET)
+
+#define CLK_OUT_REG			__REG(ELFIN_CLOCK_POWER_BASE+CLK_OUT_OFFSET)
+
+#define CLK_GATE_IP0_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP0_OFFSET)
+#define CLK_GATE_IP1_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP1_OFFSET)
+#define CLK_GATE_IP2_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP2_OFFSET)
+#define CLK_GATE_IP3_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP3_OFFSET)
+#define CLK_GATE_IP4_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_IP4_OFFSET)
+#define CLK_GATE_BLOCK_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_GATE_BLOCK_OFFSET)
+
+#define CLK_DIV_STAT0_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV_STAT0_OFFSET)
+#define CLK_DIV_STAT1_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_DIV_STAT1_OFFSET)
+#define CLK_MUX_STAT0_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_MUX_STAT0_OFFSET)
+#define CLK_MUX_STAT1_REG		__REG(ELFIN_CLOCK_POWER_BASE+CLK_MUX_STAT1_OFFSET)
+
+/*
+#define AHB_CON0_REG			__REG(ELFIN_CLOCK_POWER_BASE+AHB_CON0_OFFSET)
+#define AHB_CON1_REG			__REG(ELFIN_CLOCK_POWER_BASE+AHB_CON1_OFFSET)
+#define AHB_CON2_REG			__REG(ELFIN_CLOCK_POWER_BASE+AHB_CON2_OFFSET)
+#define SELECT_DMA_REG			__REG(ELFIN_CLOCK_POWER_BASE+SELECT_DMA_OFFSET)
+#define SW_RST_REG			__REG(ELFIN_CLOCK_POWER_BASE+SW_RST_OFFSET)
+#define SYS_ID_REG			__REG(ELFIN_CLOCK_POWER_BASE+SYS_ID_OFFSET)
+#define MEM_SYS_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+MEM_SYS_CFG_OFFSET)
+#define QOS_OVERRIDE0_REG		__REG(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE0_OFFSET)
+#define QOS_OVERRIDE1_REG		__REG(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE1_OFFSET)
+#define MEM_CFG_STAT_REG		__REG(ELFIN_CLOCK_POWER_BASE+MEM_CFG_STAT_OFFSET)
+#define PWR_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+PWR_CFG_OFFSET)
+#define EINT_MASK_REG			__REG(ELFIN_CLOCK_POWER_BASE+EINT_MASK_OFFSET)
+#define NOR_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+NOR_CFG_OFFSET)
+#define STOP_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+STOP_CFG_OFFSET)
+#define SLEEP_CFG_REG			__REG(ELFIN_CLOCK_POWER_BASE+SLEEP_CFG_OFFSET)
+#define OSC_FREQ_REG			__REG(ELFIN_CLOCK_POWER_BASE+OSC_FREQ_OFFSET)
+#define OSC_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+OSC_CNT_VAL_OFFSET)
+#define PWR_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+PWR_CNT_VAL_OFFSET)
+#define FPC_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+FPC_CNT_VAL_OFFSET)
+#define MTC_CNT_VAL_REG			__REG(ELFIN_CLOCK_POWER_BASE+MTC_CNT_VAL_OFFSET)
+#define OTHERS_REG			__REG(ELFIN_CLOCK_POWER_BASE+OTHERS_OFFSET)
+#define RST_STAT_REG			__REG(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)
+#define WAKEUP_STAT_REG			__REG(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
+#define BLK_PWR_STAT_REG		__REG(ELFIN_CLOCK_POWER_BASE+BLK_PWR_STAT_OFFSET)
+*/
+#define PRO_ID_BASE			0xE0000000
+#define PRO_ID_OFFSET			0x00
+#define OMR_OFFSET			0x04
+
+#define INF_REG_BASE			0xE010F000
+
+#define INF_REG0_REG			__REG(INF_REG_BASE+INF_REG0_OFFSET)
+#define INF_REG1_REG			__REG(INF_REG_BASE+INF_REG1_OFFSET)
+#define INF_REG2_REG			__REG(INF_REG_BASE+INF_REG2_OFFSET)
+#define INF_REG3_REG			__REG(INF_REG_BASE+INF_REG3_OFFSET)
+#define INF_REG4_REG			__REG(INF_REG_BASE+INF_REG4_OFFSET)
+#define INF_REG5_REG			__REG(INF_REG_BASE+INF_REG5_OFFSET)
+#define INF_REG6_REG			__REG(INF_REG_BASE+INF_REG6_OFFSET)
+#define INF_REG7_REG			__REG(INF_REG_BASE+INF_REG7_OFFSET)
+/*
+#define APLL_LOCK			(ELFIN_CLOCK_POWER_BASE+APLL_LOCK_OFFSET)
+#define MPLL_LOCK			(ELFIN_CLOCK_POWER_BASE+MPLL_LOCK_OFFSET)
+#define EPLL_LOCK			(ELFIN_CLOCK_POWER_BASE+EPLL_LOCK_OFFSET)
+#define APLL_CON			(ELFIN_CLOCK_POWER_BASE+APLL_CON_OFFSET)
+#define MPLL_CON			(ELFIN_CLOCK_POWER_BASE+MPLL_CON_OFFSET)
+#define EPLL_CON0			(ELFIN_CLOCK_POWER_BASE+EPLL_CON0_OFFSET)
+#define EPLL_CON1			(ELFIN_CLOCK_POWER_BASE+EPLL_CON1_OFFSET)
+#define CLK_SRC				(ELFIN_CLOCK_POWER_BASE+CLK_SRC_OFFSET)
+#define CLK_DIV0			(ELFIN_CLOCK_POWER_BASE+CLK_DIV0_OFFSET)
+#define CLK_DIV1			(ELFIN_CLOCK_POWER_BASE+CLK_DIV1_OFFSET)
+#define CLK_DIV2			(ELFIN_CLOCK_POWER_BASE+CLK_DIV2_OFFSET)
+#define CLK_OUT				(ELFIN_CLOCK_POWER_BASE+CLK_OUT_OFFSET)
+#define HCLK_GATE			(ELFIN_CLOCK_POWER_BASE+HCLK_GATE_OFFSET)
+#define PCLK_GATE			(ELFIN_CLOCK_POWER_BASE+PCLK_GATE_OFFSET)
+#define SCLK_GATE			(ELFIN_CLOCK_POWER_BASE+SCLK_GATE_OFFSET)
+#define AHB_CON0			(ELFIN_CLOCK_POWER_BASE+AHB_CON0_OFFSET)
+#define AHB_CON1			(ELFIN_CLOCK_POWER_BASE+AHB_CON1_OFFSET)
+#define AHB_CON2			(ELFIN_CLOCK_POWER_BASE+AHB_CON2_OFFSET)
+#define SELECT_DMA			(ELFIN_CLOCK_POWER_BASE+SELECT_DMA_OFFSET)
+#define SW_RST				(ELFIN_CLOCK_POWER_BASE+SW_RST_OFFSET)
+#define SYS_ID				(ELFIN_CLOCK_POWER_BASE+SYS_ID_OFFSET)
+#define MEM_SYS_CFG			(ELFIN_CLOCK_POWER_BASE+MEM_SYS_CFG_OFFSET)
+#define QOS_OVERRIDE0			(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE0_OFFSET)
+#define QOS_OVERRIDE1			(ELFIN_CLOCK_POWER_BASE+QOS_OVERRIDE1_OFFSET)
+#define MEM_CFG_STAT			(ELFIN_CLOCK_POWER_BASE+MEM_CFG_STAT_OFFSET)
+#define PWR_CFG				(ELFIN_CLOCK_POWER_BASE+PWR_CFG_OFFSET)
+#define EINT_MASK			(ELFIN_CLOCK_POWER_BASE+EINT_MASK_OFFSET)
+#define NOR_CFG				(ELFIN_CLOCK_POWER_BASE+NOR_CFG_OFFSET)
+#define STOP_CFG			(ELFIN_CLOCK_POWER_BASE+STOP_CFG_OFFSET)
+#define SLEEP_CFG			(ELFIN_CLOCK_POWER_BASE+SLEEP_CFG_OFFSET)
+#define OSC_FREQ			(ELFIN_CLOCK_POWER_BASE+OSC_FREQ_OFFSET)
+#define OSC_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+OSC_CNT_VAL_OFFSET)
+#define PWR_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+PWR_CNT_VAL_OFFSET)
+#define FPC_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+FPC_CNT_VAL_OFFSET)
+#define MTC_CNT_VAL			(ELFIN_CLOCK_POWER_BASE+MTC_CNT_VAL_OFFSET)
+#define OTHERS				(ELFIN_CLOCK_POWER_BASE+OTHERS_OFFSET)
+#define RST_STAT			(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)
+#define WAKEUP_STAT			(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
+#define BLK_PWR_STAT			(ELFIN_CLOCK_POWER_BASE+BLK_PWR_STAT_OFFSET)
+#define USB_PHY_CONTROL			(ELFIN_CLOCK_POWER_BASE+USB_PHY_CONTROL_OFFSET)
+#define INF_REG0			(ELFIN_CLOCK_POWER_BASE+INF_REG0_OFFSET)
+#define INF_REG1			(ELFIN_CLOCK_POWER_BASE+INF_REG1_OFFSET)
+#define INF_REG2			(ELFIN_CLOCK_POWER_BASE+INF_REG2_OFFSET)
+#define INF_REG3			(ELFIN_CLOCK_POWER_BASE+INF_REG3_OFFSET)
+#define INF_REG4			(ELFIN_CLOCK_POWER_BASE+INF_REG4_OFFSET)
+#define INF_REG5			(ELFIN_CLOCK_POWER_BASE+INF_REG5_OFFSET)
+#define INF_REG6			(ELFIN_CLOCK_POWER_BASE+INF_REG6_OFFSET)
+#define INF_REG7			(ELFIN_CLOCK_POWER_BASE+INF_REG7_OFFSET)
+*/
+/* Access Controller (TZPC) */
+#define TZPC_DECPROT0SET_OFFSET		0x804
+#define TZPC_DECPROT1SET_OFFSET		0x810
+#define TZPC_DECPROT2SET_OFFSET		0x81C
+#define TZPC_DECPROT3SET_OFFSET		0x828
+
+/*
+ * GPIO
+ */
+#define ELFIN_GPIO_BASE			0xE0200000
+
+
+#define GPA0CON_OFFSET 			0x000 
+#define GPA0DAT_OFFSET	 		0x004 
+#define GPA0PUD_OFFSET 			0x008 
+#define GPA0DRV_SR_OFFSET	 	0x00C 
+#define GPA0CONPDN_OFFSET 		0x010 
+#define GPA0PUDPDN_OFFSET 		0x014
+
+#define GPA1CON_OFFSET 			0x020
+#define GPA1DAT_OFFSET 			0x024 
+#define GPA1PUD_OFFSET 			0x028 
+#define GPA1DRV_SR_OFFSET 		0x02C 
+#define GPA1CONPDN_OFFSET 		0x030 
+#define GPA1PUDPDN_OFFSET 		0x034 
+
+#define GPBCON_OFFSET 			0x040 
+#define GPBDAT_OFFSET 			0x044 
+#define GPBPUD_OFFSET 			0x048 
+#define GPBDRV_SR_OFFSET 		0x04C 
+#define GPBCONPDN_OFFSET 		0x050 
+#define GPBPUDPDN_OFFSET 		0x054 
+
+#define GPC0CON_OFFSET 			0x060 
+#define GPC0DAT_OFFSET 			0x064 
+#define GPC0PUD_OFFSET 			0x068 
+#define GPC0DRV_SR_OFFSET 		0x06C 
+#define GPC0CONPDN_OFFSET 		0x070 
+#define GPC0PUDPDN_OFFSET 		0x074 
+
+#define GPC1CON_OFFSET 			0x080 
+#define GPC1DAT_OFFSET 			0x084 
+#define GPC1PUD_OFFSET 			0x088 
+#define GPC1DRV_SR_OFFSET 		0x08C 
+#define GPC1CONPDN_OFFSET 		0x090 
+#define GPC1PUDPDN_OFFSET 		0x094 
+
+#define GPD0CON_OFFSET 			0x0A0 
+#define GPD0DAT_OFFSET 			0x0A4 
+#define GPD0PUD_OFFSET 			0x0A8 
+#define GPD0DRV_SR_OFFSET 		0x0AC 
+#define GPD0CONPDN_OFFSET 		0x0B0 
+#define GPD0PUDPDN_OFFSET 		0x0B4 
+
+#define GPD1CON_OFFSET 			0x0C0 
+#define GPD1DAT_OFFSET 			0x0C4 
+#define GPD1PUD_OFFSET 			0x0C8 
+#define GPD1DRV_SR_OFFSET 		0x0CC 
+#define GPD1CONPDN_OFFSET 		0x0D0 
+#define GPD1PUDPDN_OFFSET 		0x0D4 
+
+#define GPE0CON_OFFSET 			0x0E0 
+#define GPE0DAT_OFFSET 			0x0E4 
+#define GPE0PUD_OFFSET 			0x0E8 
+#define GPE0DRV_SR_OFFSET 		0x0EC 
+#define GPE0CONPDN_OFFSET 		0x0F0 
+#define GPE0PUDPDN_OFFSET 		0x0F4
+
+#define GPE1CON_OFFSET 			0x100 
+#define GPE1DAT_OFFSET 			0x104 
+#define GPE1PUD_OFFSET 			0x108 
+#define GPE1DRV_SR_OFFSET 		0x10C 
+#define GPE1CONPDN_OFFSET 		0x110 
+#define GPE1PUDPDN_OFFSET 		0x114 
+
+#define GPF0CON_OFFSET 			0x120 
+#define GPF0DAT_OFFSET 			0x124 
+#define GPF0PUD_OFFSET 			0x128 
+#define GPF0DRV_SR_OFFSET 		0x12C 
+#define GPF0CONPDN_OFFSET 		0x130 
+#define GPF0PUDPDN_OFFSET 		0x134 
+
+#define GPF1CON_OFFSET 			0x140 
+#define GPF1DAT_OFFSET 			0x144 
+#define GPF1PUD_OFFSET 			0x148 
+#define GPF1DRV_SR_OFFSET 		0x14C 
+#define GPF1CONPDN_OFFSET 		0x150 
+#define GPF1PUDPDN_OFFSET 		0x154 
+
+#define GPF2CON_OFFSET 			0x160 
+#define GPF2DAT_OFFSET 			0x164 
+#define GPF2PUD_OFFSET 			0x168 
+#define GPF2DRV_SR_OFFSET 		0x16C 
+#define GPF2CONPDN_OFFSET 		0x170 
+#define GPF2PUDPDN_OFFSET 		0x174 
+
+#define GPF3CON_OFFSET 			0x180 
+#define GPF3DAT_OFFSET 			0x184 
+#define GPF3PUD_OFFSET 			0x188 
+#define GPF3DRV_SR_OFFSET 		0x18C 
+#define GPF3CONPDN_OFFSET 		0x190 
+#define GPF3PUDPDN_OFFSET 		0x194 
+
+#define GPG0CON_OFFSET 			0x1A0 
+#define GPG0DAT_OFFSET 			0x1A4 
+#define GPG0PUD_OFFSET 			0x1A8 
+#define GPG0DRV_SR_OFFSET 		0x1AC 
+#define GPG0CONPDN_OFFSET 		0x1B0 
+#define GPG0PUDPDN_OFFSET 		0x1B4 
+
+#define GPG1CON_OFFSET 			0x1C0 
+#define GPG1DAT_OFFSET 			0x1C4 
+#define GPG1PUD_OFFSET 			0x1C8 
+#define GPG1DRV_SR_OFFSET 		0x1CC 
+#define GPG1CONPDN_OFFSET 		0x1D0 
+#define GPG1PUDPDN_OFFSET 		0x1D4 
+
+#define GPG2CON_OFFSET 			0x1E0 
+#define GPG2DAT_OFFSET 			0x1E4 
+#define GPG2PUD_OFFSET 			0x1E8 
+#define GPG2DRV_SR_OFFSET 		0x1EC 
+#define GPG2CONPDN_OFFSET 		0x1F0 
+#define GPG2PUDPDN_OFFSET 		0x1F4 
+
+#define GPG3CON_OFFSET 			0x200 
+#define GPG3DAT_OFFSET 			0x204 
+#define GPG3PUD_OFFSET 			0x208 
+#define GPG3DRV_SR_OFFSET 		0x20C 
+#define GPG3CONPDN_OFFSET 		0x210 
+#define GPG3PUDPDN_OFFSET 		0x214
+
+#define MP1_0DRV_SR_OFFSET 		0x3CC
+#define MP1_1DRV_SR_OFFSET 		0x3EC
+#define MP1_2DRV_SR_OFFSET 		0x40C
+#define MP1_3DRV_SR_OFFSET 		0x42C
+#define MP1_4DRV_SR_OFFSET 		0x44C
+#define MP1_5DRV_SR_OFFSET 		0x46C
+#define MP1_6DRV_SR_OFFSET 		0x48C
+#define MP1_7DRV_SR_OFFSET 		0x4AC
+#define MP1_8DRV_SR_OFFSET 		0x4CC
+
+#define MP2_0DRV_SR_OFFSET 		0x4EC
+#define MP2_1DRV_SR_OFFSET 		0x50C
+#define MP2_2DRV_SR_OFFSET 		0x52C
+#define MP2_3DRV_SR_OFFSET 		0x54C
+#define MP2_4DRV_SR_OFFSET 		0x56C
+#define MP2_5DRV_SR_OFFSET 		0x58C
+#define MP2_6DRV_SR_OFFSET 		0x5AC
+#define MP2_7DRV_SR_OFFSET 		0x5CC
+#define MP2_8DRV_SR_OFFSET 		0x5EC
+
+/* GPH0 */
+#define GPH0CON_OFFSET			0xc00
+#define GPH0DAT_OFFSET			0xc04
+#define GPH0PUD_OFFSET			0xc08
+#define GPH0DRV_OFFSET			0xc0c
+
+/* GPH1 */
+#define GPH1CON_OFFSET			0xc20
+#define GPH1DAT_OFFSET			0xc24
+#define GPH1PUD_OFFSET			0xc28
+#define GPH1DRV_OFFSET			0xc2c
+
+/* GPH2 */
+#define GPH2CON_OFFSET			0xc40
+#define GPH2DAT_OFFSET			0xc44
+#define GPH2PUD_OFFSET			0xc48
+#define GPH2DRV_OFFSET			0xc4c
+
+/* GPH3 */
+#define GPH3CON_OFFSET			0xc60
+#define GPH3DAT_OFFSET			0xc64
+#define GPH3PUD_OFFSET			0xc68
+#define GPH3DRV_OFFSET			0xc6c
+
+
+#define GPICON_OFFSET 			0x220 
+#define GPIPUD_OFFSET 			0x228 
+#define GPIDRV_OFFSET_SR 		0x22C 
+#define GPIPUDPDN_OFFSET 		0x234 
+
+#define GPJ0CON_OFFSET 			0x240 
+#define GPJ0DAT_OFFSET 			0x244 
+#define GPJ0PUD_OFFSET 			0x248 
+#define GPJ0DRV_SR_OFFSET 		0x24C 
+#define GPJ0CONPDN_OFFSET 		0x250 
+#define GPJ0PUDPDN_OFFSET 		0x254 
+
+#define GPJ1CON_OFFSET 			0x260 
+#define GPJ1DAT_OFFSET 			0x264 
+#define GPJ1PUD_OFFSET 			0x268 
+#define GPJ1DRV_SR_OFFSET 		0x26C 
+#define GPJ1CONPDN_OFFSET 		0x270 
+#define GPJ1PUDPDN_OFFSET 		0x274 
+
+#define GPJ2CON_OFFSET 			0x280 
+#define GPJ2DAT_OFFSET 			0x284 
+#define GPJ2PUD_OFFSET 			0x288 
+#define GPJ2DRV_SR_OFFSET 		0x28C 
+#define GPJ2CONPDN_OFFSET 		0x290 
+#define GPJ2PUDPDN_OFFSET 		0x294 
+
+#define GPJ3CON_OFFSET 			0x2A0 
+#define GPJ3DAT_OFFSET 			0x2A4 
+#define GPJ3PUD_OFFSET 			0x2A8 
+#define GPJ3DRV_SR_OFFSET 		0x2AC 
+#define GPJ3CONPDN_OFFSET 		0x2B0 
+#define GPJ3PUDPDN_OFFSET 		0x2B4 
+
+#define GPJ4CON_OFFSET 			0x2C0 
+#define GPJ4DAT_OFFSET 			0x2C4 
+#define GPJ4PUD_OFFSET 			0x2C8 
+#define GPJ4DRV_SR_OFFSET 		0x2CC 
+#define GPJ4CONPDN_OFFSET 		0x2D0 
+#define GPJ4PUDPDN_OFFSET 		0x2D4 
+
+#define MP01CON_OFFSET 			0x2E0 
+#define MP01DAT_OFFSET 			0x2E4 
+#define MP01PUD_OFFSET 			0x2E8 
+#define MP01DRV_SR_OFFSET 		0x2EC 
+#define MP01CONPDN_OFFSET 		0x2E0 
+#define MP01PUDPDN_OFFSET 		0x2E4 
+
+#define MP02CON_OFFSET                  0x300 
+#define MP02DAT_OFFSET                  0x304
+#define MP02PUD_OFFSET                  0x308 
+#define MP02DRV_SR_OFFSET               0x30c 
+#define MP02CONPDN_OFFSET               0x310 
+#define MP02PUDPDN_OFFSET               0x314
+
+#define MP03CON_OFFSET                  0x320 
+#define MP03DAT_OFFSET                  0x324
+#define MP03PUD_OFFSET                  0x328 
+#define MP03DRV_SR_OFFSET               0x32c 
+#define MP03CONPDN_OFFSET               0x330 
+#define MP03PUDPDN_OFFSET               0x334
+
+#define MP06CON_OFFSET                  0x380
+#define MP06DAT_OFFSET                  0x384
+#define MP06PUD_OFFSET                  0x388
+#define MP06DRV_SR_OFFSET               0x38C
+#define MP06CONPDN_OFFSET               0x390
+#define MP06PUDPDN_OFFSET               0x394
+
+#define MP07CON_OFFSET                  0x3A0
+#define MP07DAT_OFFSET                  0x3A4
+#define MP07PUD_OFFSET                  0x3A8
+#define MP07DRV_SR_OFFSET               0x3AC
+#define MP07CONPDN_OFFSET               0x3B0
+#define MP07PUDPDN_OFFSET               0x3B4
+
+#define GPA0CON				(ELFIN_GPIO_BASE + GPA0CON_OFFSET)	 
+#define GPA0DAT				(ELFIN_GPIO_BASE + GPA0DAT_OFFSET)		 
+#define GPA0PUD				(ELFIN_GPIO_BASE + GPA0PUD_OFFSET)		 
+#define GPA0DRV				(ELFIN_GPIO_BASE + GPA0DRV_SR_OFFSET)
+#define GPA0CONPDN			(ELFIN_GPIO_BASE + GPA0CONPDN_OFFSET)	 
+#define GPA0PUDPDN			(ELFIN_GPIO_BASE + GPA0PUDPDN_OFFSET)	 
+#define GPA1CON				(ELFIN_GPIO_BASE + GPA1CON_OFFSET) 
+#define GPA1DAT				(ELFIN_GPIO_BASE + GPA1DAT_OFFSET) 		 
+#define GPA1PUD				(ELFIN_GPIO_BASE + GPA1PUD_OFFSET) 		 
+#define GPA1DRV				(ELFIN_GPIO_BASE + GPA1DRV_SR_OFFSET) 	 
+#define GPA1CONPDN			(ELFIN_GPIO_BASE + GPA1CONPDN_OFFSET) 	 
+#define GPA1PUDPDN			(ELFIN_GPIO_BASE + GPA1PUDPDN_OFFSET) 	 
+#define GPBCON				(ELFIN_GPIO_BASE + GPBCON_OFFSET) 
+#define GPBDAT				(ELFIN_GPIO_BASE + GPBDAT_OFFSET)			 
+#define GPBPUD				(ELFIN_GPIO_BASE + GPBPUD_OFFSET)			 
+#define GPBDRV_SR			(ELFIN_GPIO_BASE + GPBDRV_SR_OFFSET)
+#define GPBCONPDN			(ELFIN_GPIO_BASE + GPBCONPDN_OFFSET)	 
+#define GPBPUDPDN			(ELFIN_GPIO_BASE + GPBPUDPDN_OFFSET)	 
+#define GPC0CON				(ELFIN_GPIO_BASE + GPC0CON_OFFSET)	 
+#define GPC0DAT				(ELFIN_GPIO_BASE + GPC0DAT_OFFSET)		 
+#define GPC0PUD				(ELFIN_GPIO_BASE + GPC0PUD_OFFSET)		 
+#define GPC0DRV				(ELFIN_GPIO_BASE + GPC0DRV_SR_OFFSET)
+#define GPC0CONPDN			(ELFIN_GPIO_BASE + GPC0CONPDN_OFFSET)	 
+#define GPC0PUDPDN			(ELFIN_GPIO_BASE + GPC0PUDPDN_OFFSET)	 
+#define GPC1CON				(ELFIN_GPIO_BASE + GPC1CON_OFFSET) 
+#define GPC1DAT				(ELFIN_GPIO_BASE + GPC1DAT_OFFSET)		 
+#define GPC1PUD				(ELFIN_GPIO_BASE + GPC1PUD_OFFSET)		 
+#define GPC1DRV				(ELFIN_GPIO_BASE + GPC1DRV_SR_OFFSET)
+#define GPC1CONPDN			(ELFIN_GPIO_BASE + GPC1CONPDN_OFFSET)	 
+#define GPC1PUDPDN			(ELFIN_GPIO_BASE + GPC1PUDPDN_OFFSET)	 
+#define GPD0CON				(ELFIN_GPIO_BASE + GPD0CON_OFFSET) 
+#define GPD0DAT				(ELFIN_GPIO_BASE + GPD0DAT_OFFSET)		 
+#define GPD0PUD				(ELFIN_GPIO_BASE + GPD0PUD_OFFSET)		 
+#define GPD0DRV				(ELFIN_GPIO_BASE + GPD0DRV_SR_OFFSET)
+#define GPD0CONPDN			(ELFIN_GPIO_BASE + GPD0CONPDN_OFFSET)	 
+#define GPD0PUDPDN			(ELFIN_GPIO_BASE + GPD0PUDPDN_OFFSET)	 
+#define GPD1CON				(ELFIN_GPIO_BASE + GPD1CON_OFFSET) 
+#define GPD1DAT				(ELFIN_GPIO_BASE + GPD1DAT_OFFSET)		 
+#define GPD1PUD				(ELFIN_GPIO_BASE + GPD1PUD_OFFSET)		 
+#define GPD1DRV				(ELFIN_GPIO_BASE + GPD1DRV_SR_OFFSET)
+#define GPD1CONPDN			(ELFIN_GPIO_BASE + GPD1CONPDN_OFFSET)	 
+#define GPD1PUDPDN			(ELFIN_GPIO_BASE + GPD1PUDPDN_OFFSET)	 
+#define GPE0CON				(ELFIN_GPIO_BASE + GPE0CON_OFFSET) 
+#define GPE0DAT				(ELFIN_GPIO_BASE + GPE0DAT_OFFSET)		 
+#define GPE0PUD				(ELFIN_GPIO_BASE + GPE0PUD_OFFSET)		 
+#define GPE0DRV				(ELFIN_GPIO_BASE + GPE0DRV_SR_OFFSET)
+#define GPE0CONPDN			(ELFIN_GPIO_BASE + GPE0CONPDN_OFFSET)
+#define GPE0PUDPDN			(ELFIN_GPIO_BASE + GPE0PUDPDN_OFFSET)	 
+#define GPE1CON				(ELFIN_GPIO_BASE + GPE1CON_OFFSET) 
+#define GPE1DAT				(ELFIN_GPIO_BASE + GPE1DAT_OFFSET)		 
+#define GPE1PUD				(ELFIN_GPIO_BASE + GPE1PUD_OFFSET)		 
+#define GPE1DRV				(ELFIN_GPIO_BASE + GPE1DRV_SR_OFFSET)
+#define GPE1CONPDN			(ELFIN_GPIO_BASE + GPE1CONPDN_OFFSET)	 
+#define GPE1PUDPDN			(ELFIN_GPIO_BASE + GPE1PUDPDN_OFFSET)	 
+#define GPF0CON				(ELFIN_GPIO_BASE + GPF0CON_OFFSET) 
+#define GPF0DAT				(ELFIN_GPIO_BASE + GPF0DAT_OFFSET)		 
+#define GPF0PUD				(ELFIN_GPIO_BASE + GPF0PUD_OFFSET)		 
+#define GPF0DRV				(ELFIN_GPIO_BASE + GPF0DRV_SR_OFFSET)
+#define GPF0CONPDN			(ELFIN_GPIO_BASE + GPF0CONPDN_OFFSET)	 
+#define GPF0PUDPDN			(ELFIN_GPIO_BASE + GPF0PUDPDN_OFFSET)	 
+#define GPF1CON				(ELFIN_GPIO_BASE + GPF1CON_OFFSET) 
+#define GPF1DAT				(ELFIN_GPIO_BASE + GPF1DAT_OFFSET)		 
+#define GPF1PUD				(ELFIN_GPIO_BASE + GPF1PUD_OFFSET)		 
+#define GPF1DRV				(ELFIN_GPIO_BASE + GPF1DRV_SR_OFFSET)
+#define GPF1CONPDN			(ELFIN_GPIO_BASE + GPF1CONPDN_OFFSET)	 
+#define GPF1PUDPDN			(ELFIN_GPIO_BASE + GPF1PUDPDN_OFFSET)	 
+#define GPF2CON				(ELFIN_GPIO_BASE + GPF2CON_OFFSET) 
+#define GPF2DAT				(ELFIN_GPIO_BASE + GPF2DAT_OFFSET)		 
+#define GPF2PUD				(ELFIN_GPIO_BASE + GPF2PUD_OFFSET)		 
+#define GPF2DRV				(ELFIN_GPIO_BASE + GPF2DRV_SR_OFFSET)	 
+#define GPF2CONPDN			(ELFIN_GPIO_BASE + GPF2CONPDN_OFFSET)	 
+#define GPF2PUDPDN			(ELFIN_GPIO_BASE + GPF2PUDPDN_OFFSET)	 
+#define GPF3CON				(ELFIN_GPIO_BASE + GPF3CON_OFFSET) 
+#define GPF3DAT				(ELFIN_GPIO_BASE + GPF3DAT_OFFSET)		 
+#define GPF3PUD				(ELFIN_GPIO_BASE + GPF3PUD_OFFSET)		 
+#define GPF3DRV				(ELFIN_GPIO_BASE + GPF3DRV_SR_OFFSET)
+#define GPF3CONPDN			(ELFIN_GPIO_BASE + GPF3CONPDN_OFFSET)	 
+#define GPF3PUDPDN			(ELFIN_GPIO_BASE + GPF3PUDPDN_OFFSET)	 
+#define GPG0CON				(ELFIN_GPIO_BASE + GPG0CON_OFFSET) 
+#define GPG0DAT				(ELFIN_GPIO_BASE + GPG0DAT_OFFSET)		 
+#define GPG0PUD				(ELFIN_GPIO_BASE + GPG0PUD_OFFSET)		 
+#define GPG0DRV				(ELFIN_GPIO_BASE + GPG0DRV_SR_OFFSET)
+#define GPG0CONPDN			(ELFIN_GPIO_BASE + GPG0CONPDN_OFFSET)	 
+#define GPG0PUDPDN			(ELFIN_GPIO_BASE + GPG0PUDPDN_OFFSET)	 
+#define GPG1CON				(ELFIN_GPIO_BASE + GPG1CON_OFFSET) 
+#define GPG1DAT				(ELFIN_GPIO_BASE + GPG1DAT_OFFSET)		 
+#define GPG1PUD				(ELFIN_GPIO_BASE + GPG1PUD_OFFSET)		 
+#define GPG1DRV				(ELFIN_GPIO_BASE + GPG1DRV_SR_OFFSET)
+#define GPG1CONPDN			(ELFIN_GPIO_BASE + GPG1CONPDN_OFFSET)	 
+#define GPG1PUDPDN			(ELFIN_GPIO_BASE + GPG1PUDPDN_OFFSET)	 
+#define GPG2CON				(ELFIN_GPIO_BASE + GPG2CON_OFFSET) 
+#define GPG2DAT				(ELFIN_GPIO_BASE + GPG2DAT_OFFSET)		 
+#define GPG2PUD				(ELFIN_GPIO_BASE + GPG2PUD_OFFSET)		 
+#define GPG2DRV				(ELFIN_GPIO_BASE + GPG2DRV_SR_OFFSET)
+#define GPG2CONPDN			(ELFIN_GPIO_BASE + GPG2CONPDN_OFFSET)	 
+#define GPG2PUDPDN			(ELFIN_GPIO_BASE + GPG2PUDPDN_OFFSET)	 
+#define GPG3CON				(ELFIN_GPIO_BASE + GPG3CON_OFFSET) 
+#define GPG3DAT				(ELFIN_GPIO_BASE + GPG3DAT_OFFSET)		 
+#define GPG3PUD				(ELFIN_GPIO_BASE + GPG3PUD_OFFSET)		 
+#define GPG3DRV				(ELFIN_GPIO_BASE + GPG3DRV_SR_OFFSET)
+#define GPG3CONPDN			(ELFIN_GPIO_BASE + GPG3CONPDN_OFFSET)	 
+#define GPG3PUDPDN			(ELFIN_GPIO_BASE + GPG3PUDPDN_OFFSET)	 
+#define GPICON				(ELFIN_GPIO_BASE + GPICON_OFFSET) 
+#define GPIPUD				(ELFIN_GPIO_BASE + GPIPUD_OFFSET)			 
+#define GPIDRV				(ELFIN_GPIO_BASE + GPIDRV_OFFSET_SR)
+#define GPIPUDPDN			(ELFIN_GPIO_BASE + GPIPUDPDN_OFFSET)	 
+#define GPJ0CON				(ELFIN_GPIO_BASE + GPJ0CON_OFFSET)	 
+#define GPJ0DAT				(ELFIN_GPIO_BASE + GPJ0DAT_OFFSET)		 
+#define GPJ0PUD				(ELFIN_GPIO_BASE + GPJ0PUD_OFFSET)		 
+#define GPJ0DRV				(ELFIN_GPIO_BASE + GPJ0DRV_SR_OFFSET)
+#define GPJ0CONPDN			(ELFIN_GPIO_BASE + GPJ0CONPDN_OFFSET)	 
+#define GPJ0PUDPDN			(ELFIN_GPIO_BASE + GPJ0PUDPDN_OFFSET)	 
+#define GPJ1CON				(ELFIN_GPIO_BASE + GPJ1CON_OFFSET) 
+#define GPJ1DAT				(ELFIN_GPIO_BASE + GPJ1DAT_OFFSET)		 
+#define GPJ1PUD				(ELFIN_GPIO_BASE + GPJ1PUD_OFFSET)		 
+#define GPJ1DRV				(ELFIN_GPIO_BASE + GPJ1DRV_SR_OFFSET)
+#define GPJ1CONPDN			(ELFIN_GPIO_BASE + GPJ1CONPDN_OFFSET)	 
+#define GPJ1PUDPDN			(ELFIN_GPIO_BASE + GPJ1PUDPDN_OFFSET)	 
+#define GPJ2CON				(ELFIN_GPIO_BASE + GPJ2CON_OFFSET) 
+#define GPJ2DAT				(ELFIN_GPIO_BASE + GPJ2DAT_OFFSET)		 
+#define GPJ2PUD				(ELFIN_GPIO_BASE + GPJ2PUD_OFFSET)		 
+#define GPJ2DRV				(ELFIN_GPIO_BASE + GPJ2DRV_SR_OFFSET)
+#define GPJ2CONPDN			(ELFIN_GPIO_BASE + GPJ2CONPDN_OFFSET)	 
+#define GPJ2PUDPDN			(ELFIN_GPIO_BASE + GPJ2PUDPDN_OFFSET)	 
+#define GPJ3CON				(ELFIN_GPIO_BASE + GPJ3CON_OFFSET) 
+#define GPJ3DAT				(ELFIN_GPIO_BASE + GPJ3DAT_OFFSET)		 
+#define GPJ3PUD				(ELFIN_GPIO_BASE + GPJ3PUD_OFFSET)		 
+#define GPJ3DRV_SR			(ELFIN_GPIO_BASE + GPJ3DRV_SR_OFFSET)
+#define GPJ3CONPDN			(ELFIN_GPIO_BASE + GPJ3CONPDN_OFFSET)	 
+#define GPJ3PUDPDN			(ELFIN_GPIO_BASE + GPJ3PUDPDN_OFFSET)	 
+#define GPJ4CON				(ELFIN_GPIO_BASE + GPJ4CON_OFFSET)
+#define GPJ4DAT				(ELFIN_GPIO_BASE + GPJ4DAT_OFFSET)		 
+#define GPJ4PUD				(ELFIN_GPIO_BASE + GPJ4PUD_OFFSET)		 
+#define GPJ4DRV				(ELFIN_GPIO_BASE + GPJ4DRV_SR_OFFSET)
+#define GPJ4CONPDN			(ELFIN_GPIO_BASE + GPJ4CONPDN_OFFSET)	 
+#define GPJ4PUDPDN			(ELFIN_GPIO_BASE + GPJ4PUDPDN_OFFSET)
+
+#define MP01CON_REG			__REG(ELFIN_GPIO_BASE + MP01CON_OFFSET)
+#define MP01DAT_REG			__REG(ELFIN_GPIO_BASE + MP01DAT_OFFSET)		 
+#define MP01PUD_REG			__REG(ELFIN_GPIO_BASE + MP01PUD_OFFSET)		 
+#define MP01DRV_REG			__REG(ELFIN_GPIO_BASE + MP01DRV_SR_OFFSET)
+#define MP01CONPDN_REG			__REG(ELFIN_GPIO_BASE + MP01CONPDN_OFFSET)	 
+#define MP01PUDPDN_REG			__REG(ELFIN_GPIO_BASE + MP01PUDPDN_OFFSET)
+
+
+#define MP02CON_REG                     __REG(ELFIN_GPIO_BASE + MP02CON_OFFSET)
+#define MP02DAT_REG                     __REG(ELFIN_GPIO_BASE + MP02DAT_OFFSET)          
+#define MP02PUD_REG                     __REG(ELFIN_GPIO_BASE + MP02PUD_OFFSET)          
+#define MP02DRV_REG                     __REG(ELFIN_GPIO_BASE + MP02DRV_SR_OFFSET)
+#define MP02CONPDN_REG                  __REG(ELFIN_GPIO_BASE + MP02CONPDN_OFFSET)       
+#define MP02PUDPDN_REG                  __REG(ELFIN_GPIO_BASE + MP02PUDPDN_OFFSET)
+
+#define MP03CON_REG                     __REG(ELFIN_GPIO_BASE + MP03CON_OFFSET)
+#define MP03DAT_REG                     __REG(ELFIN_GPIO_BASE + MP03DAT_OFFSET)          
+#define MP03PUD_REG                     __REG(ELFIN_GPIO_BASE + MP03PUD_OFFSET)          
+#define MP03DRV_REG                     __REG(ELFIN_GPIO_BASE + MP03DRV_SR_OFFSET)
+#define MP03CONPDN_REG                  __REG(ELFIN_GPIO_BASE + MP03CONPDN_OFFSET)       
+#define MP03PUDPDN_REG                  __REG(ELFIN_GPIO_BASE + MP03PUDPDN_OFFSET)
+
+#define NFCONF_VAL	(7<<12)|(7<<8)|(7<<4)|(0<<3)|(1<<2)|(1<<1)|(0<<0)       
+#define NFCONT_VAL	(0<<18)|(0<<17)|(0<<16)|(0<<10)|(0<<9)|(0<<8)|(0<<7)|(0<<6)|(0x3<<1)|(1<<0)
+#define MP03CON_VAL	(1<<29)|(1<<25)|(1<<21)|(1<<17)|(1<<13)|(1<<9)|(1<<5)|(1<<1)
+/*
+ * Bus Matrix
+ */
+#define ELFIN_MEM_SYS_CFG		0x7e00f120
+
+/*
+ * Memory controller
+ */
+#define ELFIN_SROM_BASE			0xE8000000
+
+#define SROM_BW_REG			__REG(ELFIN_SROM_BASE+0x0)
+#define SROM_BC0_REG			__REG(ELFIN_SROM_BASE+0x4)
+#define SROM_BC1_REG			__REG(ELFIN_SROM_BASE+0x8)
+#define SROM_BC2_REG			__REG(ELFIN_SROM_BASE+0xC)
+#define SROM_BC3_REG			__REG(ELFIN_SROM_BASE+0x10)
+#define SROM_BC4_REG			__REG(ELFIN_SROM_BASE+0x14)
+#define SROM_BC5_REG			__REG(ELFIN_SROM_BASE+0x18)
+
+/*
+ * SDRAM Controller
+ */
+#define APB_DMC_0_BASE			0xF0000000
+#define APB_DMC_1_BASE			0xF1400000
+#define ASYNC_MSYS_DMC0_BASE		0xF1E00000
+
+#define DMC_CONCONTROL 			0x00
+#define DMC_MEMCONTROL 			0x04
+#define DMC_MEMCONFIG0 			0x08
+#define DMC_MEMCONFIG1 			0x0C
+#define DMC_DIRECTCMD 			0x10
+#define DMC_PRECHCONFIG 		0x14
+#define DMC_PHYCONTROL0 		0x18
+#define DMC_PHYCONTROL1 		0x1C
+#define DMC_RESERVED 			0x20
+#define DMC_PWRDNCONFIG 		0x28
+#define DMC_TIMINGAREF 			0x30
+#define DMC_TIMINGROW 			0x34
+#define DMC_TIMINGDATA 			0x38
+#define DMC_TIMINGPOWER 		0x3C
+#define DMC_PHYSTATUS 			0x40
+#define DMC_CHIP0STATUS 		0x48
+#define DMC_CHIP1STATUS 		0x4C
+#define DMC_AREFSTATUS 			0x50
+#define DMC_MRSTATUS 			0x54
+#define DMC_PHYTEST0 			0x58
+#define DMC_PHYTEST1 			0x5C
+#define DMC_QOSCONTROL0 		0x60
+#define DMC_QOSCONFIG0 			0x64
+#define DMC_QOSCONTROL1 		0x68
+#define DMC_QOSCONFIG1 			0x6C
+#define DMC_QOSCONTROL2 		0x70
+#define DMC_QOSCONFIG2 			0x74
+#define DMC_QOSCONTROL3 		0x78
+#define DMC_QOSCONFIG3 			0x7C
+#define DMC_QOSCONTROL4 		0x80
+#define DMC_QOSCONFIG4 			0x84
+#define DMC_QOSCONTROL5 		0x88
+#define DMC_QOSCONFIG5 			0x8C
+#define DMC_QOSCONTROL6 		0x90
+#define DMC_QOSCONFIG6 			0x94
+#define DMC_QOSCONTROL7 		0x98
+#define DMC_QOSCONFIG7 			0x9C
+#define DMC_QOSCONTROL8 		0xA0
+#define DMC_QOSCONFIG8 			0xA4
+#define DMC_QOSCONTROL9 		0xA8
+#define DMC_QOSCONFIG9 			0xAC
+#define DMC_QOSCONTROL10 		0xB0
+#define DMC_QOSCONFIG10 		0xB4
+#define DMC_QOSCONTROL11 		0xB8
+#define DMC_QOSCONFIG11 		0xBC
+#define DMC_QOSCONTROL12 		0xC0
+#define DMC_QOSCONFIG12 		0xC4
+#define DMC_QOSCONTROL13 		0xC8
+#define DMC_QOSCONFIG13 		0xCC
+#define DMC_QOSCONTROL14 		0xD0
+#define DMC_QOSCONFIG14 		0xD4
+#define DMC_QOSCONTROL15 		0xD8
+#define DMC_QOSCONFIG15 		0xDC
+
+
+/*
+* Memory Chip direct command
+*/
+
+/****************************************************************
+ Definitions for memory configuration
+ Set memory configuration
+	active_chips	 = 1'b0 (1 chip)
+	qos_master_chip  = 3'b000(ARID[3:0])
+	memory burst	 = 3'b010(burst 4)
+	stop_mem_clock	 = 1'b0(disable dynamical stop)
+	auto_power_down  = 1'b0(disable auto power-down mode)
+	power_down_prd	 = 6'b00_0000(0 cycle for auto power-down)
+	ap_bit		 = 1'b0 (bit position of auto-precharge is 10)
+	row_bits	 = 3'b010(# row address 13)
+	column_bits	 = 3'b010(# column address 10 )
+
+ Set user configuration
+	2'b10=SDRAM/mSDRAM, 2'b11=DDR, 2'b01=mDDR
+
+ Set chip select for chip [n]
+	 row bank control, bank address 0x3000_0000 ~ 0x37ff_ffff
+	 CHIP_[n]_CFG=0x30F8,  30: ADDR[31:24], F8: Mask[31:24]
+******************************************************************/
+
+/*
+ * HS MMC Interface
+ */
+#define ELFIN_HSMMC_BASE		0xEB000000
+
+#define HM_SYSAD			(0x00)
+#define HM_BLKSIZE			(0x04)
+#define HM_BLKCNT			(0x06)
+#define HM_ARGUMENT			(0x08)
+#define HM_TRNMOD			(0x0c)
+#define HM_CMDREG			(0x0e)
+#define HM_RSPREG0			(0x10)
+#define HM_RSPREG1			(0x14)
+#define HM_RSPREG2			(0x18)
+#define HM_RSPREG3			(0x1c)
+#define HM_BDATA			(0x20)
+#define HM_PRNSTS			(0x24)
+#define HM_HOSTCTL			(0x28)
+#define HM_PWRCON			(0x29)
+#define HM_BLKGAP			(0x2a)
+#define HM_WAKCON			(0x2b)
+#define HM_CLKCON			(0x2c)
+#define HM_TIMEOUTCON			(0x2e)
+#define HM_SWRST			(0x2f)
+#define HM_NORINTSTS			(0x30)
+#define HM_ERRINTSTS			(0x32)
+#define HM_NORINTSTSEN			(0x34)
+#define HM_ERRINTSTSEN			(0x36)
+#define HM_NORINTSIGEN			(0x38)
+#define HM_ERRINTSIGEN			(0x3a)
+#define HM_ACMD12ERRSTS			(0x3c)
+#define HM_CAPAREG			(0x40)
+#define HM_MAXCURR			(0x48)
+#define HM_CONTROL2			(0x80)
+#define HM_CONTROL3			(0x84)
+#define HM_CONTROL4			(0x8c)
+#define HM_HCVER			(0xfe)
+
+/*
+ * Nand flash controller
+ */
+#define ELFIN_NAND_BASE			0xB0E00000
+#define ELFIN_NAND_ECC_BASE		0xB0E20000
+
+#define NFCONF_OFFSET           	0x00
+#define NFCONT_OFFSET           	0x04
+#define NFCMMD_OFFSET           	0x08
+#define NFADDR_OFFSET           	0x0c
+#define NFDATA_OFFSET			0x10
+#define NFMECCDATA0_OFFSET      	0x14
+#define NFMECCDATA1_OFFSET      	0x18
+#define NFSECCDATA0_OFFSET      	0x1c
+#define NFSBLK_OFFSET           	0x20
+#define NFEBLK_OFFSET           	0x24
+#define NFSTAT_OFFSET           	0x28
+#define NFESTAT0_OFFSET         	0x2c
+#define NFESTAT1_OFFSET         	0x30
+#define NFMECC0_OFFSET          	0x34
+#define NFMECC1_OFFSET          	0x38
+#define NFSECC_OFFSET           	0x3c
+#define NFMLCBITPT_OFFSET       	0x40
+#define NFECCCONF_OFFSET 		0x000 // R/W ECC configuration register 0x0000_0000
+#define NFECCCONT_OFFSET 		0x020 // R/W ECC control register 0x0000_0000
+#define NFECCSTAT_OFFSET 		0x030 // R ECC status register 0x0000_0000
+#define NFECCSECSTAT_OFFSET 		0x040 // R ECC sector status register 0x0000_0000
+#define NFECCPRGECC0_OFFSET 		0x090 // R ECC parity code0 register for page program 0x0000_0000
+#define NFECCPRGECC1_OFFSET 		0x094 // R ECC parity code1 register for page program 0x0000_0000
+#define NFECCPRGECC2_OFFSET 		0x098 // R ECC parity code2 register for page program 0x0000_0000
+#define NFECCPRGECC3_OFFSET 		0x09C // R ECC parity code3 register for page program 0x0000_0000
+#define NFECCPRGECC4_OFFSET 		0x0A0 // R ECC parity code4 register for page program 0x0000_0000
+#define NFECCPRGECC5_OFFSET 		0x0A4 // R ECC parity code5 register for page program 0x0000_0000
+#define NFECCPRGECC6_OFFSET 		0x0A8 // R ECC parity code6 register for page program 0x0000_0000
+#define NFECCERL0_OFFSET		0x0C0 // R ECC error byte location0 register 0x0000_0000
+#define NFECCERL1_OFFSET		0x0C4 // R ECC error byte location1 register 0x0000_0000
+#define NFECCERL2_OFFSET		0x0C8 // R ECC error byte location2 register 0x0000_0000
+#define NFECCERL3_OFFSET 		0x0CC // R ECC error byte location3 register 0x0000_0000
+#define NFECCERL4_OFFSET 		0x0D0 // R ECC error byte location4 register 0x0000_0000
+#define NFECCERL5_OFFSET 		0x0D4 // R ECC error byte location5 register 0x0000_0000
+#define NFECCERL6_OFFSET 		0x0D8 // R ECC error byte location6 register 0x0000_0000
+#define NFECCERL7_OFFSET 		0x0DC // R ECC error byte location7 register 0x0000_0000
+#define NFECCERP0_OFFSET 		0x0F0 // R ECC error bit pattern0 register 0x0000_0000
+#define NFECCERP1_OFFSET 		0x0F4 // R ECC error bit pattern1 register 0x0000_0000
+#define NFECCERP2_OFFSET 		0x0F8 // R ECC error bit pattern2 register 0x0000_0000
+#define NFECCERP3_OFFSET 		0x0FC // R ECC error bit pattern3 register 0x0000_0000
+#define NFECCCONECC0_OFFSET 		0x110 // R/W ECC parity conversion code0 register 0x0000_0000
+#define NFECCCONECC1_OFFSET 		0x114 // R/W ECC parity conversion code1 register 0x0000_0000
+#define NFECCCONECC2_OFFSET 		0x118 // R/W ECC parity conversion code2 register 0x0000_0000
+#define NFECCCONECC3_OFFSET 		0x11C // R/W ECC parity conversion code3 register 0x0000_0000
+#define NFECCCONECC4_OFFSET 		0x120 // R/W ECC parity conversion code4 register 0x0000_0000
+#define NFECCCONECC5_OFFSET 		0x124 // R/W ECC parity conversion code5 register 0x0000_0000
+#define NFECCCONECC6_OFFSET		0x128 // R/W ECC parity conversion code6 register 0x0000_0000
+
+#define NFCONF				(ELFIN_NAND_BASE+NFCONF_OFFSET)
+#define NFCONT				(ELFIN_NAND_BASE+NFCONT_OFFSET)
+#define NFCMMD				(ELFIN_NAND_BASE+NFCMMD_OFFSET)
+#define NFADDR           		(ELFIN_NAND_BASE+NFADDR_OFFSET)
+#define NFDATA          		(ELFIN_NAND_BASE+NFDATA_OFFSET)
+#define NFMECCDATA0     		(ELFIN_NAND_BASE+NFMECCDATA0_OFFSET)
+#define NFMECCDATA1     		(ELFIN_NAND_BASE+NFMECCDATA1_OFFSET)
+#define NFSECCDATA0      		(ELFIN_NAND_BASE+NFSECCDATA0_OFFSET)
+#define NFSBLK          		(ELFIN_NAND_BASE+NFSBLK_OFFSET)
+#define NFEBLK           		(ELFIN_NAND_BASE+NFEBLK_OFFSET)
+#define NFSTAT           		(ELFIN_NAND_BASE+NFSTAT_OFFSET)
+#define NFESTAT0         		(ELFIN_NAND_BASE+NFESTAT0_OFFSET)
+#define NFESTAT1         		(ELFIN_NAND_BASE+NFESTAT1_OFFSET)
+#define NFMECC0          		(ELFIN_NAND_BASE+NFMECC0_OFFSET)
+#define NFMECC1          		(ELFIN_NAND_BASE+NFMECC1_OFFSET)
+#define NFSECC           		(ELFIN_NAND_BASE+NFSECC_OFFSET)
+#define NFMLCBITPT           		(ELFIN_NAND_BASE+NFMLCBITPT_OFFSET)
+
+#define NFECCCONF			(ELFIN_NAND_ECC_BASE+NFECCCONF_OFFSET)
+#define NFECCCONT			(ELFIN_NAND_ECC_BASE+NFECCCONT_OFFSET)
+#define NFECCSTAT			(ELFIN_NAND_ECC_BASE+NFECCSTAT_OFFSET)
+#define NFECCSECSTAT			(ELFIN_NAND_ECC_BASE+NFECCSECSTAT_OFFSET)
+#define NFECCPRGECC0			(ELFIN_NAND_ECC_BASE+NFECCPRGECC0_OFFSET)
+#define NFECCPRGECC1			(ELFIN_NAND_ECC_BASE+NFECCPRGECC1_OFFSET)
+#define NFECCPRGECC2			(ELFIN_NAND_ECC_BASE+NFECCPRGECC2_OFFSET)
+#define NFECCPRGECC3			(ELFIN_NAND_ECC_BASE+NFECCPRGECC3_OFFSET)
+#define NFECCPRGECC4			(ELFIN_NAND_ECC_BASE+NFECCPRGECC4_OFFSET)
+#define NFECCPRGECC5			(ELFIN_NAND_ECC_BASE+NFECCPRGECC5_OFFSET)
+#define NFECCPRGECC6			(ELFIN_NAND_ECC_BASE+NFECCPRGECC6_OFFSET)
+#define NFECCERL0			(ELFIN_NAND_ECC_BASE+NFECCERL0_OFFSET)
+#define NFECCERL1			(ELFIN_NAND_ECC_BASE+NFECCERL1_OFFSET)
+#define NFECCERL2			(ELFIN_NAND_ECC_BASE+NFECCERL2_OFFSET)
+#define NFECCERL3			(ELFIN_NAND_ECC_BASE+NFECCERL3_OFFSET)
+#define NFECCERL4			(ELFIN_NAND_ECC_BASE+NFECCERL4_OFFSET)
+#define NFECCERL5			(ELFIN_NAND_ECC_BASE+NFECCERL5_OFFSET)
+#define NFECCERL6			(ELFIN_NAND_ECC_BASE+NFECCERL6_OFFSET)
+#define NFECCERL7			(ELFIN_NAND_ECC_BASE+NFECCERL7_OFFSET)
+#define NFECCERP0			(ELFIN_NAND_ECC_BASE+NFECCERP0_OFFSET)
+#define NFECCERP1			(ELFIN_NAND_ECC_BASE+NFECCERP1_OFFSET)
+#define NFECCERP2			(ELFIN_NAND_ECC_BASE+NFECCERP2_OFFSET)
+#define NFECCERP3			(ELFIN_NAND_ECC_BASE+NFECCERP3_OFFSET)
+#define NFECCCONECC0			(ELFIN_NAND_ECC_BASE+NFECCCONECC0_OFFSET)
+#define NFECCCONECC1			(ELFIN_NAND_ECC_BASE+NFECCCONECC1_OFFSET)
+#define NFECCCONECC2			(ELFIN_NAND_ECC_BASE+NFECCCONECC2_OFFSET)
+#define NFECCCONECC3			(ELFIN_NAND_ECC_BASE+NFECCCONECC3_OFFSET)
+#define NFECCCONECC4			(ELFIN_NAND_ECC_BASE+NFECCCONECC4_OFFSET)
+#define NFECCCONECC5			(ELFIN_NAND_ECC_BASE+NFECCCONECC5_OFFSET)
+#define NFECCCONECC6			(ELFIN_NAND_ECC_BASE+NFECCCONECC6_OFFSET)
+
+
+#define NFCONF_REG			__REG(ELFIN_NAND_BASE+NFCONF_OFFSET)
+#define NFCONT_REG			__REG(ELFIN_NAND_BASE+NFCONT_OFFSET)
+#define NFCMD_REG			__REG(ELFIN_NAND_BASE+NFCMMD_OFFSET)
+#define NFADDR_REG           		__REG(ELFIN_NAND_BASE+NFADDR_OFFSET)
+#define NFDATA_REG          		__REG(ELFIN_NAND_BASE+NFDATA_OFFSET)
+#define NFDATA8_REG          		__REGb(ELFIN_NAND_BASE+NFDATA_OFFSET)
+#define NFMECCDATA0_REG     		__REG(ELFIN_NAND_BASE+NFMECCDATA0_OFFSET)
+#define NFMECCDATA1_REG     		__REG(ELFIN_NAND_BASE+NFMECCDATA1_OFFSET)
+#define NFSECCDATA0_REG      		__REG(ELFIN_NAND_BASE+NFSECCDATA0_OFFSET)
+#define NFSBLK_REG          		__REG(ELFIN_NAND_BASE+NFSBLK_OFFSET)
+#define NFEBLK_REG           		__REG(ELFIN_NAND_BASE+NFEBLK_OFFSET)
+#define NFSTAT_REG           		__REG(ELFIN_NAND_BASE+NFSTAT_OFFSET)
+#define NFESTAT0_REG         		__REG(ELFIN_NAND_BASE+NFESTAT0_OFFSET)
+#define NFESTAT1_REG         		__REG(ELFIN_NAND_BASE+NFESTAT1_OFFSET)
+#define NFMECC0_REG          		__REG(ELFIN_NAND_BASE+NFMECC0_OFFSET)
+#define NFMECC1_REG          		__REG(ELFIN_NAND_BASE+NFMECC1_OFFSET)
+#define NFSECC_REG           		__REG(ELFIN_NAND_BASE+NFSECC_OFFSET)
+#define NFMLCBITPT_REG         		__REG(ELFIN_NAND_BASE+NFMLCBITPT_OFFSET)
+
+#define NFCONF_ECC_MLC			(1<<24)
+
+#define NFCONF_ECC_1BIT			(0<<23)
+#define NFCONF_ECC_4BIT			(2<<23)
+#define NFCONF_ECC_8BIT			(1<<23)
+
+#define NFCONT_ECC_ENC			(1<<18)
+#define NFCONT_WP			(1<<16)
+#define NFCONT_MECCLOCK			(1<<7)
+#define NFCONT_SECCLOCK			(1<<6)
+#define NFCONT_INITMECC			(1<<5)
+#define NFCONT_INITSECC			(1<<4)
+#define NFCONT_INITECC			(NFCONT_INITMECC | NFCONT_INITSECC)
+#define NFCONT_CS			(1<<1)
+#define NFSTAT_ECCENCDONE		(1<<25)
+#define NFSTAT_ECCDECDONE		(1<<24)
+#define NFSTAT_RnB			(1<<0)
+#define NFESTAT0_ECCBUSY		(1<<31)
+
+
+
+/*************************************************************
+ * OneNAND Controller
+ *************************************************************/
+#define ELFIN_ONENAND_BASE		0xB0000000
+#define ELFIN_ONENANDCON_BASE		(ELFIN_ONENAND_BASE + 0x600000)
+
+#define ONENAND_IF_CTRL_OFFSET			0x100
+#define ONENAND_IF_CMD_OFFSET			0x104
+#define ONENAND_IF_ASYNC_TIMING_CTRL_OFFSET	0x108
+#define ONENAND_IF_STATUS_OFFSET		0x10C
+#define DMA_SRC_ADDR_OFFSET			0x400
+#define DMA_SRC_CFG_OFFSET			0x404
+#define DMA_DST_ADDR_OFFSET			0x408
+#define DMA_DST_CFG_OFFSET			0x40C
+#define DMA_TRANS_SIZE_OFFSET			0x414
+#define DMA_TRANS_CMD_OFFSET			0x418
+#define DMA_TRANS_STATUS_OFFSET			0x41C
+#define DMA_TRANS_DIR_OFFSET			0x420
+#define SQC_SAO_OFFSET				0x600
+#define SQC_CMD_OFFSET				0x608
+#define SQC_STATUS_OFFSET			0x60C
+#define SQC_CAO_OFFSET				0x610
+#define SQC_REG_CTRL_OFFSET			0x614
+#define SQC_REG_VAL_OFFSET			0x618
+#define SQC_BRPAO0_OFFSET			0x620
+#define SQC_BRPAO1_OFFSET			0x624
+#define INTC_SQC_CLR_OFFSET			0x1000
+#define INTC_DMA_CLR_OFFSET			0x1004
+#define INTC_ONENAND_CLR_OFFSET			0x1008
+#define INTC_SQC_MASK_OFFSET			0x1020
+#define INTC_DMA_MASK_OFFSET			0x1024
+#define INTC_ONENAND_MASK_OFFSET		0x1028
+#define INTC_SQC_PEND_OFFSET			0x1040
+#define INTC_DMA_PEND_OFFSET			0x1044
+#define INTC_ONENAND_PEND_OFFSET		0x1048
+#define INTC_SQC_STATUS_OFFSET			0x1060
+#define INTC_DMA_STATUS_OFFSET			0x1064
+#define INTC_ONENAND_STATUS_OFFSET		0x1068
+
+#if 0
+#define ONENAND_MEM_CFG_SYNC_READ	(1 << 15)
+#define ONENAND_MEM_CFG_BRL_7		(7 << 12)
+#define ONENAND_MEM_CFG_BRL_6		(6 << 12)
+#define ONENAND_MEM_CFG_BRL_5		(5 << 12)
+#define ONENAND_MEM_CFG_BRL_4		(4 << 12)
+#define ONENAND_MEM_CFG_BRL_3		(3 << 12)
+#define ONENAND_MEM_CFG_BRL_10		(2 << 12)
+#define ONENAND_MEM_CFG_BRL_9		(1 << 12)
+#define ONENAND_MEM_CFG_BRL_8		(0 << 12)
+#define ONENAND_MEM_CFG_BRL_SHIFT	(12)
+#define ONENAND_MEM_CFG_BL_1K		(5 << 9)
+#define ONENAND_MEM_CFG_BL_32		(4 << 9)
+#define ONENAND_MEM_CFG_BL_16		(3 << 9)
+#define ONENAND_MEM_CFG_BL_8		(2 << 9)
+#define ONENAND_MEM_CFG_BL_4		(1 << 9)
+#define ONENAND_MEM_CFG_BL_CONT		(0 << 9)
+#define ONENAND_MEM_CFG_BL_SHIFT	(9)
+#define ONENAND_MEM_CFG_NO_ECC		(1 << 8)
+#define ONENAND_MEM_CFG_RDY_HIGH	(1 << 7)
+#define ONENAND_MEM_CFG_INT_HIGH	(1 << 6)
+#define ONENAND_MEM_CFG_IOBE		(1 << 5)
+#define ONENAND_MEM_CFG_RDY_CONF	(1 << 4)
+#define ONENAND_MEM_CFG_HF		(1 << 2)
+#define ONENAND_MEM_CFG_WM_SYNC		(1 << 1)
+#define ONENAND_MEM_CFG_BWPS_UNLOCK	(1 << 0)
+
+#define ONENAND_BURST_LEN_CONT		(0)
+#define ONENAND_BURST_LEN_4		(4)
+#define ONENAND_BURST_LEN_8		(8)
+#define ONENAND_BURST_LEN_16		(16)
+
+#define ONENAND_MEM_RESET_WARM		(0x1)
+#define ONENAND_MEM_RESET_COLD		(0x2)
+#define ONENAND_MEM_RESET_HOT		(0x3)
+
+#define ONENAND_INT_ERR_CACHE_OP_ERR	(1 << 13)
+#define ONENAND_INT_ERR_RST_CMP		(1 << 12)
+#define ONENAND_INT_ERR_RDY_ACT		(1 << 11)
+#define ONENAND_INT_ERR_INT_ACT		(1 << 10)
+#define ONENAND_INT_ERR_UNSUP_CMD	(1 << 9)
+#define ONENAND_INT_ERR_LOCKED_BLK	(1 << 8)
+#define ONENAND_INT_ERR_BLK_RW_CMP	(1 << 7)
+#define ONENAND_INT_ERR_ERS_CMP		(1 << 6)
+#define ONENAND_INT_ERR_PGM_CMP		(1 << 5)
+#define ONENAND_INT_ERR_LOAD_CMP	(1 << 4)
+#define ONENAND_INT_ERR_ERS_FAIL	(1 << 3)
+#define ONENAND_INT_ERR_PGM_FAIL	(1 << 2)
+#define ONENAND_INT_ERR_INT_TO		(1 << 1)
+#define ONENAND_INT_ERR_LD_FAIL_ECC_ERR	(1 << 0)
+
+#define ONENAND_DEVICE_DENSITY_SHIFT	(4)
+#define ONENAND_DEVICE_IS_DDP		(1 << 3)
+#define ONENAND_DEVICE_IS_DEMUX		(1 << 2)
+#define ONENAND_DEVICE_VCC_MASK		(0x3)
+#define ONENAND_DEVICE_DENSITY_128Mb	(0x000)
+#define ONENAND_DEVICE_DENSITY_256Mb	(0x001)
+#define ONENAND_DEVICE_DENSITY_512Mb	(0x002)
+#define ONENAND_DEVICE_DENSITY_1Gb	(0x003)
+#define ONENAND_DEVICE_DENSITY_2Gb	(0x004)
+#define ONENAND_DEVICE_DENSITY_4Gb	(0x005)
+
+#define ONENAND_SYNC_MODE_RM_SYNC	(1 << 1)
+#define ONENAND_SYNC_MODE_WM_SYNC	(1 << 0)
+
+#define ONENAND_TRANS_SPARE_TSRF_INC	(1 << 0)
+
+#define ONENAND_INT_PIN_ENABLE		(1 << 0)
+
+#define ONENAND_ACC_CLOCK_266_133	(0x5)
+#define ONENAND_ACC_CLOCK_166_83	(0x3)
+#define ONENAND_ACC_CLOCK_134_67	(0x3)
+#define ONENAND_ACC_CLOCK_100_50	(0x2)
+#define ONENAND_ACC_CLOCK_60_30		(0x2)
+
+#define ONENAND_FLASH_AUX_WD_DISABLE	(1 << 0)
+
+/*
+ * Datain values for mapped commands
+ */
+#define ONENAND_DATAIN_ERASE_STATUS	(0x00)
+#define ONENAND_DATAIN_ERASE_MULTI	(0x01)
+#define ONENAND_DATAIN_ERASE_SINGLE	(0x03)
+#define ONENAND_DATAIN_ERASE_VERIFY	(0x15)
+#define ONENAND_DATAIN_UNLOCK_START	(0x08)
+#define ONENAND_DATAIN_UNLOCK_END	(0x09)
+#define ONENAND_DATAIN_LOCK_START	(0x0A)
+#define ONENAND_DATAIN_LOCK_END		(0x0B)
+#define ONENAND_DATAIN_LOCKTIGHT_START	(0x0C)
+#define ONENAND_DATAIN_LOCKTIGHT_END	(0x0D)
+#define ONENAND_DATAIN_UNLOCK_ALL	(0x0E)
+#define ONENAND_DATAIN_COPYBACK_SRC	(0x1000)
+#define ONENAND_DATAIN_COPYBACK_DST	(0x2000)
+#define ONENAND_DATAIN_ACCESS_OTP	(0x12)
+#define ONENAND_DATAIN_ACCESS_MAIN	(0x14)
+#define ONENAND_DATAIN_ACCESS_SPARE	(0x13)
+#define ONENAND_DATAIN_ACCESS_MAIN_AND_SPARE	(0x16)
+#define ONENAND_DATAIN_PIPELINE_READ	(0x4000)
+#define ONENAND_DATAIN_PIPELINE_WRITE	(0x4100)
+#define ONENAND_DATAIN_RMW_LOAD		(0x10)
+#define ONENAND_DATAIN_RMW_MODIFY	(0x11)
+
+/*
+ * Command Mapping for S5PC110 OneNAND Controller
+ */
+#define ONENAND_AHB_ADDR		(0xB0000000)
+#define ONENAND_DUMMY_ADDR		(0xB0400000)
+#define ONENAND_CMD_SHIFT		(26)
+#define ONENAND_CMD_MAP_00		(0x0)
+#define ONENAND_CMD_MAP_01		(0x1)
+#define ONENAND_CMD_MAP_10		(0x2)
+#define ONENAND_CMD_MAP_11		(0x3)
+#define ONENAND_CMD_MAP_FF		(0xF)
+
+/*
+ * Mask for Mapping table
+ */
+#define ONENAND_MEM_ADDR_MASK		(0xffffff)
+#define ONENAND_DDP_SHIFT_1Gb		(22)
+#define ONENAND_DDP_SHIFT_2Gb		(23)
+#define ONENAND_DDP_SHIFT_4Gb		(24)
+#define ONENAND_FBA_SHIFT		(13)
+#define ONENAND_FPA_SHIFT		(7)
+#define ONENAND_FSA_SHIFT		(5)
+#define ONENAND_FBA_MASK_128Mb		(0xff)
+#define ONENAND_FBA_MASK_256Mb		(0x1ff)
+#define ONENAND_FBA_MASK_512Mb		(0x1ff)
+#define ONENAND_FBA_MASK_1Gb_DDP	(0x1ff)
+#define ONENAND_FBA_MASK_1Gb		(0x3ff)
+#define ONENAND_FBA_MASK_2Gb_DDP	(0x3ff)
+#define ONENAND_FBA_MASK_2Gb		(0x7ff)
+#define ONENAND_FBA_MASK_4Gb_DDP	(0x7ff)
+#define ONENAND_FBA_MASK_4Gb		(0xfff)
+#define ONENAND_FPA_MASK		(0x3f)
+#define ONENAND_FSA_MASK		(0x3)
+
+#endif
+
+/*
+ * Device ID Register F001h (R)
+ */
+#define ONENAND_DEVICE_DENSITY_SHIFT	(4)
+#define ONENAND_DEVICE_IS_DDP		(1 << 3)
+#define ONENAND_DEVICE_IS_DEMUX		(1 << 2)
+#define ONENAND_DEVICE_VCC_MASK		(0x3)
+
+/*
+ * Version ID Register F002h (R)
+ */
+#define ONENAND_VERSION_PROCESS_SHIFT	(8)
+
+/*
+ * Start Address 1 F100h (R/W)
+ */
+#define ONENAND_DDP_SHIFT		(15)
+#define ONENAND_DDP_CHIP0		(0)
+#define ONENAND_DDP_CHIP1		(1 << ONENAND_DDP_SHIFT)
+
+/*
+ * Start Buffer Register F200h (R/W)
+ */
+#define ONENAND_BSA_MASK		(0x03)
+#define ONENAND_BSA_SHIFT		(8)
+#define ONENAND_BSA_BOOTRAM		(0 << 2)
+#define ONENAND_BSA_DATARAM0		(2 << 2)
+#define ONENAND_BSA_DATARAM1		(3 << 2)
+#define ONENAND_BSC_MASK		(0x03)
+
+/*
+ * Command Register F220h (R/W)
+ */
+#define ONENAND_CMD_READ		(0x00)
+#define ONENAND_CMD_READOOB		(0x13)
+#define ONENAND_CMD_PROG		(0x80)
+#define ONENAND_CMD_PROGOOB		(0x1A)
+#define ONENAND_CMD_UNLOCK		(0x23)
+#define ONENAND_CMD_LOCK		(0x2A)
+#define ONENAND_CMD_LOCK_TIGHT		(0x2C)
+#define ONENAND_CMD_UNLOCK_ALL		(0x27)
+#define ONENAND_CMD_ERASE		(0x94)
+#define ONENAND_CMD_RESET		(0xF0)
+#define ONENAND_CMD_OTP_ACCESS		(0x65)
+#define ONENAND_CMD_READID		(0x90)
+#define ONENAND_CMD_STARTADDR1		(0xE0)
+#define ONENAND_CMD_WP_STATUS		(0xE1)
+#define ONENAND_CMD_PIPELINE_READ	(0x01)
+#define ONENAND_CMD_PIPELINE_WRITE	(0x81)
+
+/*
+ * System Configuration 1 Register F221h (R, R/W)
+ */
+#define ONENAND_SYS_CFG1_SYNC_READ	(1 << 15)
+#define ONENAND_SYS_CFG1_BRL_7		(7 << 12)
+#define ONENAND_SYS_CFG1_BRL_6		(6 << 12)
+#define ONENAND_SYS_CFG1_BRL_5		(5 << 12)
+#define ONENAND_SYS_CFG1_BRL_4		(4 << 12)
+#define ONENAND_SYS_CFG1_BRL_3		(3 << 12)
+#define ONENAND_SYS_CFG1_BRL_10		(2 << 12)
+#define ONENAND_SYS_CFG1_BRL_9		(1 << 12)
+#define ONENAND_SYS_CFG1_BRL_8		(0 << 12)
+#define ONENAND_SYS_CFG1_BRL_SHIFT	(12)
+#define ONENAND_SYS_CFG1_BL_32		(4 << 9)
+#define ONENAND_SYS_CFG1_BL_16		(3 << 9)
+#define ONENAND_SYS_CFG1_BL_8		(2 << 9)
+#define ONENAND_SYS_CFG1_BL_4		(1 << 9)
+#define ONENAND_SYS_CFG1_BL_CONT	(0 << 9)
+#define ONENAND_SYS_CFG1_BL_SHIFT	(9)
+#define ONENAND_SYS_CFG1_NO_ECC		(1 << 8)
+#define ONENAND_SYS_CFG1_RDY		(1 << 7)
+#define ONENAND_SYS_CFG1_INT		(1 << 6)
+#define ONENAND_SYS_CFG1_IOBE		(1 << 5)
+#define ONENAND_SYS_CFG1_RDY_CONF	(1 << 4)
+
+/*
+ * Controller Status Register F240h (R)
+ */
+#define ONENAND_CTRL_ONGO		(1 << 15)
+#define ONENAND_CTRL_LOCK		(1 << 14)
+#define ONENAND_CTRL_LOAD		(1 << 13)
+#define ONENAND_CTRL_PROGRAM		(1 << 12)
+#define ONENAND_CTRL_ERASE		(1 << 11)
+#define ONENAND_CTRL_ERROR		(1 << 10)
+#define ONENAND_CTRL_RSTB		(1 << 7)
+#define ONENAND_CTRL_OTP_L		(1 << 6)
+#define ONENAND_CTRL_OTP_BL		(1 << 5)
+
+/*
+ * Interrupt Status Register F241h (R)
+ */
+#define ONENAND_INT_MASTER		(1 << 15)
+#define ONENAND_INT_READ		(1 << 7)
+#define ONENAND_INT_WRITE		(1 << 6)
+#define ONENAND_INT_ERASE		(1 << 5)
+#define ONENAND_INT_RESET		(1 << 4)
+#define ONENAND_INT_CLEAR		(0 << 0)
+
+/*
+ * NAND Flash Write Protection Status Register F24Eh (R)
+ */
+#define ONENAND_WP_US			(1 << 2)
+#define ONENAND_WP_LS			(1 << 1)
+#define ONENAND_WP_LTS			(1 << 0)
+
+/*
+ * ECC Status Register FF00h (R)
+ */
+#define ONENAND_ECC_1BIT		(1 << 0)
+#define ONENAND_ECC_1BIT_ALL		(0x5555)
+#define ONENAND_ECC_2BIT		(1 << 1)
+#define ONENAND_ECC_2BIT_ALL		(0xAAAA)
+
+/*
+ * One-Time Programmable (OTP)
+ */
+#define ONENAND_OTP_LOCK_OFFSET		(14)
+
+/*************************************************************
+ * End of OneNAND Controller
+ *************************************************************/
+/*
+ * Interrupt
+ */
+#define ELFIN_VIC0_BASE_ADDR		(0xF2000000)
+#define ELFIN_VIC1_BASE_ADDR		(0xF2100000)
+#define ELFIN_VIC2_BASE_ADDR		(0xF2200000)
+
+#define ELFIN_TZIC0_BASE_ADDR		(0xF2800000)
+#define ELFIN_TZIC1_BASE_ADDR		(0xF2900000)
+#define ELFIN_TZIC2_BASE_ADDR		(0xF2A00000)
+
+#define oINTMOD				(0x0C)		// VIC INT SELECT (IRQ or FIQ)
+#define oINTUNMSK			(0x10)		// VIC INT EN (Unmask by writing 1)
+#define oINTMSK				(0x14)		// VIC INT EN CLEAR (Mask by writing 1)
+#define oINTSUBMSK			(0x1C)		// VIC SOFT INT CLEAR
+#define oVECTADDR			(0xF00)		// VIC ADDRESS
+
+/*
+ * Watchdog timer
+ */
+#define ELFIN_WATCHDOG_BASE		0xE2700000
+
+#define WTCON_OFFSET			0x00
+#define WTDAT_OFFSET			0x08
+#define WTCNT_OFFSET			0x0C
+
+#define WTCON_REG			__REG(ELFIN_WATCHDOG_BASE+WTCON_OFFSET)
+#define WTDAT_REG			__REG(ELFIN_WATCHDOG_BASE+WTDAT_OFFSET)
+#define WTCNT_REG			__REG(ELFIN_WATCHDOG_BASE+WTCNT_OFFSET)
+
+/*
+ * UART
+ */
+#define ELFIN_UART_BASE			0XE2900000
+
+#define ELFIN_UART0_OFFSET		0x0000
+#define ELFIN_UART1_OFFSET		0x0400
+#define ELFIN_UART2_OFFSET		0x0800
+#define ELFIN_UART3_OFFSET		0x0c00
+
+#if defined(CONFIG_SERIAL1)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)
+#elif defined(CONFIG_SERIAL2)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART1_OFFSET)
+#elif defined(CONFIG_SERIAL3)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART2_OFFSET)
+#elif defined(CONFIG_SERIAL4)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART3_OFFSET)
+#else
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)
+#endif
+
+#define ULCON_OFFSET			0x00
+#define UCON_OFFSET			0x04
+#define UFCON_OFFSET			0x08
+#define UMCON_OFFSET			0x0C
+#define UTRSTAT_OFFSET			0x10
+#define UERSTAT_OFFSET			0x14
+#define UFSTAT_OFFSET			0x18
+#define UMSTAT_OFFSET			0x1C
+#define UTXH_OFFSET			0x20
+#define URXH_OFFSET			0x24
+#define UBRDIV_OFFSET			0x28
+#define UDIVSLOT_OFFSET			0x2C
+#define UINTP_OFFSET			0x30
+#define UINTSP_OFFSET			0x34
+#define UINTM_OFFSET			0x38
+
+#define UTRSTAT_TX_EMPTY		BIT2
+#define UTRSTAT_RX_READY		BIT0
+#define UART_ERR_MASK			0xF
+
+
+/*
+ * PWM timer
+ */
+#define ELFIN_TIMER_BASE		0xE2500000
+
+#define TCFG0_REG			__REG(0xE2500000)
+#define TCFG1_REG			__REG(0xE2500004)
+#define TCON_REG			__REG(0xE2500008)
+#define TCNTB0_REG			__REG(0xE250000c)
+#define TCMPB0_REG			__REG(0xE2500010)
+#define TCNTO0_REG			__REG(0xE2500014)
+#define TCNTB1_REG			__REG(0xE2500018)
+#define TCMPB1_REG			__REG(0xE250001c)
+#define TCNTO1_REG			__REG(0xE2500020)
+#define TCNTB2_REG			__REG(0xE2500024)
+#define TCMPB2_REG			__REG(0xE2500028)
+#define TCNTO2_REG			__REG(0xE250002c)
+#define TCNTB3_REG			__REG(0xE2500030)
+#define TCMPB3_REG			__REG(0xE2500034)
+#define TCNTO3_REG			__REG(0xE2500038)
+#define TCNTB4_REG			__REG(0xE250003c)
+#define TCNTO4_REG			__REG(0xE2500040)
+#define TINT_CSTAT			__REG(0xE2500044)
+
+
+/*
+ * USB2.0 HS OTG (Chapter 26)
+ */
+#define USBOTG_LINK_BASE		(0xEC000000)
+#define USBOTG_PHY_BASE			(0xEC100000)
+
+#define S5P_OTG_PHYPWR	 		(USBOTG_PHY_BASE + 0x000) /* R/W OTG PHY Power Control Register */
+#define S5P_OTG_PHYCLK 			(USBOTG_PHY_BASE + 0x004) /* R/W OTG PHY Clock Control Register */
+#define S5P_OTG_RSTCON 			(USBOTG_PHY_BASE + 0x008) /* R/W OTG Reset Control Register */
+#define S5P_OTG_PHYTUNE0 		(USBOTG_PHY_BASE + 0x020) /* R/W OTG PHY0 Tuning Register */
+#define S5P_OTG_PHYTUNE1 		(USBOTG_PHY_BASE + 0x024) /* R/W OTG PHY1 Tuning Register */
+
+/* Core Global Register */
+#define S5P_OTG_GOTGCTL 		(USBOTG_LINK_BASE + 0x000) /* R/W OTG Control and Status Register */
+#define S5P_OTG_GOTGINT 		(USBOTG_LINK_BASE + 0x004) /* R/W OTG Interrupt Register */
+#define S5P_OTG_GAHBCFG 		(USBOTG_LINK_BASE + 0x008) /* R/W Core AHB Configuration Register */
+#define S5P_OTG_GUSBCFG 		(USBOTG_LINK_BASE + 0x00C) /* R/W Core USB Configuration Register */
+#define S5P_OTG_GRSTCTL 		(USBOTG_LINK_BASE + 0x010) /* R/W Core Reset Register */
+#define S5P_OTG_GINTSTS 		(USBOTG_LINK_BASE + 0x014) /* R/W Core Interrupt Register */
+#define S5P_OTG_GINTMSK 		(USBOTG_LINK_BASE + 0x018) /* R/W Core Interrupt Mask Register */
+#define S5P_OTG_GRXSTSR 		(USBOTG_LINK_BASE + 0x01C) /* R Receive Status Debug Read Register */
+#define S5P_OTG_GRXSTSP 		(USBOTG_LINK_BASE + 0x020) /* R Receive Status Read/Pop Register */
+#define S5P_OTG_GRXFSIZ 		(USBOTG_LINK_BASE + 0x024) /* R/W Receive FIFO Size Register */
+#define S5P_OTG_GNPTXFSIZ 		(USBOTG_LINK_BASE + 0x028) /* R/W Non-Periodic Transmit FIFO Size Register */
+#define S5P_OTG_GNPTXSTS 		(USBOTG_LINK_BASE + 0x02C) /* R Non-Periodic Transmit FIFO/Queue Status Register */
+#define S5P_OTG_HPTXFSIZ 		(USBOTG_LINK_BASE + 0x100) /* R/W Host Periodic Transmit FIFO Size Register */
+#define S5P_OTG_DPTXFSIZ1 		(USBOTG_LINK_BASE + 0x104) /* R/W Device Periodic Transmit FIFO-1 Size Register */
+#define S5P_OTG_DPTXFSIZ2 		(USBOTG_LINK_BASE + 0x108) /* R/W Device Periodic Transmit FIFO-2 Size Register */
+#define S5P_OTG_DPTXFSIZ3 		(USBOTG_LINK_BASE + 0x10C) /* R/W Device Periodic Transmit FIFO-3 Size Register */
+#define S5P_OTG_DPTXFSIZ4 		(USBOTG_LINK_BASE + 0x110) /* R/W Device Periodic Transmit FIFO-4 Size Register */
+#define S5P_OTG_DPTXFSIZ5 		(USBOTG_LINK_BASE + 0x114) /* R/W Device Periodic Transmit FIFO-5 Size Register */
+#define S5P_OTG_DPTXFSIZ6 		(USBOTG_LINK_BASE + 0x118) /* R/W Device Periodic Transmit FIFO-6 Size Register */
+#define S5P_OTG_DPTXFSIZ7 		(USBOTG_LINK_BASE + 0x11C) /* R/W Device Periodic Transmit FIFO-7 Size Register */
+#define S5P_OTG_DPTXFSIZ8 		(USBOTG_LINK_BASE + 0x120) /* R/W Device Periodic Transmit FIFO-8 Size Register */
+#define S5P_OTG_DPTXFSIZ9 		(USBOTG_LINK_BASE + 0x124) /* R/W Device Periodic Transmit FIFO-9 Size Register */
+#define S5P_OTG_DPTXFSIZ10 		(USBOTG_LINK_BASE + 0x128) /* R/W Device Periodic Transmit FIFO-10 Size Register */
+#define S5P_OTG_DPTXFSIZ11 		(USBOTG_LINK_BASE + 0x12C) /* R/W Device Periodic Transmit FIFO-11 Size Register */
+#define S5P_OTG_DPTXFSIZ12 		(USBOTG_LINK_BASE + 0x130) /* R/W Device Periodic Transmit FIFO-12 Size Register */
+#define S5P_OTG_DPTXFSIZ13 		(USBOTG_LINK_BASE + 0x134) /* R/W Device Periodic Transmit FIFO-13 Size Register */
+#define S5P_OTG_DPTXFSIZ14 		(USBOTG_LINK_BASE + 0x138) /* R/W Device Periodic Transmit FIFO-14 Size Register */
+#define S5P_OTG_DPTXFSIZ15 		(USBOTG_LINK_BASE + 0x13C) /* R/W Device Periodic Transmit FIFO-15 Size Register */
+
+/* Host Mode Register */
+/* Host Global Register */
+#define S5P_OTG_HCFG 			(USBOTG_LINK_BASE + 0x400) /* R/W Host Configuration Register */
+#define S5P_OTG_HFIR 			(USBOTG_LINK_BASE + 0x404) /* R/W Host Frame Interval Register */
+#define S5P_OTG_HFNUM 			(USBOTG_LINK_BASE + 0x408) /* R Host Frame Number/Frame Time Remaining Register */
+
+#define S5P_OTG_HPTXSTS 		(USBOTG_LINK_BASE + 0x410) /* R Host Periodic Transmit FIFO/Queue Status Register */
+#define S5P_OTG_HAINT 			(USBOTG_LINK_BASE + 0x414) /* R Host All Channels Interrupt Register */
+#define S5P_OTG_HAINTMSK 		(USBOTG_LINK_BASE + 0x418) /* R/W Host All Channels Interrupt Mask Register */
+
+/*Host Port Control and Status Register */
+#define S5P_OTG_HPRT 			(USBOTG_LINK_BASE + 0x440) /* R/W Host Port Control and Status Register */
+
+/*Host Channel-Specific Register */
+#define S5P_OTG_HCCHAR0 		(USBOTG_LINK_BASE + 0x500) /* R/W Host Channel 0 Characteristics Register */
+#define S5P_OTG_HCSPLT0 		(USBOTG_LINK_BASE + 0x504) /* R/W Host Channel 0 Spilt Control Register */
+#define S5P_OTG_HCINT0 			(USBOTG_LINK_BASE + 0x508) /* R/W Host Channel 0 Interrupt Register */
+#define S5P_OTG_HCINTMSK0 		(USBOTG_LINK_BASE + 0x50C) /* R/W Host Channel 0 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ0 		(USBOTG_LINK_BASE + 0x510) /* R/W Host Channel 0 Transfer Size Register */
+#define S5P_OTG_HCDMA0 			(USBOTG_LINK_BASE + 0x514) /* R/W Host Channel 0 DMA Address Register */
+#define S5P_OTG_HCCHAR1 		(USBOTG_LINK_BASE + 0x520) /* R/W Host Channel 1 Characteristics Register */
+#define S5P_OTG_HCSPLT1 		(USBOTG_LINK_BASE + 0x524) /* R/W Host Channel 1 Spilt Control Register */
+#define S5P_OTG_HCINT1 			(USBOTG_LINK_BASE + 0x528) /* R/W Host Channel 1 Interrupt Register */
+#define S5P_OTG_HCINTMSK1 		(USBOTG_LINK_BASE + 0x52C) /* R/W Host Channel 1 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ1 		(USBOTG_LINK_BASE + 0x530) /* R/W Host Channel 1 Transfer Size Register */
+#define S5P_OTG_HCDMA1 			(USBOTG_LINK_BASE + 0x534) /* R/W Host Channel 1 DMA Address Register */
+#define S5P_OTG_HCCHAR2 		(USBOTG_LINK_BASE + 0x540) /* R/W Host Channel 2 Characteristics Register */
+#define S5P_OTG_HCSPLT2 		(USBOTG_LINK_BASE + 0x544) /* R/W Host Channel 2 Spilt Control Register */
+#define S5P_OTG_HCINT2 			(USBOTG_LINK_BASE + 0x548) /* R/W Host Channel 2 Interrupt Register */
+#define S5P_OTG_HCINTMSK2 		(USBOTG_LINK_BASE + 0x54C) /* R/W Host Channel 2 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ2 		(USBOTG_LINK_BASE + 0x550) /* R/W Host Channel 2 Transfer Size Register */
+#define S5P_OTG_HCDMA2 			(USBOTG_LINK_BASE + 0x554) /* R/W Host Channel 2 DMA Address Register */
+#define S5P_OTG_HCCHAR3 		(USBOTG_LINK_BASE + 0x560) /* R/W Host Channel 3 Characteristics Register */
+#define S5P_OTG_HCSPLT3 		(USBOTG_LINK_BASE + 0x564) /* R/W Host Channel 3 Spilt Control Register */
+#define S5P_OTG_HCINT3 			(USBOTG_LINK_BASE + 0x568) /* R/W Host Channel 3 Interrupt Register */
+#define S5P_OTG_HCINTMSK3 		(USBOTG_LINK_BASE + 0x56C) /* R/W Host Channel 3 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ3 		(USBOTG_LINK_BASE + 0x570) /* R/W Host Channel 3 Transfer Size Register */
+#define S5P_OTG_HCDMA3 			(USBOTG_LINK_BASE + 0x574) /* R/W Host Channel 3 DMA Address Register */
+#define S5P_OTG_HCCHAR4 		(USBOTG_LINK_BASE + 0x580) /* R/W Host Channel 4 Characteristics Register */
+#define S5P_OTG_HCSPLT4 		(USBOTG_LINK_BASE + 0x584) /* R/W Host Channel 4 Spilt Control Register */
+#define S5P_OTG_HCINT4 			(USBOTG_LINK_BASE + 0x588) /* R/W Host Channel 4 Interrupt Register */
+#define S5P_OTG_HCINTMSK4 		(USBOTG_LINK_BASE + 0x58C) /* R/W Host Channel 4 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ4 		(USBOTG_LINK_BASE + 0x580) /* R/W Host Channel 4 Transfer Size Register */
+#define S5P_OTG_HCDMA4 			(USBOTG_LINK_BASE + 0x584) /* R/W Host Channel 4 DMA Address Register */
+#define S5P_OTG_HCCHAR5 		(USBOTG_LINK_BASE + 0x5A0) /* R/W Host Channel 5 Characteristics Register */
+#define S5P_OTG_HCSPLT5 		(USBOTG_LINK_BASE + 0x5A4) /* R/W Host Channel 5 Spilt Control Register */
+#define S5P_OTG_HCINT5 			(USBOTG_LINK_BASE + 0x5A8) /* R/W Host Channel 5 Interrupt Register */
+#define S5P_OTG_HCINTMSK5 		(USBOTG_LINK_BASE + 0x5AC) /* R/W Host Channel 5 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ5 		(USBOTG_LINK_BASE + 0x5B0) /* R/W Host Channel 5 Transfer Size Register */
+#define S5P_OTG_HCDMA5 			(USBOTG_LINK_BASE + 0x5B4) /* R/W Host Channel 5 DMA Address Register */
+#define S5P_OTG_HCCHAR6 		(USBOTG_LINK_BASE + 0x5C0) /* R/W Host Channel 6 Characteristics Register */
+#define S5P_OTG_HCSPLT6 		(USBOTG_LINK_BASE + 0x5C4) /* R/W Host Channel 6 Spilt Control Register */
+#define S5P_OTG_HCINT6 			(USBOTG_LINK_BASE + 0x5C8) /* R/W Host Channel 6 Interrupt Register */
+#define S5P_OTG_HCINTMSK6 		(USBOTG_LINK_BASE + 0x5CC) /* R/W Host Channel 6 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ6 		(USBOTG_LINK_BASE + 0x5D0) /* R/W Host Channel 6 Transfer Size Register */
+#define S5P_OTG_HCDMA6 			(USBOTG_LINK_BASE + 0x5D4) /* R/W Host Channel 6 DMA Address Register */
+#define S5P_OTG_HCCHAR7 		(USBOTG_LINK_BASE + 0x5E0) /* R/W Host Channel 7 Characteristics Register */
+#define S5P_OTG_HCSPLT7 		(USBOTG_LINK_BASE + 0x5E4) /* R/W Host Channel 7 Spilt Control Register */
+#define S5P_OTG_HCINT7 			(USBOTG_LINK_BASE + 0x5E8) /* R/W Host Channel 7 Interrupt Register */
+#define S5P_OTG_HCINTMSK7 		(USBOTG_LINK_BASE + 0x5EC) /* R/W Host Channel 7 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ7 		(USBOTG_LINK_BASE + 0x5F0) /* R/W Host Channel 7 Transfer Size Register */
+#define S5P_OTG_HCDMA7 			(USBOTG_LINK_BASE + 0x5F4) /* R/W Host Channel 7 DMA Address Register */
+#define S5P_OTG_HCCHAR8 		(USBOTG_LINK_BASE + 0x600) /* R/W Host Channel 8 Characteristics Register */
+#define S5P_OTG_HCSPLT8 		(USBOTG_LINK_BASE + 0x604) /* R/W Host Channel 8 Spilt Control Register */
+#define S5P_OTG_HCINT8 			(USBOTG_LINK_BASE + 0x608) /* R/W Host Channel 8 Interrupt Register */
+#define S5P_OTG_HCINTMSK8 		(USBOTG_LINK_BASE + 0x60C) /* R/W Host Channel 8 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ8 		(USBOTG_LINK_BASE + 0x610) /* R/W Host Channel 8 Transfer Size Register */
+#define S5P_OTG_HCDMA8 			(USBOTG_LINK_BASE + 0x614) /* R/W Host Channel 8 DMA Address Register */
+#define S5P_OTG_HCCHAR9 		(USBOTG_LINK_BASE + 0x620) /* R/W Host Channel 9 Characteristics Register */
+#define S5P_OTG_HCSPLT9 		(USBOTG_LINK_BASE + 0x624) /* R/W Host Channel 9 Spilt Control Register */
+#define S5P_OTG_HCINT9 			(USBOTG_LINK_BASE + 0x628) /* R/W Host Channel 9 Interrupt Register */
+#define S5P_OTG_HCINTMSK9 		(USBOTG_LINK_BASE + 0x62C) /* R/W Host Channel 9 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ9 		(USBOTG_LINK_BASE + 0x630) /* R/W Host Channel 9 Transfer Size Register */
+#define S5P_OTG_HCDMA9 			(USBOTG_LINK_BASE + 0x634) /* R/W Host Channel 9 DMA Address Register */
+#define S5P_OTG_HCCHAR10 		(USBOTG_LINK_BASE + 0x640) /* R/W Host Channel 10 Characteristics Register */
+#define S5P_OTG_HCSPLT10 		(USBOTG_LINK_BASE + 0x644) /* R/W Host Channel 10 Spilt Control Register */
+#define S5P_OTG_HCINT10 		(USBOTG_LINK_BASE + 0x648) /* R/W Host Channel 10 Interrupt Register */
+#define S5P_OTG_HCINTMSK10 		(USBOTG_LINK_BASE + 0x64C) /* R/W Host Channel 10 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ10 		(USBOTG_LINK_BASE + 0x650) /* R/W Host Channel 10 Transfer Size Register */
+#define S5P_OTG_HCDMA10 		(USBOTG_LINK_BASE + 0x654) /* R/W Host Channel 10 DMA Address Register */
+#define S5P_OTG_HCCHAR11 		(USBOTG_LINK_BASE + 0x660) /* R/W Host Channel 11 Characteristics Register */
+#define S5P_OTG_HCSPLT11 		(USBOTG_LINK_BASE + 0x664) /* R/W Host Channel 11 Spilt Control Register */
+#define S5P_OTG_HCINT11 		(USBOTG_LINK_BASE + 0x668) /* R/W Host Channel 11 Interrupt Register */
+#define S5P_OTG_HCINTMSK11 		(USBOTG_LINK_BASE + 0x66C) /* R/W Host Channel 11 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ11 		(USBOTG_LINK_BASE + 0x670) /* R/W Host Channel 11 Transfer Size Register */
+#define S5P_OTG_HCDMA11 		(USBOTG_LINK_BASE + 0x674) /* R/W Host Channel 11 DMA Address Register */
+#define S5P_OTG_HCCHAR12 		(USBOTG_LINK_BASE + 0x680) /* R/W Host Channel 12 Characteristics Register */
+#define S5P_OTG_HCSPLT12 		(USBOTG_LINK_BASE + 0x684) /* R/W Host Channel 12 Spilt Control Register */
+#define S5P_OTG_HCINT12 		(USBOTG_LINK_BASE + 0x688) /* R/W Host Channel 12 Interrupt Register */
+#define S5P_OTG_HCINTMSK12 		(USBOTG_LINK_BASE + 0x68C) /* R/W Host Channel 12 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ12 		(USBOTG_LINK_BASE + 0x690) /* R/W Host Channel 12 Transfer Size Register */
+#define S5P_OTG_HCDMA12 		(USBOTG_LINK_BASE + 0x694) /* R/W Host Channel 12 DMA Address Register */
+#define S5P_OTG_HCCHAR13 		(USBOTG_LINK_BASE + 0x6A0) /* R/W Host Channel 13 Characteristics Register */
+#define S5P_OTG_HCSPLT13 		(USBOTG_LINK_BASE + 0x6A4) /* R/W Host Channel 13 Spilt Control Register */
+#define S5P_OTG_HCINT13 		(USBOTG_LINK_BASE + 0x6A8) /* R/W Host Channel 13 Interrupt Register */
+#define S5P_OTG_HCINTMSK13 		(USBOTG_LINK_BASE + 0x6AC) /* R/W Host Channel 13 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ13 		(USBOTG_LINK_BASE + 0x6B0) /* R/W Host Channel 13 Transfer Size Register */
+#define S5P_OTG_HCDMA13 		(USBOTG_LINK_BASE + 0x6B4) /* R/W Host Channel 13 DMA Address Register */
+#define S5P_OTG_HCCHAR14 		(USBOTG_LINK_BASE + 0x6C0) /* R/W Host Channel 14 Characteristics Register */
+#define S5P_OTG_HCSPLT14 		(USBOTG_LINK_BASE + 0x6C4) /* R/W Host Channel 14 Spilt Control Register */
+#define S5P_OTG_HCINT14 		(USBOTG_LINK_BASE + 0x6C8) /* R/W Host Channel 14 Interrupt Register */
+#define S5P_OTG_HCINTMSK14 		(USBOTG_LINK_BASE + 0x6CC) /* R/W Host Channel 14 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ14	 	(USBOTG_LINK_BASE + 0x6D0) /* R/W Host Channel 14 Transfer Size Register */
+#define S5P_OTG_HCDMA14 		(USBOTG_LINK_BASE + 0x6D4) /* R/W Host Channel 14 DMA Address Register */
+#define S5P_OTG_HCCHAR15 		(USBOTG_LINK_BASE + 0x6E0) /* R/W Host Channel 15 Characteristics Register */
+#define S5P_OTG_HCSPLT15 		(USBOTG_LINK_BASE + 0x6E4) /* R/W Host Channel 15 Spilt Control Register */
+#define S5P_OTG_HCINT15 		(USBOTG_LINK_BASE + 0x6E8) /* R/W Host Channel 15 Interrupt Register */
+#define S5P_OTG_HCINTMSK15 		(USBOTG_LINK_BASE + 0x6EC) /* R/W Host Channel 15 Interrupt Mask Register */
+#define S5P_OTG_HCTSIZ15 		(USBOTG_LINK_BASE + 0x6F0) /* R/W Host Channel 15 Transfer Size Register */
+#define S5P_OTG_HCDMA15 		(USBOTG_LINK_BASE + 0x6F4) /* R/W Host Channel 15 DMA Address Register */
+
+/* Device Global Register */
+#define S5P_OTG_DCFG 			(USBOTG_LINK_BASE + 0x800) /* R/W Device Configuration Register */
+#define S5P_OTG_DCTL 			(USBOTG_LINK_BASE + 0x804) /* R/W Device Control Register */
+#define S5P_OTG_DSTS 			(USBOTG_LINK_BASE + 0x808) /* R Device Status Register */
+#define S5P_OTG_DIEPMSK 		(USBOTG_LINK_BASE + 0x810) /* R/W Device IN Endpoint Common Interrupt Mask Register */
+#define S5P_OTG_DOEPMSK 		(USBOTG_LINK_BASE + 0x814) /* R/W Device OUT Endpoint Common Interrupt Mask Register */
+#define S5P_OTG_DAINT 			(USBOTG_LINK_BASE + 0x818) /* R Device ALL Endpoints Interrupt Register */
+#define S5P_OTG_DAINTMSK 		(USBOTG_LINK_BASE + 0x81C) /* R/W Device ALL Endpoints Interrupt Mask Register */
+#define S5P_OTG_DTKNQR1 		(USBOTG_LINK_BASE + 0x820) /* R Device IN Token Sequence Learning Queue Read Register */
+#define S5P_OTG_DTKNQR2 		(USBOTG_LINK_BASE + 0x824) /* R Device IN Token Sequence Learning Queue Read Register */
+#define S5P_OTG_DVBUSDIS 		(USBOTG_LINK_BASE + 0x828) /* R/W Device VBUS Discharge Time Register */
+#define S5P_OTG_DVBUSPULSE 		(USBOTG_LINK_BASE + 0x82C) /* R/W Device VBUS Pulsing Time Register */
+#define S5P_OTG_DTKNQR3 		(USBOTG_LINK_BASE + 0x830) /* R Device IN Token Sequence Learning Queue Read Register */
+#define S5P_OTG_DTKNQR4 		(USBOTG_LINK_BASE + 0x834) /* R Device IN Token Sequence Learning Queue Read Register */
+
+/* Device Logical IN Endpo int-Specific Registers */
+#define S5P_OTG_DIEPCTL0 		(USBOTG_LINK_BASE + 0x900) /* R/W Device Control IN Endpoint 0 Control Register */
+#define S5P_OTG_DIEPINT0 		(USBOTG_LINK_BASE + 0x908) /* R/W Device IN Endpoint 0 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ0 		(USBOTG_LINK_BASE + 0x910) /* R/W Device IN Endpoint 0 Transfer Size Register */
+#define S5P_OTG_DIEPDMA0 		(USBOTG_LINK_BASE + 0x914) /* R/W Device IN Endpoint 0 DMA Address Register */
+#define S5P_OTG_DIEPCTL1 		(USBOTG_LINK_BASE + 0x920) /* R/W Device Control IN Endpoint 1 Control Register */
+#define S5P_OTG_DIEPINT1 		(USBOTG_LINK_BASE + 0x928) /* R/W Device IN Endpoint 1 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ1 		(USBOTG_LINK_BASE + 0x930) /* R/W Device IN Endpoint 1 Transfer Size Register */
+#define S5P_OTG_DIEPDMA1 		(USBOTG_LINK_BASE + 0x934) /* R/W Device IN Endpoint 1 DMA Address Register */
+#define S5P_OTG_DIEPCTL2 		(USBOTG_LINK_BASE + 0x940) /* R/W Device Control IN Endpoint 2 Control Register */
+#define S5P_OTG_DIEPINT2 		(USBOTG_LINK_BASE + 0x948) /* R/W Device IN Endpoint 2 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ2 		(USBOTG_LINK_BASE + 0x950) /* R/W Device IN Endpoint 2 Transfer Size Register */
+#define S5P_OTG_DIEPDMA2 		(USBOTG_LINK_BASE + 0x954) /* R/W Device IN Endpoint 2 DMA Address Register */
+#define S5P_OTG_DIEPCTL3 		(USBOTG_LINK_BASE + 0x960) /* R/W Device Control IN Endpoint 3 Control Register */
+#define S5P_OTG_DIEPINT3 		(USBOTG_LINK_BASE + 0x968) /* R/W Device IN Endpoint 3 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ3 		(USBOTG_LINK_BASE + 0x970) /* R/W Device IN Endpoint 3 Transfer Size Register */
+#define S5P_OTG_DIEPDMA3 		(USBOTG_LINK_BASE + 0x974) /* R/W Device IN Endpoint 3 DMA Address Register */
+#define S5P_OTG_DIEPCTL4 		(USBOTG_LINK_BASE + 0x980) /* R/W Device Control IN Endpoint 0 Control Register */
+#define S5P_OTG_DIEPINT4 		(USBOTG_LINK_BASE + 0x988) /* R/W Device IN Endpoint 4 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ4 		(USBOTG_LINK_BASE + 0x990) /* R/W Device IN Endpoint 4 Transfer Size Register */
+#define S5P_OTG_DIEPDMA4 		(USBOTG_LINK_BASE + 0x994) /* R/W Device IN Endpoint 4 DMA Address Register */
+#define S5P_OTG_DIEPCTL5 		(USBOTG_LINK_BASE + 0x9A0) /* R/W Device Control IN Endpoint 5 Control Register */
+#define S5P_OTG_DIEPINT5 		(USBOTG_LINK_BASE + 0x9A8) /* R/W Device IN Endpoint 5 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ5 		(USBOTG_LINK_BASE + 0x9B0) /* R/W Device IN Endpoint 5 Transfer Size Register */
+#define S5P_OTG_DIEPDMA5 		(USBOTG_LINK_BASE + 0x9B4) /* R/W Device IN Endpoint 5 DMA Address Register */
+#define S5P_OTG_DIEPCTL6 		(USBOTG_LINK_BASE + 0x9C0) /* R/W Device Control IN Endpoint 6 Control Register */
+#define S5P_OTG_DIEPINT6		(USBOTG_LINK_BASE + 0x9C8) /* R/W Device IN Endpoint 6 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ6		(USBOTG_LINK_BASE + 0x9D0) /* R/W Device IN Endpoint 6 Transfer Size Register */
+#define S5P_OTG_DIEPDMA6		(USBOTG_LINK_BASE + 0x9D4) /* R/W Device IN Endpoint 6 DMA Address Register */
+#define S5P_OTG_DIEPCTL7		(USBOTG_LINK_BASE + 0x9E0) /* R/W Device Control IN Endpoint 7 Control Register */
+#define S5P_OTG_DIEPINT7		(USBOTG_LINK_BASE + 0x9E8) /* R/W Device IN Endpoint 7 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ7		(USBOTG_LINK_BASE + 0x9F0) /* R/W Device IN Endpoint 7 Transfer Size Register */
+#define S5P_OTG_DIEPDMA7		(USBOTG_LINK_BASE + 0x9F4) /* R/W Device IN Endpoint 7 DMA Address Register */
+#define S5P_OTG_DIEPCTL8		(USBOTG_LINK_BASE + 0xA00) /* R/W Device Control IN Endpoint 8 Control Register */
+#define S5P_OTG_DIEPINT8		(USBOTG_LINK_BASE + 0xA08) /* R/W Device IN Endpoint 8 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ8		(USBOTG_LINK_BASE + 0xA10) /* R/W Device IN Endpoint 8 Transfer Size Register */
+#define S5P_OTG_DIEPDMA8		(USBOTG_LINK_BASE + 0xA14) /* R/W Device IN Endpoint 8 DMA Address Register */
+#define S5P_OTG_DIEPCTL9		(USBOTG_LINK_BASE + 0xA20) /* R/W Device Control IN Endpoint 9 Control Register */
+#define S5P_OTG_DIEPINT9		(USBOTG_LINK_BASE + 0xA28) /* R/W Device IN Endpoint 9 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ9		(USBOTG_LINK_BASE + 0xA30) /* R/W Device IN Endpoint 9 Transfer Size Register */
+#define S5P_OTG_DIEPDMA9		(USBOTG_LINK_BASE + 0xA34) /* R/W Device IN Endpoint 9 DMA Address Register */
+#define S5P_OTG_DIEPCTL10		(USBOTG_LINK_BASE + 0xA40) /* R/W Device Control IN Endpoint 10 Control Register */
+#define S5P_OTG_DIEPINT10		(USBOTG_LINK_BASE + 0xA48) /* R/W Device IN Endpoint 10 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ10		(USBOTG_LINK_BASE + 0xA50) /* R/W Device IN Endpoint 10 Transfer Size Register */
+#define S5P_OTG_DIEPDMA10		(USBOTG_LINK_BASE + 0xA54) /* R/W Device IN Endpoint 10 DMA Address Register */
+#define S5P_OTG_DIEPCTL11		(USBOTG_LINK_BASE + 0xA60) /* R/W Device Control IN Endpoint 11 Control Register */
+#define S5P_OTG_DIEPINT11		(USBOTG_LINK_BASE + 0xA68) /* R/W Device IN Endpoint 11 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ11		(USBOTG_LINK_BASE + 0xA70) /* R/W Device IN Endpoint 11 Transfer Size Register */
+#define S5P_OTG_DIEPDMA11		(USBOTG_LINK_BASE + 0xA74) /* R/W Device IN Endpoint 11 DMA Address Register */
+#define S5P_OTG_DIEPCTL12		(USBOTG_LINK_BASE + 0xA80) /* R/W Device Control IN Endpoint 12 Control Register */
+#define S5P_OTG_DIEPINT12		(USBOTG_LINK_BASE + 0xA88) /* R/W Device IN Endpoint 12 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ12		(USBOTG_LINK_BASE + 0xA90) /* R/W Device IN Endpoint 12 Transfer Size Register */
+#define S5P_OTG_DIEPDMA12		(USBOTG_LINK_BASE + 0xA94) /* R/W Device IN Endpoint 12 DMA Address Register */
+#define S5P_OTG_DIEPCTL13		(USBOTG_LINK_BASE + 0xAA0) /* R/W Device Control IN Endpoint 13 Control Register */
+#define S5P_OTG_DIEPINT13		(USBOTG_LINK_BASE + 0xAA8) /* R/W Device IN Endpoint 13 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ13		(USBOTG_LINK_BASE + 0xAB0) /* R/W Device IN Endpoint 13 Transfer Size Register */
+#define S5P_OTG_DIEPDMA13		(USBOTG_LINK_BASE + 0xAB4) /* R/W Device IN Endpoint 13 DMA Address Register */
+#define S5P_OTG_DIEPCTL14		(USBOTG_LINK_BASE + 0xAC0) /* R/W Device Control IN Endpoint 14 Control Register */
+#define S5P_OTG_DIEPINT14		(USBOTG_LINK_BASE + 0xAC8) /* R/W Device IN Endpoint 14 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ14		(USBOTG_LINK_BASE + 0xAD0) /* R/W Device IN Endpoint 14 Transfer Size Register */
+#define S5P_OTG_DIEPDMA14		(USBOTG_LINK_BASE + 0xAD4) /* R/W Device IN Endpoint 14 DMA Address Register */
+#define S5P_OTG_DIEPCTL15		(USBOTG_LINK_BASE + 0xAE0) /* R/W Device Control IN Endpoint 15 Control Register */
+#define S5P_OTG_DIEPINT15		(USBOTG_LINK_BASE + 0xAE8) /* R/W Device IN Endpoint 15 Interrupt Register */
+#define S5P_OTG_DIEPTSIZ15		(USBOTG_LINK_BASE + 0xAF0) /* R/W Device IN Endpoint 15 Transfer Size Register */
+#define S5P_OTG_DIEPDMA15		(USBOTG_LINK_BASE + 0xAF4) /* R/W Device IN Endpoint 15 DMA Address Register */
+
+/* Device Logical OUT Endpoint-Specific Register */
+#define S5P_OTG_DOEPCTL0		(USBOTG_LINK_BASE + 0xB00) /* R/W Device Control OUT Endpoint 0 Control Register */
+#define S5P_OTG_DOEPINT0		(USBOTG_LINK_BASE + 0xB08) /* R/W Device OUT Endpoint 0 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ0		(USBOTG_LINK_BASE + 0xB10) /* R/W Device OUT Endpoint 0 Transfer Size Register */
+#define S5P_OTG_DOEPDMA0		(USBOTG_LINK_BASE + 0xB14) /* R/W Device OUT Endpoint 0 DMA Address Register */
+#define S5P_OTG_DOEPCTL1		(USBOTG_LINK_BASE + 0xB20) /* R/W Device Control OUT Endpoint 1 Control Register */
+#define S5P_OTG_DOEPINT1		(USBOTG_LINK_BASE + 0xB28) /* R/W Device OUT Endpoint 1 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ1		(USBOTG_LINK_BASE + 0xB30) /* R/W Device OUT Endpoint 1 Transfer Size Register */
+#define S5P_OTG_DOEPDMA1		(USBOTG_LINK_BASE + 0xB34) /* R/W Device OUT Endpoint 1 DMA Address Register */
+#define S5P_OTG_DOEPCTL2		(USBOTG_LINK_BASE + 0xB40) /* R/W Device Control OUT Endpoint 2 Control Register */
+#define S5P_OTG_DOEPINT2		(USBOTG_LINK_BASE + 0xB48) /* R/W Device OUT Endpoint 2 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ2		(USBOTG_LINK_BASE + 0xB50) /* R/W Device OUT Endpoint 2 Transfer Size Register */
+#define S5P_OTG_DOEPDMA2		(USBOTG_LINK_BASE + 0xB54) /* R/W Device OUT Endpoint 2 DMA Address Register */
+#define S5P_OTG_DOEPCTL3		(USBOTG_LINK_BASE + 0xB60) /* R/W Device Control OUT Endpoint 3 Control Register */
+#define S5P_OTG_DOEPINT3		(USBOTG_LINK_BASE + 0xB68) /* R/W Device OUT Endpoint 3 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ3		(USBOTG_LINK_BASE + 0xB70) /* R/W Device OUT Endpoint 3 Transfer Size Register */
+#define S5P_OTG_DOEPDMA3		(USBOTG_LINK_BASE + 0xB74) /* R/W Device OUT Endpoint 3 DMA Address Register */
+#define S5P_OTG_DOEPCTL4		(USBOTG_LINK_BASE + 0xB80) /* R/W Device Control OUT Endpoint 4 Control Register */
+#define S5P_OTG_DOEPINT4		(USBOTG_LINK_BASE + 0xB88) /* R/W Device OUT Endpoint 4 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ4		(USBOTG_LINK_BASE + 0xB90) /* R/W Device OUT Endpoint 4 Transfer Size Register */
+#define S5P_OTG_DOEPDMA4		(USBOTG_LINK_BASE + 0xB94) /* R/W Device OUT Endpoint 4 DMA Address Register */
+#define S5P_OTG_DOEPCTL5		(USBOTG_LINK_BASE + 0xBA0) /* R/W Device Control OUT Endpoint 5 Control Register */
+#define S5P_OTG_DOEPINT5		(USBOTG_LINK_BASE + 0xBA8) /* R/W Device OUT Endpoint 5 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ5		(USBOTG_LINK_BASE + 0xBB0) /* R/W Device OUT Endpoint 5 Transfer Size Register */
+#define S5P_OTG_DOEPDMA5		(USBOTG_LINK_BASE + 0xBB4) /* R/W Device OUT Endpoint 5 DMA Address Register */
+#define S5P_OTG_DOEPCTL6		(USBOTG_LINK_BASE + 0xBC0) /* R/W Device Control OUT Endpoint 6 Control Register */
+#define S5P_OTG_DOEPINT6		(USBOTG_LINK_BASE + 0xBC8) /* R/W Device OUT Endpoint 6 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ6		(USBOTG_LINK_BASE + 0xBD0) /* R/W Device OUT Endpoint 6 Transfer Size Register */
+#define S5P_OTG_DOEPDMA6		(USBOTG_LINK_BASE + 0xBD4) /* R/W Device OUT Endpoint 6 DMA Address Register */
+#define S5P_OTG_DOEPCTL7		(USBOTG_LINK_BASE + 0xBE0) /* R/W Device Control OUT Endpoint 7 Control Register */
+#define S5P_OTG_DOEPINT7		(USBOTG_LINK_BASE + 0xBE8) /* R/W Device OUT Endpoint 7 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ7		(USBOTG_LINK_BASE + 0xBF0) /* R/W Device OUT Endpoint 7 Transfer Size Register */
+#define S5P_OTG_DOEPDMA7		(USBOTG_LINK_BASE + 0xBF4) /* R/W Device OUT Endpoint 7 DMA Address Register */
+#define S5P_OTG_DOEPCTL8		(USBOTG_LINK_BASE + 0xC00) /* R/W Device Control OUT Endpoint 8 Control Register */
+#define S5P_OTG_DOEPINT8		(USBOTG_LINK_BASE + 0xC08) /* R/W Device OUT Endpoint 8 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ8		(USBOTG_LINK_BASE + 0xC10) /* R/W Device OUT Endpoint 8 Transfer Size Register */
+#define S5P_OTG_DOEPDMA8		(USBOTG_LINK_BASE + 0xC14) /* R/W Device OUT Endpoint 8 DMA Address Register */
+#define S5P_OTG_DOEPCTL9		(USBOTG_LINK_BASE + 0xC20) /* R/W Device Control OUT Endpoint 9 Control Register */
+#define S5P_OTG_DOEPINT9		(USBOTG_LINK_BASE + 0xC28) /* R/W Device OUT Endpoint 9 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ9		(USBOTG_LINK_BASE + 0xC30) /* R/W Device OUT Endpoint 9 Transfer Size Register */
+#define S5P_OTG_DOEPDMA9		(USBOTG_LINK_BASE + 0xC34) /* R/W Device OUT Endpoint 9 DMA Address Register */
+#define S5P_OTG_DOEPCTL10		(USBOTG_LINK_BASE + 0xC40) /* R/W Device Control OUT Endpoint 10 Control Register */
+#define S5P_OTG_DOEPINT10		(USBOTG_LINK_BASE + 0xC48) /* R/W Device OUT Endpoint 10 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ10		(USBOTG_LINK_BASE + 0xC50) /* R/W Device OUT Endpoint 10 Transfer Size Register */
+#define S5P_OTG_DOEPDMA10		(USBOTG_LINK_BASE + 0xC54) /* R/W Device OUT Endpoint 10 DMA Address Register */
+#define S5P_OTG_DOEPCTL11		(USBOTG_LINK_BASE + 0xC60) /* R/W Device Control OUT Endpoint 11 Control Register */
+#define S5P_OTG_DOEPINT11		(USBOTG_LINK_BASE + 0xC68) /* R/W Device OUT Endpoint 11 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ11		(USBOTG_LINK_BASE + 0xC70) /* R/W Device OUT Endpoint 11 Transfer Size Register */
+#define S5P_OTG_DOEPDMA11		(USBOTG_LINK_BASE + 0xC74) /* R/W Device OUT Endpoint 11 DMA Address Register */
+#define S5P_OTG_DOEPCTL12		(USBOTG_LINK_BASE + 0xC80) /* R/W Device Control OUT Endpoint 12 Control Register */
+#define S5P_OTG_DOEPINT12		(USBOTG_LINK_BASE + 0xC88) /* R/W Device OUT Endpoint 12 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ12		(USBOTG_LINK_BASE + 0xC90) /* R/W Device OUT Endpoint 12 Transfer Size Register */
+#define S5P_OTG_DOEPDMA12		(USBOTG_LINK_BASE + 0xC94) /* R/W Device OUT Endpoint 12 DMA Address Register */
+#define S5P_OTG_DOEPCTL13		(USBOTG_LINK_BASE + 0xCA0) /* R/W Device Control OUT Endpoint 13 Control Register */
+#define S5P_OTG_DOEPINT13		(USBOTG_LINK_BASE + 0xCA8) /* R/W Device OUT Endpoint 13 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ13		(USBOTG_LINK_BASE + 0xCB0) /* R/W Device OUT Endpoint 13 Transfer Size Register */
+#define S5P_OTG_DOEPDMA13		(USBOTG_LINK_BASE + 0xCB4) /* R/W Device OUT Endpoint 13 DMA Address Register */
+#define S5P_OTG_DOEPCTL14		(USBOTG_LINK_BASE + 0xCC0) /* R/W Device Control OUT Endpoint 14 Control Register */
+#define S5P_OTG_DOEPINT14		(USBOTG_LINK_BASE + 0xCC8) /* R/W Device OUT Endpoint 14 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ14		(USBOTG_LINK_BASE + 0xCD0) /* R/W Device OUT Endpoint 14 Transfer Size Register */
+#define S5P_OTG_DOEPDMA14		(USBOTG_LINK_BASE + 0xCD4) /* R/W Device OUT Endpoint 14 DMA Address Register */
+#define S5P_OTG_DOEPCTL15		(USBOTG_LINK_BASE + 0xCE0) /* R/W Device Control OUT Endpoint 15 Control Register */
+#define S5P_OTG_OTG_DOEPINT15		(USBOTG_LINK_BASE + 0xCE8) /* R/W Device OUT Endpoint 15 Interrupt Register */
+#define S5P_OTG_DOEPTSIZ15		(USBOTG_LINK_BASE + 0xCF0) /* R/W Device OUT Endpoint 15 Transfer Size Register */
+#define S5P_OTG_DOEPDMA15		(USBOTG_LINK_BASE + 0xCF4) /* R/W Device OUT Endpoint 15 DMA Address Register */
+
+/* Power and Clock Gating Register */
+#define S5P_OTG_PCGCCTL 		(USBOTG_LINK_BASE + 0xE00) /* R/W Power and Clock Gating Control Register */
+
+/* Endpoint FIFO address */
+#define S5P_OTG_EP0_FIFO		(USBOTG_LINK_BASE + 0x1000)
+
+/* USB Global Interrupt Status register(GINTSTS) setting value */
+#define GINTSTS_WkUpInt		(1<<31)
+#define GINTSTS_OEPInt		(1<<19)
+#define GINTSTS_IEPInt		(1<<18)
+#define GINTSTS_EnumDone	(1<<13)
+#define GINTSTS_USBRst		(1<<12)
+#define GINTSTS_USBSusp		(1<<11)
+#define GINTSTS_RXFLvl		(1<<4)
+
+
+/* PENDING BIT */
+#define BIT_EINT0			(0x1)
+#define BIT_EINT1			(0x1<<1)
+#define BIT_EINT2			(0x1<<2)
+#define BIT_EINT3			(0x1<<3)
+#define BIT_EINT4_7			(0x1<<4)
+#define BIT_EINT8_23			(0x1<<5)
+#define BIT_BAT_FLT			(0x1<<7)
+#define BIT_TICK			(0x1<<8)
+#define BIT_WDT				(0x1<<9)
+#define BIT_TIMER0			(0x1<<10)
+#define BIT_TIMER1			(0x1<<11)
+#define BIT_TIMER2			(0x1<<12)
+#define BIT_TIMER3			(0x1<<13)
+#define BIT_TIMER4			(0x1<<14)
+#define BIT_UART2			(0x1<<15)
+#define BIT_LCD				(0x1<<16)
+#define BIT_DMA0			(0x1<<17)
+#define BIT_DMA1			(0x1<<18)
+#define BIT_DMA2			(0x1<<19)
+#define BIT_DMA3			(0x1<<20)
+#define BIT_SDI				(0x1<<21)
+#define BIT_SPI0			(0x1<<22)
+#define BIT_UART1			(0x1<<23)
+#define BIT_USBH			(0x1<<26)
+#define BIT_IIC				(0x1<<27)
+#define BIT_UART0			(0x1<<28)
+#define BIT_SPI1			(0x1<<29)
+#define BIT_RTC				(0x1<<30)
+#define BIT_ADC				(0x1<<31)
+#define BIT_ALLMSK			(0xFFFFFFFF)
+
+#endif /*__S5PC110_H__*/
diff -urN u-boot-2013.10/Makefile u-boot-2013.10_aston/Makefile
--- u-boot-2013.10/Makefile	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/Makefile	2015-12-25 06:06:16.000000000 -0800
@@ -165,6 +165,9 @@
 CROSS_COMPILE ?=
 endif
 
+CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-
+
+
 # load other configuration
 include $(TOPDIR)/config.mk
 
@@ -783,7 +786,7 @@
 
 # ARM relocations should all be R_ARM_RELATIVE.
 checkarmreloc: $(obj)u-boot
-	@if test "R_ARM_RELATIVE" != \
+#	@if test "R_ARM_RELATIVE" != \
 		"`$(CROSS_COMPILE)readelf -r $< | cut -d ' ' -f 4 | grep R_ARM | sort -u`"; \
 		then echo "$< contains relocations other than \
 		R_ARM_RELATIVE"; false; fi
diff -urN u-boot-2013.10/net/eth.c u-boot-2013.10_aston/net/eth.c
--- u-boot-2013.10/net/eth.c	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/net/eth.c	2016-01-04 21:40:00.000000000 -0800
@@ -11,6 +11,9 @@
 #include <miiphy.h>
 #include <phy.h>
 
+extern int dm9000_initialize(bd_t *bis);
+
+
 void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
 {
 	char *end;
@@ -89,12 +92,20 @@
  * CPU and board-specific Ethernet initializations.  Aliased function
  * signals caller to move on
  */
+
+// 自己定义一个board_eth_init函数，做网卡驱动添加工作
+static int board_eth_init(bd_t *bis)
+{
+	return dm9000_initialize(bis);
+}
+
 static int __def_eth_init(bd_t *bis)
 {
 	return -1;
 }
 int cpu_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));
-int board_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));
+//int board_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));
+
 
 #ifdef CONFIG_API
 static struct {
diff -urN u-boot-2013.10/sd_fusing/C110-EVT1-mkbl1.c u-boot-2013.10_aston/sd_fusing/C110-EVT1-mkbl1.c
--- u-boot-2013.10/sd_fusing/C110-EVT1-mkbl1.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/sd_fusing/C110-EVT1-mkbl1.c	2015-12-22 04:26:15.000000000 -0800
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *              http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+int main (int argc, char *argv[])
+{
+	FILE		*fp;
+	char		*Buf, *a;
+	int		BufLen;
+	int		nbytes, fileLen;
+	unsigned int	checksum;
+	int		i;
+
+//////////////////////////////////////////////////////////////
+	if (argc != 4)
+	{
+		printf("Usage: mkbl1 <source file> <destination file> <size> \n");
+		return -1;
+	}
+
+//////////////////////////////////////////////////////////////
+	BufLen = atoi(argv[3]);
+	Buf = (char *)malloc(BufLen);
+	memset(Buf, 0x00, BufLen);
+	
+//////////////////////////////////////////////////////////////
+	fp = fopen(argv[1], "rb");
+	if( fp == NULL)
+	{
+		printf("source file open error\n");
+		free(Buf);
+		return -1;
+	}
+
+	fseek(fp, 0L, SEEK_END);
+	fileLen = ftell(fp);
+	fseek(fp, 0L, SEEK_SET);
+
+	if ( BufLen > fileLen )
+	{
+		printf("Usage: unsupported size\n");
+		free(Buf);
+		fclose(fp);
+		return -1;
+	}
+
+	nbytes = fread(Buf, 1, BufLen, fp);
+
+	if ( nbytes != BufLen )
+	{
+		printf("source file read error\n");
+		free(Buf);
+		fclose(fp);
+		return -1;
+	}
+
+	fclose(fp);
+
+//////////////////////////////////////////////////////////////
+	a = Buf + 16;
+	for(i = 0, checksum = 0; i < BufLen - 16; i++)
+		checksum += (0x000000FF) & *a++;
+
+	a = Buf + 8;	
+	*( (unsigned int *)a ) = checksum;
+
+//////////////////////////////////////////////////////////////
+	fp = fopen(argv[2], "wb");
+	if (fp == NULL)
+	{
+		printf("destination file open error\n");
+		free(Buf);
+		return -1;
+	}
+
+	a	= Buf;
+	nbytes	= fwrite( a, 1, BufLen, fp);
+
+	if ( nbytes != BufLen )
+	{
+		printf("destination file write error\n");
+		free(Buf);
+		fclose(fp);
+		return -1;
+	}
+
+	free(Buf);
+	fclose(fp);
+
+	return 0;
+}
Binary files u-boot-2013.10/sd_fusing/c110.signedBL1_bin and u-boot-2013.10_aston/sd_fusing/c110.signedBL1_bin differ
diff -urN u-boot-2013.10/sd_fusing/Makefile u-boot-2013.10_aston/sd_fusing/Makefile
--- u-boot-2013.10/sd_fusing/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/sd_fusing/Makefile	2015-12-22 04:26:15.000000000 -0800
@@ -0,0 +1,46 @@
+.SUFFIXES : .c .o
+
+CC		= gcc
+ASM		=
+LINK		=
+LIBCC		= ar
+RM		= rm
+
+#----------------------------------------------------------------------------------------------
+INCPATH		=
+LIBPATH		= 
+OBJPATH		= .
+OUTPATH		= .
+SOURCEPATH	= .
+
+LDFLAGS		= -L$(LIBPATH) 
+#LFLAGS		= -lm
+ASFLAGS		=
+ARFLAGS		= -ruv
+CFLAGS		= -o
+
+LIBS =
+
+#---------------------------------------------------------------------------------------
+SOURCES = $(OBJECTS:.o=.c)
+
+all:
+	$(CC) $(CFLAGS)	mkbl1 C110-EVT1-mkbl1.c 
+	$(CC) $(CFLAGS)	sd_fdisk sd_fdisk.c
+
+#---------------------------------------------------------------------------------------
+.c.o:
+		$(CC) $(CFLAGS) -c $< -o $@
+
+dep:
+		gccmakedep	$(SOURCES)
+
+#---------------------------------------------------------------------------------------
+clean:
+		$(RM)		-rf sd_fdisk
+		$(RM)		-rf mkbl1
+
+new:
+		$(MAKE)		clean
+		$(MAKE)
+
Binary files u-boot-2013.10/sd_fusing/mkbl1 and u-boot-2013.10_aston/sd_fusing/mkbl1 differ
Binary files u-boot-2013.10/sd_fusing/sd_fdisk and u-boot-2013.10_aston/sd_fusing/sd_fdisk differ
diff -urN u-boot-2013.10/sd_fusing/sd_fdisk.c u-boot-2013.10_aston/sd_fusing/sd_fdisk.c
--- u-boot-2013.10/sd_fusing/sd_fdisk.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/sd_fusing/sd_fdisk.c	2015-12-22 04:26:15.000000000 -0800
@@ -0,0 +1,315 @@
+/*
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *              http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define		BLOCK_SIZE			512
+#define		BLOCK_END			0xFFFFFFFF
+#define		_10MB				(10*1024*1024)
+#define		_100MB				(100*1024*1024)
+#define		_8_4GB				(1023*254*63)
+
+#define		CHS_MODE			0
+#define		LBA_MODE			!(CHS_MODE)	
+
+typedef struct
+{
+	int		C_start;
+	int		H_start;
+	int		S_start;
+
+	int		C_end;
+	int		H_end;
+	int		S_end;
+
+	int		available_block;
+	int		unit;
+	int		total_block_count;
+	int		addr_mode;	// LBA_MODE or CHS_MODE
+} SDInfo;
+
+typedef struct
+{
+	unsigned char bootable;
+	unsigned char partitionId;
+
+	int		C_start;
+	int		H_start;
+	int		S_start;
+
+	int		C_end;
+	int		H_end;
+	int		S_end;
+
+	int		block_start;
+	int		block_count;
+	int		block_end;
+} PartitionInfo;
+
+/////////////////////////////////////////////////////////////////
+int calc_unit(int length, SDInfo sdInfo)
+{
+	if (sdInfo.addr_mode == CHS_MODE)
+		return ( (length / BLOCK_SIZE / sdInfo.unit + 1 ) * sdInfo.unit);
+
+	else
+		return ( (length / BLOCK_SIZE) );
+}
+
+/////////////////////////////////////////////////////////////////
+void encode_chs(int C, int H, int S, unsigned char *result)
+{
+	*result++ = (unsigned char) H;
+	*result++ = (unsigned char) ( S + ((C & 0x00000300) >> 2) );
+	*result   = (unsigned char) (C & 0x000000FF); 
+}
+
+/////////////////////////////////////////////////////////////////
+void encode_partitionInfo(PartitionInfo partInfo, unsigned char *result)
+{
+	*result++ = partInfo.bootable;
+
+	encode_chs(partInfo.C_start, partInfo.H_start, partInfo.S_start, result);
+	result +=3;
+
+	*result++ = partInfo.partitionId;
+
+	encode_chs(partInfo.C_end, partInfo.H_end, partInfo.S_end, result);
+	result += 3;
+
+	*((int *)result) = partInfo.block_start;
+	result += 4;	
+	
+	*((int *)result) = partInfo.block_count;
+}
+
+/////////////////////////////////////////////////////////////////
+void get_SDInfo(int block_count, SDInfo *sdInfo)
+{
+	int C, H, S;
+
+	int C_max = 1023, H_max = 255, S_max = 63;
+	int H_start = 1, S_start = 1;
+	int diff_min = 0, diff = 0;
+	
+	if(block_count >= _8_4GB)
+		sdInfo->addr_mode = LBA_MODE;
+	else
+		sdInfo->addr_mode = CHS_MODE;
+
+//-----------------------------------------------------
+	if (sdInfo->addr_mode == CHS_MODE)
+	{
+		diff_min = C_max;
+
+		for (H = H_start; H <= H_max; H++)
+			for (S  = S_start; S <= S_max; S++)
+			{
+				C = block_count / (H * S);
+
+				if ( (C <= C_max) )
+				{
+					diff = C_max - C;
+					if (diff <= diff_min)
+					{
+						diff_min = diff;
+						sdInfo->C_end = C;
+						sdInfo->H_end = H;
+						sdInfo->S_end = S;
+					}
+				}
+			}
+	}
+//-----------------------------------------------------
+	else
+	{
+		sdInfo->C_end = 1023;
+		sdInfo->H_end = 254;
+		sdInfo->S_end = 63;
+	}
+
+//-----------------------------------------------------
+	sdInfo->C_start			= 0;
+	sdInfo->H_start			= 1;
+	sdInfo->S_start			= 1;
+
+	sdInfo->total_block_count	= block_count;
+	sdInfo->available_block		= sdInfo->C_end * sdInfo->H_end * sdInfo->S_end;
+	sdInfo->unit			= sdInfo->H_end * sdInfo->S_end;
+}
+
+/////////////////////////////////////////////////////////////////
+void make_partitionInfo(int LBA_start, int count, SDInfo sdInfo, PartitionInfo *partInfo)
+{
+	int		temp = 0;
+	int		_10MB_unit;
+	
+	partInfo->block_start	= LBA_start;
+
+//-----------------------------------------------------
+	if (sdInfo.addr_mode == CHS_MODE)
+	{
+		partInfo->C_start	= partInfo->block_start / (sdInfo.H_end * sdInfo.S_end);
+		temp			= partInfo->block_start % (sdInfo.H_end * sdInfo.S_end);
+		partInfo->H_start	= temp / sdInfo.S_end;
+		partInfo->S_start	= temp % sdInfo.S_end + 1;
+
+		if (count == BLOCK_END)
+		{
+			_10MB_unit = calc_unit(_10MB, sdInfo);
+			partInfo->block_end	= sdInfo.C_end * sdInfo.H_end * sdInfo.S_end - _10MB_unit - 1;
+			partInfo->block_count	= partInfo->block_end - partInfo->block_start + 1;
+	
+			partInfo->C_end	= partInfo->block_end / sdInfo.unit;
+			partInfo->H_end = sdInfo.H_end - 1;
+			partInfo->S_end = sdInfo.S_end;
+		}
+		else
+		{
+			partInfo->block_count	= count;
+	
+			partInfo->block_end	= partInfo->block_start + count - 1;
+			partInfo->C_end		= partInfo->block_end / sdInfo.unit;
+	
+			temp			= partInfo->block_end % sdInfo.unit;
+			partInfo->H_end		= temp / sdInfo.S_end;
+			partInfo->S_end		= temp % sdInfo.S_end + 1;
+		}
+	}
+//-----------------------------------------------------
+	else
+	{
+		partInfo->C_start	= 0;
+		partInfo->H_start	= 1;
+		partInfo->S_start	= 1;
+
+		partInfo->C_end		= 1023;
+		partInfo->H_end		= 254;
+		partInfo->S_end		= 63;
+	
+		if (count == BLOCK_END)
+		{
+			_10MB_unit = calc_unit(_10MB, sdInfo);
+			partInfo->block_end	= sdInfo.total_block_count - _10MB_unit - 1;
+			partInfo->block_count	= partInfo->block_end - partInfo->block_start + 1;
+
+		}
+		else
+		{
+			partInfo->block_count	= count;
+			partInfo->block_end	= partInfo->block_start + count - 1;
+		}
+	}
+}
+
+/////////////////////////////////////////////////////////////////
+int get_sd_block_count(char *devicefile)
+{
+	FILE	*fp;
+	char	buf[128];
+
+	int	block_count = 0;
+	int	nbytes = 0;
+
+	char *t = "/sys/block/";
+	char sd_size_file[64];
+
+	strcpy(sd_size_file, t);
+	strcat(sd_size_file, &devicefile[5]);
+	strcat(sd_size_file, "/size");
+
+	fp = fopen(sd_size_file, "rb");
+	nbytes = fread(buf, 1, 128, fp);
+	fclose(fp);
+
+	block_count = atoi(buf);
+	
+	return block_count;
+} 
+
+
+/////////////////////////////////////////////////////////////////
+int main(int argc, char *argv[])
+{
+	FILE		*fp;
+
+	int		total_block_count;
+	int		block_start = 0, block_offset = 0;
+
+	SDInfo		sdInfo;
+	PartitionInfo	partInfo[4];
+
+	unsigned char	mbr[512];
+
+	if (argc != 2)
+	{
+		printf("Usage: sd_fdisk <device_file>\n");
+		return -1;
+	}
+///////////////////////////////////////////////////////////	
+	memset((unsigned char *)&sdInfo, 0x00, sizeof(SDInfo));
+
+///////////////////////////////////////////////////////////	
+	total_block_count = get_sd_block_count(argv[1]);
+	get_SDInfo(total_block_count, &sdInfo);
+/*
+///////////////////////////////////////////////////////////
+// 馆靛矫 Unit窜困肺 刚历 拌魂茄促.
+	block_start	= calc_unit(_10MB, sdInfo);
+	block_offset	= calc_unit(_100MB, sdInfo);
+
+///////////////////////////////////////////////////////////	
+	partInfo[0].bootable	= 0x00;
+	partInfo[0].partitionId	= 0x83;
+
+	make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[0]);
+
+///////////////////////////////////////////////////////////	
+	block_start += block_offset;
+	
+	partInfo[1].bootable	= 0x00;
+	partInfo[1].partitionId	= 0x83;
+
+	make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[1]);
+
+///////////////////////////////////////////////////////////	
+	block_start += block_offset;
+	partInfo[2].bootable	= 0x00;
+	partInfo[2].partitionId	= 0x83;
+
+	make_partitionInfo(block_start, block_offset, sdInfo, &partInfo[2]);
+*/
+///////////////////////////////////////////////////////////	
+//	block_start += block_offset;
+	block_start = calc_unit(_10MB, sdInfo);
+
+	block_offset += BLOCK_END;
+	partInfo[3].bootable	= 0x00;
+	partInfo[3].partitionId	= 0x0C;
+
+	make_partitionInfo(block_start, BLOCK_END, sdInfo, &partInfo[3]);
+
+///////////////////////////////////////////////////////////	
+	memset(mbr, 0x00, sizeof(mbr));
+	mbr[510] = 0x55; mbr[511] = 0xAA;
+
+//	encode_partitionInfo(partInfo[0], &mbr[0x1CE]);
+//	encode_partitionInfo(partInfo[1], &mbr[0x1DE]);
+//	encode_partitionInfo(partInfo[2], &mbr[0x1EE]);
+	encode_partitionInfo(partInfo[3], &mbr[0x1BE]);
+	
+	fp = fopen("sd_mbr.dat", "wb");
+	fwrite(mbr, 1, sizeof(mbr), fp);
+	fclose(fp);
+
+	return 0;
+}
+
diff -urN u-boot-2013.10/sd_fusing/sd_fusing2.sh u-boot-2013.10_aston/sd_fusing/sd_fusing2.sh
--- u-boot-2013.10/sd_fusing/sd_fusing2.sh	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/sd_fusing/sd_fusing2.sh	2015-12-22 04:26:15.000000000 -0800
@@ -0,0 +1,98 @@
+#
+# Copyright (C) 2010 Samsung Electronics Co., Ltd.
+#              http://www.samsung.com/
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+####################################
+reader_type1="/dev/sdb"
+reader_type2="/dev/mmcblk0"
+
+if [ -z $1 ]
+then
+    echo "usage: ./sd_fusing.sh <SD Reader's device file>"
+    exit 0
+fi
+
+if [ $1 = $reader_type1 ]
+then 
+    partition1="$11"
+    partition2="$12"
+    partition3="$13"
+    partition4="$14"
+
+elif [ $1 = $reader_type2 ]
+then 
+    partition1="$1p1"
+    partition2="$1p2"
+    partition3="$1p3"
+    partition4="$1p4"
+
+else
+    echo "Unsupported SD reader"
+    exit 0
+fi
+
+if [ -b $1 ]
+then
+    echo "$1 reader is identified."
+else
+    echo "$1 is NOT identified."
+    exit 0
+fi
+
+####################################
+# make partition
+echo "make sd card partition"
+echo "./sd_fdisk $1" 
+./sd_fdisk $1 
+dd iflag=dsync oflag=dsync if=sd_mbr.dat of=$1 
+rm sd_mbr.dat
+ 
+####################################
+# format
+umount $partition1 2> /dev/null
+umount $partition2 2> /dev/null
+umount $partition3 2> /dev/null
+umount $partition4 2> /dev/null
+
+echo "mkfs.vfat -F 32 $partition1"
+mkfs.vfat -F 32 $partition1
+
+#echo "mkfs.ext2 $partition2"
+#mkfs.ext2 $partition2  
+
+#echo "mkfs.ext2 $partition3"
+#mkfs.ext2 $partition3  
+
+#echo "mkfs.ext2 $partition4"
+#mkfs.ext2 $partition4  
+
+####################################
+# mount 
+#umount /media/sd 2> /dev/null
+#mkdir -p /media/sd
+#echo "mount -t vfat $partition1 /media/sd"
+#mount -t vfat $partition1 /media/sd
+
+####################################
+#<BL1 fusing>
+signed_bl1_position=1
+bl2_position=9
+uboot_position=57
+
+echo "BL1 fusing"
+dd iflag=dsync oflag=dsync if=c110.signedBL1_bin of=$1 seek=$signed_bl1_position
+
+####################################
+#<u-boot fusing>
+echo "u-boot fusing"
+dd iflag=dsync oflag=dsync if=../u-boot.bin of=$1 seek=$bl2_position count=16
+dd iflag=dsync oflag=dsync if=../u-boot.bin of=$1 seek=$uboot_position
+
+####################################
+#<Message Display>
+echo "U-boot image is fused successfully."
+echo "Eject SD card and insert it again."
diff -urN u-boot-2013.10/sd_fusing/sd_fusing.sh u-boot-2013.10_aston/sd_fusing/sd_fusing.sh
--- u-boot-2013.10/sd_fusing/sd_fusing.sh	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2013.10_aston/sd_fusing/sd_fusing.sh	2015-12-22 04:26:15.000000000 -0800
@@ -0,0 +1,98 @@
+#
+# Copyright (C) 2010 Samsung Electronics Co., Ltd.
+#              http://www.samsung.com/
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+####################################
+reader_type1="/dev/sdb"
+reader_type2="/dev/mmcblk0"
+
+if [ -z $1 ]
+then
+    echo "usage: ./sd_fusing.sh <SD Reader's device file>"
+    exit 0
+fi
+
+if [ $1 = $reader_type1 ]
+then 
+    partition1="$11"
+    partition2="$12"
+    partition3="$13"
+    partition4="$14"
+
+elif [ $1 = $reader_type2 ]
+then 
+    partition1="$1p1"
+    partition2="$1p2"
+    partition3="$1p3"
+    partition4="$1p4"
+
+else
+    echo "Unsupported SD reader"
+    exit 0
+fi
+
+if [ -b $1 ]
+then
+    echo "$1 reader is identified."
+else
+    echo "$1 is NOT identified."
+    exit 0
+fi
+
+####################################
+# make partition
+echo "make sd card partition"
+echo "./sd_fdisk $1" 
+./sd_fdisk $1 
+dd iflag=dsync oflag=dsync if=sd_mbr.dat of=$1 
+rm sd_mbr.dat
+ 
+####################################
+# format
+umount $partition1 2> /dev/null
+umount $partition2 2> /dev/null
+umount $partition3 2> /dev/null
+umount $partition4 2> /dev/null
+
+echo "mkfs.vfat -F 32 $partition1"
+mkfs.vfat -F 32 $partition1
+
+#echo "mkfs.ext2 $partition2"
+#mkfs.ext2 $partition2  
+
+#echo "mkfs.ext2 $partition3"
+#mkfs.ext2 $partition3  
+
+#echo "mkfs.ext2 $partition4"
+#mkfs.ext2 $partition4  
+
+####################################
+# mount 
+#umount /media/sd 2> /dev/null
+#mkdir -p /media/sd
+#echo "mount -t vfat $partition1 /media/sd"
+#mount -t vfat $partition1 /media/sd
+
+####################################
+#<BL1 fusing>
+bl1_position=1
+uboot_position=49
+
+echo "BL1 fusing"
+./mkbl1 ../u-boot.bin SD-bl1-8k.bin 8192
+dd iflag=dsync oflag=dsync if=SD-bl1-8k.bin of=$1 seek=$bl1_position
+rm SD-bl1-8k.bin
+
+####################################
+#<u-boot fusing>
+echo "u-boot fusing"
+dd iflag=dsync oflag=dsync if=../u-boot.bin of=$1 seek=$uboot_position
+
+####################################
+#<Message Display>
+echo "U-boot image is fused successfully."
+echo "Eject SD card and insert it again."
diff -urN u-boot-2013.10/tools/buildman/buildman u-boot-2013.10_aston/tools/buildman/buildman
--- u-boot-2013.10/tools/buildman/buildman	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/tools/buildman/buildman	1969-12-31 16:00:00.000000000 -0800
@@ -1,123 +0,0 @@
-#!/usr/bin/env python
-#
-# Copyright (c) 2012 The Chromium OS Authors.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-"""See README for more information"""
-
-import multiprocessing
-from optparse import OptionParser
-import os
-import re
-import sys
-import unittest
-
-# Bring in the patman libraries
-our_path = os.path.dirname(os.path.realpath(__file__))
-sys.path.append(os.path.join(our_path, '../patman'))
-
-# Our modules
-import board
-import builder
-import checkpatch
-import command
-import control
-import doctest
-import gitutil
-import patchstream
-import terminal
-import toolchain
-
-def RunTests():
-    import test
-    import doctest
-
-    result = unittest.TestResult()
-    for module in ['toolchain']:
-        suite = doctest.DocTestSuite(module)
-        suite.run(result)
-
-    # TODO: Surely we can just 'print' result?
-    print result
-    for test, err in result.errors:
-        print err
-    for test, err in result.failures:
-        print err
-
-    sys.argv = [sys.argv[0]]
-    suite = unittest.TestLoader().loadTestsFromTestCase(test.TestBuild)
-    result = unittest.TestResult()
-    suite.run(result)
-
-    # TODO: Surely we can just 'print' result?
-    print result
-    for test, err in result.errors:
-        print err
-    for test, err in result.failures:
-        print err
-
-
-parser = OptionParser()
-parser.add_option('-b', '--branch', type='string',
-       help='Branch name to build')
-parser.add_option('-B', '--bloat', dest='show_bloat',
-       action='store_true', default=False,
-       help='Show changes in function code size for each board')
-parser.add_option('-c', '--count', dest='count', type='int',
-       default=-1, help='Run build on the top n commits')
-parser.add_option('-e', '--show_errors', action='store_true',
-       default=False, help='Show errors and warnings')
-parser.add_option('-f', '--force-build', dest='force_build',
-       action='store_true', default=False,
-       help='Force build of boards even if already built')
-parser.add_option('-d', '--detail', dest='show_detail',
-       action='store_true', default=False,
-       help='Show detailed information for each board in summary')
-parser.add_option('-g', '--git', type='string',
-       help='Git repo containing branch to build', default='.')
-parser.add_option('-H', '--full-help', action='store_true', dest='full_help',
-       default=False, help='Display the README file')
-parser.add_option('-j', '--jobs', dest='jobs', type='int',
-       default=None, help='Number of jobs to run at once (passed to make)')
-parser.add_option('-k', '--keep-outputs', action='store_true',
-       default=False, help='Keep all build output files (e.g. binaries)')
-parser.add_option('--list-tool-chains', action='store_true', default=False,
-       help='List available tool chains')
-parser.add_option('-n', '--dry-run', action='store_true', dest='dry_run',
-       default=False, help="Do a try run (describe actions, but no nothing)")
-parser.add_option('-Q', '--quick', action='store_true',
-       default=False, help='Do a rough build, with limited warning resolution')
-parser.add_option('-s', '--summary', action='store_true',
-       default=False, help='Show a build summary')
-parser.add_option('-S', '--show-sizes', action='store_true',
-       default=False, help='Show image size variation in summary')
-parser.add_option('--step', type='int',
-       default=1, help='Only build every n commits (0=just first and last)')
-parser.add_option('-t', '--test', action='store_true', dest='test',
-                  default=False, help='run tests')
-parser.add_option('-T', '--threads', type='int',
-       default=None, help='Number of builder threads to use')
-parser.add_option('-u', '--show_unknown', action='store_true',
-       default=False, help='Show boards with unknown build result')
-
-parser.usage = """buildman -b <branch> [options]
-
-Build U-Boot for all commits in a branch. Use -n to do a dry run"""
-
-(options, args) = parser.parse_args()
-
-# Run our meagre tests
-if options.test:
-    RunTests()
-elif options.full_help:
-    pager = os.getenv('PAGER')
-    if not pager:
-        pager = 'more'
-    fname = os.path.join(os.path.dirname(sys.argv[0]), 'README')
-    command.Run(pager, fname)
-
-# Build selected commits for selected boards
-else:
-    control.DoBuildman(options, args)
diff -urN u-boot-2013.10/tools/patman/patman u-boot-2013.10_aston/tools/patman/patman
--- u-boot-2013.10/tools/patman/patman	2013-10-16 10:08:12.000000000 -0700
+++ u-boot-2013.10_aston/tools/patman/patman	1969-12-31 16:00:00.000000000 -0800
@@ -1,166 +0,0 @@
-#!/usr/bin/env python
-#
-# Copyright (c) 2011 The Chromium OS Authors.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-"""See README for more information"""
-
-from optparse import OptionParser
-import os
-import re
-import sys
-import unittest
-
-# Our modules
-import checkpatch
-import command
-import gitutil
-import patchstream
-import project
-import settings
-import terminal
-import test
-
-
-parser = OptionParser()
-parser.add_option('-a', '--no-apply', action='store_false',
-                  dest='apply_patches', default=True,
-                  help="Don't test-apply patches with git am")
-parser.add_option('-H', '--full-help', action='store_true', dest='full_help',
-       default=False, help='Display the README file')
-parser.add_option('-c', '--count', dest='count', type='int',
-       default=-1, help='Automatically create patches from top n commits')
-parser.add_option('-i', '--ignore-errors', action='store_true',
-       dest='ignore_errors', default=False,
-       help='Send patches email even if patch errors are found')
-parser.add_option('-n', '--dry-run', action='store_true', dest='dry_run',
-       default=False, help="Do a dry run (create but don't email patches)")
-parser.add_option('-p', '--project', default=project.DetectProject(),
-                  help="Project name; affects default option values and "
-                  "aliases [default: %default]")
-parser.add_option('-r', '--in-reply-to', type='string', action='store',
-                  help="Message ID that this series is in reply to")
-parser.add_option('-s', '--start', dest='start', type='int',
-       default=0, help='Commit to start creating patches from (0 = HEAD)')
-parser.add_option('-t', '--ignore-bad-tags', action='store_true',
-                  default=False, help='Ignore bad tags / aliases')
-parser.add_option('--test', action='store_true', dest='test',
-                  default=False, help='run tests')
-parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
-       default=False, help='Verbose output of errors and warnings')
-parser.add_option('--cc-cmd', dest='cc_cmd', type='string', action='store',
-       default=None, help='Output cc list for patch file (used by git)')
-parser.add_option('--no-check', action='store_false', dest='check_patch',
-                  default=True,
-                  help="Don't check for patch compliance")
-parser.add_option('--no-tags', action='store_false', dest='process_tags',
-                  default=True, help="Don't process subject tags as aliaes")
-
-parser.usage = """patman [options]
-
-Create patches from commits in a branch, check them and email them as
-specified by tags you place in the commits. Use -n to do a dry run first."""
-
-
-# Parse options twice: first to get the project and second to handle
-# defaults properly (which depends on project).
-(options, args) = parser.parse_args()
-settings.Setup(parser, options.project, '')
-(options, args) = parser.parse_args()
-
-# Run our meagre tests
-if options.test:
-    import doctest
-
-    sys.argv = [sys.argv[0]]
-    suite = unittest.TestLoader().loadTestsFromTestCase(test.TestPatch)
-    result = unittest.TestResult()
-    suite.run(result)
-
-    for module in ['gitutil', 'settings']:
-        suite = doctest.DocTestSuite(module)
-        suite.run(result)
-
-    # TODO: Surely we can just 'print' result?
-    print result
-    for test, err in result.errors:
-        print err
-    for test, err in result.failures:
-        print err
-
-# Called from git with a patch filename as argument
-# Printout a list of additional CC recipients for this patch
-elif options.cc_cmd:
-    fd = open(options.cc_cmd, 'r')
-    re_line = re.compile('(\S*) (.*)')
-    for line in fd.readlines():
-        match = re_line.match(line)
-        if match and match.group(1) == args[0]:
-            for cc in match.group(2).split(', '):
-                cc = cc.strip()
-                if cc:
-                    print cc
-    fd.close()
-
-elif options.full_help:
-    pager = os.getenv('PAGER')
-    if not pager:
-        pager = 'more'
-    fname = os.path.join(os.path.dirname(sys.argv[0]), 'README')
-    command.Run(pager, fname)
-
-# Process commits, produce patches files, check them, email them
-else:
-    gitutil.Setup()
-
-    if options.count == -1:
-        # Work out how many patches to send if we can
-        options.count = gitutil.CountCommitsToBranch() - options.start
-
-    col = terminal.Color()
-    if not options.count:
-        str = 'No commits found to process - please use -c flag'
-        print col.Color(col.RED, str)
-        sys.exit(1)
-
-    # Read the metadata from the commits
-    if options.count:
-        series = patchstream.GetMetaData(options.start, options.count)
-        cover_fname, args = gitutil.CreatePatches(options.start, options.count,
-                series)
-
-    # Fix up the patch files to our liking, and insert the cover letter
-    series = patchstream.FixPatches(series, args)
-    if series and cover_fname and series.get('cover'):
-        patchstream.InsertCoverLetter(cover_fname, series, options.count)
-
-    # Do a few checks on the series
-    series.DoChecks()
-
-    # Check the patches, and run them through 'git am' just to be sure
-    if options.check_patch:
-        ok = checkpatch.CheckPatches(options.verbose, args)
-    else:
-        ok = True
-    if options.apply_patches:
-        if not gitutil.ApplyPatches(options.verbose, args,
-                                    options.count + options.start):
-            ok = False
-
-    cc_file = series.MakeCcFile(options.process_tags, cover_fname,
-                                not options.ignore_bad_tags)
-
-    # Email the patches out (giving the user time to check / cancel)
-    cmd = ''
-    if ok or options.ignore_errors:
-        cmd = gitutil.EmailPatches(series, cover_fname, args,
-                options.dry_run, not options.ignore_bad_tags, cc_file,
-                in_reply_to=options.in_reply_to)
-
-    # For a dry run, just show our actions as a sanity check
-    if options.dry_run:
-        series.ShowActions(args, cmd, options.process_tags)
-
-    os.remove(cc_file)
